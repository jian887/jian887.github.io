<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[若衣后端手册]]></title>
    <url>%2F2023%2F06%2F09%2F%E8%8B%A5%E8%A1%A3%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[分页实现 前端采用基于bootstrap的轻量级表格插件bootstrap-table(opens new window) 后端采用基于mybatis的轻量级分页插件pageHelper(opens new window) 提示 前后端分页实现流程 #前端调用实现123456789101112var options = &#123; url: prefix + "/list", columns: [&#123; field: 'id', title: '主键' &#125;, &#123; field: 'name', title: '名称' &#125;]&#125;;$.table.init(options); 自定义查询条件参数（特殊情况提前设置查询条件下使用） 12345678910111213141516171819var options = &#123; url: prefix + "/list", queryParams: queryParams, columns: [&#123; field: 'id', title: '主键' &#125;, &#123; field: 'name', title: '名称' &#125;]&#125;;$.table.init(options);function queryParams(params) &#123; var search = $.table.queryParams(params); search.userName = $("#userName").val(); return search;&#125; #后台逻辑实现12345678@PostMapping("/list")@ResponseBodypublic TableDataInfo list(User user)&#123; startPage(); // 此方法配合前端完成自动分页 List&lt;User&gt; list = userService.selectUserList(user); return getDataTable(list);&#125; 常见坑点1：selectPostById莫名其妙的分页。例如下面这段代码 123456789startPage();List&lt;User&gt; list;if(user != null)&#123; list = userService.selectUserList(user);&#125; else &#123; list = new ArrayList&lt;User&gt;();&#125;Post post = postService.selectPostById(1L);return getDataTable(list); 原因分析：这种情况下由于user存在null的情况，就会导致pageHelper生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。 当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。上面这个代码，应该写成下面这个样子才能保证安全。 123456789List&lt;User&gt; list;if(user != null)&#123; startPage(); list = userService.selectUserList(user);&#125; else &#123; list = new ArrayList&lt;User&gt;();&#125;Post post = postService.selectPostById(1L);return getDataTable(list); 常见坑点2：添加了startPage方法。也没有正常分页。例如下面这段代码 1234startPage();Post post = postService.selectPostById(1L);List&lt;User&gt; list = userService.selectUserList(user);return getDataTable(list); 原因分析：只对该语句以后的第一个查询（Select）语句得到的数据进行分页。上面这个代码，应该写成下面这个样子才能正常分页。 1234Post post = postService.selectPostById(1L);startPage();List&lt;User&gt; list = userService.selectUserList(user);return getDataTable(list); 注意 如果改为其他数据库需修改配置application.yml文件中的属性helperDialect=你的数据库 #导入导出在实际开发中经常需要使用导入导出功能来加快数据的操作。在项目中可以使用注解来完成此项功能。 在需要被导入导出的实体类属性添加@Excel注解，目前支持参数如下： #注解参数说明 参数 类型 默认值 描述 sort int Integer.MAX_VALUE 导出时在excel中排序，值越小越靠前 name String 空 导出到Excel中的名字 dateFormat String 空 日期格式, 如: yyyy-MM-dd dictType String 空 如果是字典类型，请设置字典的type值 (如: sys_user_sex) readConverterExp String 空 读取内容转表达式 (如: 0=男,1=女,2=未知) separator String , 分隔符，读取字符串组内容 scale int -1 BigDecimal 精度 默认:-1(默认不开启BigDecimal格式化) roundingMode int BigDecimal.ROUND_HALF_EVEN BigDecimal 舍入规则 默认:BigDecimal.ROUND_HALF_EVEN celltype Enum Type.STRING 导出类型（0数字 1字符串 2图片） height String 14 导出时在excel中每个列的高度 单位为字符 width String 16 导出时在excel中每个列的宽 单位为字符 suffix String 空 文字后缀,如% 90 变成90% defaultValue String 空 当值为空时,字段的默认值 prompt String 空 提示信息 combo String Null 设置只能选择不能输入的列内容 headerBackgroundColor Enum IndexedColors.GREY_50_PERCENT 导出列头背景色IndexedColors.XXXX headerColor Enum IndexedColors.WHITE 导出列头字体颜色IndexedColors.XXXX backgroundColor Enum IndexedColors.WHITE 导出单元格背景色IndexedColors.XXXX color Enum IndexedColors.BLACK 导出单元格字体颜色IndexedColors.XXXX targetAttr String 空 另一个类中的属性名称,支持多级获取,以小数点隔开 isStatistics boolean false 是否自动统计数据,在最后追加一行统计数据总和 type Enum Type.ALL 字段类型（0：导出导入；1：仅导出；2：仅导入） align Enum HorizontalAlignment.CENTER 导出对齐方式HorizontalAlignment.XXXX handler Class ExcelHandlerAdapter.class 自定义数据处理器 args String[] {} 自定义数据处理器参数 #导出实现流程1、前端调用封装好的方法$.table.init，传入后台exportUrl 123456789101112var options = &#123; exportUrl: prefix + "/export", columns: [&#123; field: 'id', title: '主键' &#125;, &#123; field: 'name', title: '名称' &#125;]&#125;;$.table.init(options); 2、添加导出按钮事件 123&lt;a class="btn btn-warning" onclick="$.table.exportExcel()"&gt; &lt;i class="fa fa-download"&gt;&lt;/i&gt; 导出&lt;/a&gt; 3、在实体变量上添加@Excel注解 1234567891011121314151617@Excel(name = "用户序号", prompt = "用户编号")private Long userId;@Excel(name = "用户名称")private String userName;@Excel(name = "用户性别", readConverterExp = "0=男,1=女,2=未知")private String sex;@Excel(name = "用户头像", cellType = ColumnType.IMAGE)private String avatar;@Excel(name = "帐号状态", dictType = "sys_normal_disable")private String status;@Excel(name = "最后登陆时间", width = 30, dateFormat = "yyyy-MM-dd HH:mm:ss")private Date loginDate; 4、在Controller添加导出方法 12345678@PostMapping("/export")@ResponseBodypublic AjaxResult export(User user)&#123; List&lt;User&gt; list = userService.selectUserList(user); ExcelUtil&lt;User&gt; util = new ExcelUtil&lt;User&gt;(User.class); return util.exportExcel(list, "用户数据");&#125; 提示 导出默认流程是先创建一个临时文件，等待前端请求下载结束后马上删除这个临时文件。如遇到迅雷这种二次请求下载应用可能会导致文件已经被删除，我们也可以改成流的形式返回给前端。 参考实现 - 如何解决导出使用下载插件出现异常 #导入实现流程1、前端调用封装好的方法$.table.init，传入后台importUrl。 123456789101112var options = &#123; importUrl: prefix + "/importData", columns: [&#123; field: 'id', title: '主键' &#125;, &#123; field: 'name', title: '名称' &#125;]&#125;;$.table.init(options); 2、添加导入按钮事件 123&lt;a class="btn btn-info" onclick="$.table.importExcel()"&gt; &lt;i class="fa fa-upload"&gt;&lt;/i&gt; 导入&lt;/a&gt; 3、添加导入前端代码，form默认id为importForm，也可指定importExcel(id) 123456789101112131415&lt;!-- 导入区域 --&gt;&lt;script id="importTpl" type="text/template"&gt;&lt;form enctype="multipart/form-data" class="mt20 mb10"&gt; &lt;div class="col-xs-offset-1"&gt; &lt;input type="file" id="file" name="file"/&gt; &lt;div class="mt10 pt5"&gt; &lt;input type="checkbox" id="updateSupport" name="updateSupport" title="如果登录账户已经存在，更新这条数据。"&gt; 是否更新已经存在的用户数据 &amp;nbsp; &lt;a onclick="$.table.importTemplate()" class="btn btn-default btn-xs"&gt;&lt;i class="fa fa-file-excel-o"&gt;&lt;/i&gt; 下载模板&lt;/a&gt; &lt;/div&gt; &lt;font color="red" class="pull-left mt10"&gt; 提示：仅允许导入“xls”或“xlsx”格式文件！ &lt;/font&gt; &lt;/div&gt;&lt;/form&gt;&lt;/script&gt; 4、在实体变量上添加@Excel注解，默认为导出导入，也可以单独设置仅导入Type.IMPORT 12345678910111213141516171819@Excel(name = "用户序号")private Long id;@Excel(name = "部门编号", type = Type.IMPORT)private Long deptId;@Excel(name = "用户名称")private String userName;/** 导出部门多个对象 */@Excels(&#123; @Excel(name = "部门名称", targetAttr = "deptName", type = Type.EXPORT), @Excel(name = "部门负责人", targetAttr = "leader", type = Type.EXPORT)&#125;)private SysDept dept;/** 导出部门单个对象 */@Excel(name = "部门名称", targetAttr = "deptName", type = Type.EXPORT)private SysDept dept; 5、在Controller添加导入方法，updateSupport属性为是否存在则覆盖（可选） 12345678910@PostMapping("/importData")@ResponseBodypublic AjaxResult importData(MultipartFile file, boolean updateSupport) throws Exception&#123; ExcelUtil&lt;SysUser&gt; util = new ExcelUtil&lt;SysUser&gt;(SysUser.class); List&lt;SysUser&gt; userList = util.importExcel(file.getInputStream()); String operName = ShiroUtils.getSysUser().getLoginName(); String message = userService.importUser(userList, updateSupport, operName); return AjaxResult.success(message);&#125; 提示 也可以直接到main运行此方法测试。 123InputStream is = new FileInputStream(new File("D:\\test.xlsx"));ExcelUtil&lt;Entity&gt; util = new ExcelUtil&lt;Entity&gt;(Entity.class);List&lt;Entity&gt; userList = util.importExcel(is); #自定义标题信息有时候我们希望导出表格包含标题信息，我们可以这样做。 导出用户管理表格新增标题（用户列表） 123456public AjaxResult export(SysUser user)&#123; List&lt;SysUser&gt; list = userService.selectUserList(user); ExcelUtil&lt;SysUser&gt; util = new ExcelUtil&lt;SysUser&gt;(SysUser.class); return util.exportExcel(list, "用户数据", "用户列表");&#125; 导入表格包含标题处理方式，其中1表示标题占用行数，根据实际情况填写。 12345678public AjaxResult importData(MultipartFile file, boolean updateSupport) throws Exception&#123; ExcelUtil&lt;SysUser&gt; util = new ExcelUtil&lt;SysUser&gt;(SysUser.class); List&lt;SysUser&gt; userList = util.importExcel(file.getInputStream(), 1); String operName = SecurityUtils.getUsername(); String message = userService.importUser(userList, updateSupport, operName); return AjaxResult.success(message);&#125; #自定义数据处理器有时候我们希望数据展现为一个特殊的格式，或者需要对数据进行其它处理。Excel注解提供了自定义数据处理器以满足各种业务场景。而实现一个数据处理器也是非常简单的。如下： 1、在实体类用Excel注解handler属性指定自定义的数据处理器 12345public class User extends BaseEntity&#123; @Excel(name = "用户名称", handler = MyDataHandler.class, args = &#123; "aaa", "bbb" &#125;) private String userName;&#125; 2、编写数据处理器MyDataHandler继承ExcelHandlerAdapter，返回值为处理后的值。 12345678910public class MyDataHandler implements ExcelHandlerAdapter&#123; @Override public Object format(Object value, String[] args) &#123; // value 为单元格数据值 // args 为excel注解args参数组 return value; &#125;&#125; #自定义隐藏属性列有时候我们希望对列信息根据业务去动态显示，那么我们可以进行如下处理。 示例：对用户进行条件判断，符合条件则隐藏属性。导出的文件则不会显示此列信息。 1234567891011121314151617@PostMapping("/export")public void export(HttpServletResponse response, SysUser user)&#123; List&lt;SysUser&gt; list = userService.selectUserList(user); ExcelUtil&lt;SysUser&gt; util = new ExcelUtil&lt;SysUser&gt;(SysUser.class); if (条件A) &#123; // 不显示用户ID（单个） util.hideColumn("userId"); &#125; else if (条件B) &#123; // 不显示用户名称、用户手机（多个） util.hideColumn("userId", "phonenumber"); &#125; &#125; else if (条件C) &#123; // 不显示用户邮箱、部门名称（子对象） util.hideColumn("email", "dept.deptName"); &#125; util.exportExcel(response, list, "用户数据");&#125; #导出对象的子列表有时候对象里面还包含集合列表，例如用户管理包含多个角色需要导出，那么我们可以进行如下处理。 SysUser.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SysUser&#123; @Excel(name = "用户编号", cellType = ColumnType.NUMERIC, width = 20, needMerge = true) private String userId; @Excel(name = "用户名称", width = 20, needMerge = true) private String userName; @Excel(name = "邮箱", width = 20, needMerge = true) private String email; @Excel(name = "角色") private List&lt;SysRole&gt; roles; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public List&lt;SysRole&gt; getRoles() &#123; return roles; &#125; public void setRoles(List&lt;SysRole&gt; roles) &#123; this.roles = roles; &#125;&#125; SysRole.java 123456789101112131415161718192021222324252627282930313233343536373839404142public class SysRole&#123; @Excel(name = "角色编号", cellType = ColumnType.NUMERIC) private String roleId; @Excel(name = "角色名称") private String roleName; @Excel(name = "角色字符") private String roleKey; public String getRoleId() &#123; return roleId; &#125; public void setRoleId(String roleId) &#123; this.roleId = roleId; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getRoleKey() &#123; return roleKey; &#125; public void setRoleKey(String roleKey) &#123; this.roleKey = roleKey; &#125;&#125; 测试验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class Test&#123; public static void main(String[] args) throws IOException &#123; List&lt;SysUser&gt; userList = new ArrayList&lt;SysUser&gt;(); SysUser user1 = new SysUser(); List&lt;SysRole&gt; roles1 = new ArrayList&lt;SysRole&gt;(); SysRole role1 = new SysRole(); role1.setRoleId("1"); role1.setRoleName("超级管理员"); role1.setRoleKey("admin_key"); SysRole role2 = new SysRole(); role2.setRoleId("2"); role2.setRoleName("普通角色"); role2.setRoleKey("common_key"); SysRole role3 = new SysRole(); role3.setRoleId("3"); role3.setRoleName("测试角色"); role3.setRoleKey("test_key"); SysRole role4 = new SysRole(); role4.setRoleId("4"); role4.setRoleName("查询角色"); role4.setRoleKey("query_key"); roles1.add(role1); roles1.add(role2); roles1.add(role3); roles1.add(role4); user1.setUserId("1"); user1.setUserName("admin"); user1.setEmail("ry@qq.com"); user1.setRoles(roles1); userList.add(user1); SysUser user2 = new SysUser(); List&lt;SysRole&gt; roles2 = new ArrayList&lt;SysRole&gt;(); SysRole role21 = new SysRole(); role21.setRoleId("4"); role21.setRoleName("研发角色"); role21.setRoleKey("yanfa_key"); SysRole role22 = new SysRole(); role22.setRoleId("5"); role22.setRoleName("销售角色"); role22.setRoleKey("xiaoshou_key"); roles2.add(role21); roles2.add(role22); user2.setUserId("2"); user2.setUserName("ry"); user2.setEmail("admin@qq.com"); user2.setRoles(roles2); userList.add(user2); SysUser user3 = new SysUser(); List&lt;SysRole&gt; roles3 = new ArrayList&lt;SysRole&gt;(); SysRole role31 = new SysRole(); role31.setRoleId("4"); role31.setRoleName("张三角色"); role31.setRoleKey("zs_key"); SysRole role32 = new SysRole(); role32.setRoleId("5"); role32.setRoleName("李四角色"); role32.setRoleKey("ls_key"); roles3.add(role31); roles3.add(role32); user3.setUserId("3"); user3.setUserName("test"); user3.setEmail("test@qq.com"); user3.setRoles(roles3); userList.add(user3); ExcelUtil&lt;SysUser&gt; util = new ExcelUtil&lt;SysUser&gt;(SysUser.class); AjaxResult ajax = util.exportExcel(userList, "用户数据", "用户数据"); System.out.println(ajax.toString()); &#125;&#125; 导出文件结果 #上传下载首先创建一张上传文件的表，例如： 1234567drop table if exists sys_file_info;create table sys_file_info ( file_id int(11) not null auto_increment comment '文件id', file_name varchar(50) default '' comment '文件名称', file_path varchar(255) default '' comment '文件路径', primary key (file_id)) engine=innodb auto_increment=1 default charset=utf8 comment = '文件信息表'; #上传实现流程1、代码生成sys_file_info表相关代码并复制到对应目录。 2、参考示例修改代码。 1&lt;input id="filePath" name="filePath" class="form-control" type="file"&gt; 123456789101112131415161718192021222324252627function submitHandler() &#123; if ($.validate.form()) &#123; uploadFile(); &#125;&#125;function uploadFile() &#123; var formData = new FormData(); if ($('#filePath')[0].files[0] == null) &#123; $.modal.alertWarning("请先选择文件路径"); return false; &#125; formData.append('fileName', $("input[name='fileName']").val()); formData.append('file', $('#filePath')[0].files[0]); $.ajax(&#123; url: prefix + "/add", type: 'post', cache: false, data: formData, processData: false, contentType: false, dataType: "json", success: function(result) &#123; $.operate.successCallback(result); &#125; &#125;);&#125; 3、在SysFileInfoController添加对应上传方法 1234567891011@PostMapping("/add")@ResponseBodypublic AjaxResult addSave(@RequestParam("file") MultipartFile file, SysFileInfo fileInfo) throws IOException&#123; // 上传文件路径 String filePath = RuoYiConfig.getUploadPath(); // 上传并返回新文件名称 String fileName = FileUploadUtils.upload(filePath, file); fileInfo.setFilePath(fileName); return toAjax(sysFileInfoService.insertSysFileInfo(fileInfo));&#125; 4、上传成功后需要预览可以对该属性格式化处理 1234567&#123; field : 'filePath', title: '文件预览', formatter: function(value, row, index) &#123; return $.table.imageView(value); &#125;&#125;, 如需对文件格式控制，设置application.yml中的multipart属性 1234567# 文件上传servlet: multipart: # 单个文件大小 max-file-size: 10MB # 设置总上传的文件大小 max-request-size: 20MB 注意：如果只是单纯的上传一张图片没有其他参数可以使用通用方法 /common/upload请求处理方法 com.ruoyi.web.controller.common.CommonController #下载实现流程1、参考示例代码。 123function downloadFile(value)&#123; window.location.href = ctx + "common/download/resource?resource=" + value;&#125; 2、参考Controller下载方法 12345678910111213141516171819/** * 本地资源通用下载 */@GetMapping("/common/download/resource")public void resourceDownload(String resource, HttpServletRequest request, HttpServletResponse response) throws Exception&#123; // 本地资源路径 String localPath = Global.getProfile(); // 数据库资源地址 String downloadPath = localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX); // 下载名称 String downloadName = StringUtils.substringAfterLast(downloadPath, "/"); response.setCharacterEncoding("utf-8"); response.setContentType("multipart/form-data"); response.setHeader("Content-Disposition", "attachment;fileName=" + FileUtils.setFileDownloadHeader(request, downloadName)); FileUtils.writeBytes(downloadPath, response.getOutputStream());&#125; 权限注解Shiro注解权限控制 @RequiresAuthentication使用该注解标注的类，实例，方法在访问或调用时，当前Subject必须在当前session中已经过认证。 @RequiresGuest使用该注解标注的类，实例，方法在访问或调用时，当前Subject可以是gust身份，不需要经过认证或者在原先的session中存在记录。 @RequiresPermissions当前Subject需要拥有某些特定的权限时，才能执行被该注解标注的方法。如果当前Subject不具有这样的权限，则方法不会被执行。 @RequiresRoles当前Subject必须拥有所有指定的角色时，才能访问被该注解标注的方法。如果当天Subject不同时拥有所有指定角色，则方法不会执行还会抛出AuthorizationException异常。 @RequiresUser当前Subject必须是应用的用户，才能访问或调用被该注解标注的类，实例，方法。 @RequiresRoles@RequiresRoles注解用于配置接口要求用户拥有某（些）角色才可访问，它拥有两个参数 参数 类型 描述 value String[] 角色列表 logical Logical 角色之间的判断关系，默认为Logical.AND 示例1: 以下代码表示必须拥有admin角色才可访问 12345@RequiresRoles("admin")public AjaxResult save(...)&#123; return AjaxResult.success(...);&#125; 示例2: 以下代码表示必须拥有admin和common角色才可访问 12345@RequiresRoles(&#123;"admin", "common"&#125;)public AjaxResult save(...)&#123; return AjaxResult.success(...);&#125; 示例3: 以下代码表示需要拥有admin或common角色才可访问 12345@RequiresRoles(value = &#123;"admin", "common"&#125;, logical = Logical.OR)public AjaxResult save(...)&#123; return AjaxResult.success(...);&#125; #@RequiresPermissions@RequiresPermissions注解用于配置接口要求用户拥有某（些）权限才可访问，它拥有两个参数 参数 类型 描述 value String[] 权限列表 logical Logical 权限之间的判断关系，默认为Logical.AND 示例1: 以下代码表示必须拥有system:user:add权限才可访问 12345@RequiresPermissions("system:user:add")public AjaxResult save(...) &#123; return AjaxResult.success(...);&#125; 示例2: 以下代码表示必须拥有system:user:add和system:user:edit权限才可访问 12345@RequiresPermissions(&#123;"system:user:add", "system:user:edit"&#125;)public AjaxResult save(...)&#123; return AjaxResult.success(...);&#125; 示例3: 以下代码表示需要拥有system:user:add或system:user:edit权限才可访问 12345@RequiresPermissions(value = &#123;"system:user:add", "system:user:edit"&#125;, logical = Logical.OR)public AjaxResult save(...)&#123; return AjaxResult.success(...);&#125; 提示 Shiro的认证注解处理是有内定的处理顺序的，如果有个多个注解的话，前面的通过了会继续检查后面的，若不通过则直接返回，处理顺序依次为（与实际声明顺序无关） RequiresRoles、RequiresPermissions、RequiresAuthentication、RequiresUser、RequiresGuest。例如：你同时声明了RequiresRoles和RequiresPermissions，那就要求拥有此角色的同时还得拥有相应的权限。 #编程式判断资源访问权限示例: 编程式判断资源访问权限 123456789Subject subject = ShiroUtils.getSubject();subject.isPermitted(permission) // 验证是否有资源权限subject.isPermittedAll(permissions) // 验证是否有资源权限（列表）// 例如：if (subject.isPermitted("sys:user:edit"))&#123; System.out.pirntln("当前用户有编辑用户权限");&#125; 示例: 编程式判断角色访问权限 123456789Subject subject = ShiroUtils.getSubject();subject.hasRole(role) // 验证是否有角色权限subject.hasRoles(roles) // 验证是否有角色权限（列表）// 例如：if (subject.hasRole("admin"))&#123; System.out.pirntln("当前用户有admin角色权限");&#125; #基于URI判断用户访问权限示例: 基于URI判断用户访问权限 12345// 验证是否有资源权限filterChainDefinitionMap.put("/system/user/add", "perms[system:user:add]");filterChainDefinitionMap.put("/system/user/**", "perms[system:user:*]");// 验证是否有资源权限（列表），相当于isPermitedAll()方法。filterChainDefinitionMap.put("/system/user/**", "perms[system:user:add,system:user:edit]"); 示例: 基于URI判断角色访问权限 1234// 验证是否有角色权限filterChainDefinitionMap.put("/system/user/**", "roles[admin]");// 验证是否有角色权限（列表），相当于hasAllRoles()方法。filterChainDefinitionMap.put("/system/user/**", "roles[admin,common]"); URI通配符 123? ：匹配一个字符。* ：匹配零个或多个字符串。** ：匹配路径中的零个或多个路径。 事务管理新建的Spring Boot项目中，一般都会引用spring-boot-starter或者spring-boot-starter-web，而这两个起步依赖中都已经包含了对于spring-boot-starter-jdbc或spring-boot-starter-data-jpa的依赖。 当我们使用了这两个依赖的时候，框架会自动默认分别注入DataSourceTransactionManager或JpaTransactionManager。 所以我们不需要任何额外配置就可以用@Transactional注解进行事务的使用。 提示 @Transactional注解只能应用到public可见度的方法上，可以被应用于接口定义和接口方法，方法会覆盖类上面声明的事务。 例如用户新增需要插入用户表、用户与岗位关联表、用户与角色关联表，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作， 这样可以防止出现脏数据，就可以使用事务让它实现回退。做法非常简单，我们只需要在方法或类添加@Transactional注解即可。 1234567891011@Transactionalpublic int insertUser(User user)&#123; // 新增用户信息 int rows = userMapper.insertUser(user); // 新增用户岗位关联 insertUserPost(user); // 新增用户与角色管理 insertUserRole(user); return rows;&#125; 常见坑点1：遇到检查异常时，事务开启，也无法回滚。 例如下面这段代码，用户依旧增加成功，并没有因为后面遇到检查异常而回滚！！ 1234567891011121314151617@Transactionalpublic int insertUser(User user) throws Exception&#123; // 新增用户信息 int rows = userMapper.insertUser(user); // 新增用户岗位关联 insertUserPost(user); // 新增用户与角色管理 insertUserRole(user); // 模拟抛出SQLException异常 boolean flag = true; if (flag) &#123; throw new SQLException("发生异常了.."); &#125; return rows;&#125; 原因分析：因为Spring的默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。如果想针对检查异常进行事务回滚，可以在@Transactional注解里使用 rollbackFor属性明确指定异常。例如下面这样，就可以正常回滚： 1234567891011121314151617@Transactional(rollbackFor = Exception.class)public int insertUser(User user) throws Exception&#123; // 新增用户信息 int rows = userMapper.insertUser(user); // 新增用户岗位关联 insertUserPost(user); // 新增用户与角色管理 insertUserRole(user); // 模拟抛出SQLException异常 boolean flag = true; if (flag) &#123; throw new SQLException("发生异常了.."); &#125; return rows;&#125; 常见坑点2： 在业务层捕捉异常后，发现事务不生效。 这是许多新手都会犯的一个错误，在业务层手工捕捉并处理了异常，你都把异常“吃”掉了，Spring自然不知道这里有错，更不会主动去回滚数据。例如：下面这段代码直接导致用户新增的事务回滚没有生效。 12345678910111213141516171819202122232425@Transactionalpublic int insertUser(User user) throws Exception&#123; // 新增用户信息 int rows = userMapper.insertUser(user); // 新增用户岗位关联 insertUserPost(user); // 新增用户与角色管理 insertUserRole(user); // 模拟抛出SQLException异常 boolean flag = true; if (flag) &#123; try &#123; // 谨慎：尽量不要在业务层捕捉异常并处理 throw new SQLException("发生异常了.."); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return rows;&#125; 推荐做法：在业务层统一抛出异常，然后在控制层统一处理。 1234567891011121314151617@Transactionalpublic int insertUser(User user) throws Exception&#123; // 新增用户信息 int rows = userMapper.insertUser(user); // 新增用户岗位关联 insertUserPost(user); // 新增用户与角色管理 insertUserRole(user); // 模拟抛出SQLException异常 boolean flag = true; if (flag) &#123; throw new RuntimeException("发生异常了.."); &#125; return rows;&#125; Transactional注解的常用属性表： 属性 说明 propagation 事务的传播行为，默认值为 REQUIRED。 isolation 事务的隔离度，默认值采用 DEFAULT timeout 事务的超时时间，默认值为-1，不超时。如果设置了超时时间(单位秒)，那么如果超过该时间限制了但事务还没有完成，则自动回滚事务。 read-only 指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。 rollbackFor 用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。{xxx1.class, xxx2.class,……} noRollbackFor 抛出 no-rollback-for 指定的异常类型，不回滚事务。{xxx1.class, xxx2.class,……} …. 提示 事务的传播机制是指如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 即:在执行一个@Transactinal注解标注的方法时，开启了事务；当该方法还在执行中时，另一个人也触发了该方法；那么此时怎么算事务呢，这时就可以通过事务的传播机制来指定处理方式。 TransactionDefinition传播行为的常量： 常量 含义 TransactionDefinition.PROPAGATION_REQUIRED 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATION_REQUIRES_NEW 创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER 以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATION_NESTED 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。 #异常处理通常一个web框架中，有大量需要处理的异常。比如业务异常，权限不足等等。前端通过弹出提示信息的方式告诉用户出了什么错误。 通常情况下我们用try.....catch....对异常进行捕捉处理，但是在实际项目中对业务模块进行异常捕捉，会造成代码重复和繁杂， 我们希望代码中只有业务相关的操作，所有的异常我们单独设立一个类来处理它。全局异常就是对框架所有异常进行统一管理。 我们在可能发生异常的方法里throw抛给控制器。然后由全局异常处理器对异常进行统一处理。 如此，我们的Controller中的方法就可以很简洁了。 所谓全局异常处理器就是使用@ControllerAdvice注解。示例如下： 1、统一返回实体定义 123456789101112131415161718192021222324252627282930313233343536373839404142package com.ruoyi.common.core.domain;import java.util.HashMap;/** * 操作消息提醒 * * @author ruoyi */public class AjaxResult extends HashMap&lt;String, Object&gt;&#123; private static final long serialVersionUID = 1L; /** * 返回错误消息 * * @param code 错误码 * @param msg 内容 * @return 错误消息 */ public static AjaxResult error(String msg) &#123; AjaxResult json = new AjaxResult(); json.put("msg", msg); json.put("code", 500); return json; &#125; /** * 返回成功消息 * * @param msg 内容 * @return 成功消息 */ public static AjaxResult success(String msg) &#123; AjaxResult json = new AjaxResult(); json.put("msg", msg); json.put("code", 0); return json; &#125;&#125; 2、定义登录异常定义 123456789101112131415161718192021222324package com.ruoyi.common.exception;/** * 登录异常 * * @author ruoyi */public class LoginException extends RuntimeException&#123; private static final long serialVersionUID = 1L; protected final String message; public LoginException(String message) &#123; this.message = message; &#125; @Override public String getMessage() &#123; return message; &#125;&#125; 3、基于@ControllerAdvice注解的Controller层的全局异常统一处理 1234567891011121314151617181920212223242526272829package com.ruoyi.framework.web.exception;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;import com.ruoyi.common.core.domain.AjaxResult;import com.ruoyi.common.exception.LoginException;/** * 全局异常处理器 * * @author ruoyi */@RestControllerAdvicepublic class GlobalExceptionHandler&#123; private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 登录异常 */ @ExceptionHandler(LoginException.class) public AjaxResult loginException(LoginException e) &#123; log.error(e.getMessage(), e); return AjaxResult.error(e.getMessage()); &#125;&#125; 4、测试访问请求 123456789101112131415161718192021@Controllerpublic class SysIndexController &#123; /** * 首页方法 */ @GetMapping("/index") public String index(ModelMap mmap) &#123; /** * 模拟用户未登录，抛出业务逻辑异常 */ SysUser user = ShiroUtils.getSysUser(); if (StringUtils.isNull(user)) &#123; throw new LoginException("用户未登录，无法访问请求。"); &#125; mmap.put("user", user); return "index"; &#125;&#125; 根据上面代码含义，当我们未登录访问/index时就会发生LoginException业务逻辑异常，按照我们之前的全局异常配置以及统一返回实体实例化，访问后会出现AjaxResult格式JSON数据， 下面我们运行项目访问查看效果。界面输出内容如下所示： 1234&#123; "msg": "用户未登录，无法访问请求。", "code": 500&#125; 对于一些特殊情况，如接口需要返回json，页面请求返回html可以使用如下方法： 1234567891011121314@ExceptionHandler(LoginException.class)public Object loginException(HttpServletRequest request, LoginException e)&#123; log.error(e.getMessage(), e); if (ServletUtils.isAjaxRequest(request)) &#123; return AjaxResult.error(e.getMessage()); &#125; else &#123; return new ModelAndView("/error/500"); &#125;&#125; 若依系统的全局异常处理器GlobalExceptionHandler注意：如果全部异常处理返回json，那么可以使用@RestControllerAdvice代替@ControllerAdvice，这样在方法上就可以不需要添加@ResponseBody。 无法捕获异常？ 如果您的异常无法捕获，您可以从以下几个方面着手检查 异常是否已被处理，即抛出异常后被catch，打印了日志或抛出了其它异常 异常是否非Controller抛出，即在拦截器或过滤器中出现的异常 #参数验证spring boot中可以用@Validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。 #注解参数说明 注解名称 功能 @Xss 检查该字段是否存在跨站脚本工具 @Null 检查该字段为空 @NotNull 不能为null @NotBlank 不能为空，常用于检查空字符串 @NotEmpty 不能为空，多用于检测list是否size是0 @Max 该字段的值只能小于或等于该值 @Min 该字段的值只能大于或等于该值 @Past 检查该字段的日期是在过去 @Future 检查该字段的日期是否是属于将来的日期 @Email 检查是否是一个有效的email地址 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 @Size(min=, max=) 检查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等 @Length(min=,max=) 检查所属的字段的长度是否在min和max之间,只能用于字符串 @AssertTrue 用于boolean字段，该字段只能为true @AssertFalse 该字段的值只能为false 数据校验使用1、基础使用 因为spring boot已经引入了基础包，所以直接使用就可以了。首先在controller上声明@Validated需要对数据进行校验。 1234public AjaxResult add(@Validated @RequestBody SysUser user)&#123; .....&#125; 2、然后在对应字段Get方法加上参数校验注解，如果不符合验证要求，则会以message的信息为准，返回给前端。 12345678910111213141516171819202122232425@Size(min = 0, max = 30, message = "用户昵称长度不能超过30个字符")public String getNickName()&#123; return nickName;&#125;@NotBlank(message = "用户账号不能为空")@Size(min = 0, max = 30, message = "用户账号长度不能超过30个字符")public String getUserName()&#123; return userName;&#125;@Email(message = "邮箱格式不正确")@Size(min = 0, max = 50, message = "邮箱长度不能超过50个字符")public String getEmail()&#123; return email;&#125;@Size(min = 0, max = 11, message = "手机号码长度不能超过11个字符")public String getPhonenumber()&#123; return phonenumber;&#125; 也可以直接放在字段上面声明。 12@Size(min = 0, max = 30, message = "用户昵称长度不能超过30个字符")private String nickName; 自定义注解校验使用原生的@Validated进行参数校验时，都是特定的注解去校验（例如字段长度、大小、不为空等），我们也可以用自定义的注解去进行校验，例如项目中的@Xss注解。 1、新增Xss注解，设置自定义校验器XssValidator.class 123456789101112131415161718/** * 自定义xss校验注解 * * @author ruoyi */@Retention(RetentionPolicy.RUNTIME)@Target(value = &#123; ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER &#125;)@Constraint(validatedBy = &#123; XssValidator.class &#125;)public @interface Xss&#123; String message() default "不允许任何脚本运行"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 2、自定义Xss校验器，实现ConstraintValidator接口。 12345678910111213141516171819202122/** * 自定义xss校验注解实现 * * @author ruoyi */public class XssValidator implements ConstraintValidator&lt;Xss, String&gt;&#123; private final String HTML_PATTERN = "&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt;"; @Override public boolean isValid(String value, ConstraintValidatorContext constraintValidatorContext) &#123; return !containsHtml(value); &#125; public boolean containsHtml(String value) &#123; Pattern pattern = Pattern.compile(HTML_PATTERN); Matcher matcher = pattern.matcher(value); return matcher.matches(); &#125;&#125; 3、实体类使用自定义的@Xss注解 1234567@Xss(message = "登录账号不能包含脚本字符")@NotBlank(message = "登录账号不能为空")@Size(min = 0, max = 30, message = "登录账号长度不能超过30个字符")public String getLoginName()&#123; return loginName;&#125; 此时在去保存会进行验证，如果不符合规则的字符（例如&lt;script&gt;alert(1);&lt;/script&gt;）会提示登录账号不能包含脚本字符，代表限制成功。 如果是在方法里面校验整个实体，参考示例。 1234567@Autowiredprotected Validator validator;public void importUser(SysUser user)&#123; BeanValidators.validateWithException(validator, user);&#125; #自定义分组校验有时候我们为了在使用实体类的情况下更好的区分出新增、修改和其他操作验证的不同，可以通过groups属性设置。使用方式如下 新增类接口，用于标识出不同的操作类型 1234567public interface Add&#123;&#125;public interface Edit&#123;&#125; Controller.java 1234567891011// 新增public AjaxResult addSave(@Validated(Add.class) @RequestBody Xxxx xxxx)&#123; return success(xxxx);&#125;// 编辑public AjaxResult editSave(@Validated(Edit.class) @RequestBody Xxxx xxxx)&#123; return success(xxxx);&#125; Model.java 1234567// 仅在新增时验证@NotNull(message = "不能为空", groups = &#123;Add.class&#125;)private String xxxx;// 在新增和修改时验证@NotBlank(message = "不能为空", groups = &#123;Add.class, Edit.class&#125;)private String xxxx; 提示 如果你有更多操作类型，也可以自定义类统一管理，使用方式就变成了Type.Add、Type.Edit、Type.Xxxx等。 12345678910111213package com.eva.core.constants;/** * 操作类型 */public interface Type &#123; interface Add &#123;&#125; interface Edit &#123;&#125; interface Xxxx &#123;&#125;&#125; #系统日志在实际开发中，对于某些关键业务，我们通常需要记录该操作的内容，一个操作调一次记录方法，每次还得去收集参数等等，会造成大量代码重复。 我们希望代码中只有业务相关的操作，在项目中使用注解来完成此项功能。 在需要被记录日志的controller方法上添加@Log注解，使用方法如下： 12345@Log(title = "用户管理", businessType = BusinessType.INSERT)public AjaxResult addSave(...)&#123; return success(...);&#125; #注解参数说明 参数 类型 默认值 描述 title String 空 操作模块 businessType BusinessType OTHER 操作功能（OTHER其他、INSERT新增、UPDATE修改、DELETE删除、GRANT授权、EXPORT导出、IMPORT导入、FORCE强退、GENCODE生成代码、CLEAN清空数据） operatorType OperatorType MANAGE 操作人类别（OTHER其他、MANAGE后台用户、MOBILE手机端用户） isSaveRequestData boolean true 是否保存请求的参数 isSaveResponseData boolean true 是否保存响应的参数 excludeParamNames String[] {} 排除指定的请求参数 #自定义操作功能1、在BusinessType中新增业务操作类型如: 1234/** * 测试 */TEST, 2、在sys_dict_data字典数据表中初始化操作业务类型 1insert into sys_dict_data values(25, 10, '测试', '10', 'sys_oper_type', '', 'primary', 'N', '0', 'admin', '2018-03-16 11-33-00', 'ry', '2018-03-16 11-33-00', '测试操作'); 3、在Controller中使用注解 12345@Log(title = "测试标题", businessType = BusinessType.TEST)public AjaxResult test(...)&#123; return success(...);&#125; 操作日志记录逻辑实现代码LogAspect.java(opens new window)登录系统（系统管理-操作日志）可以查询操作日志列表和详细信息。 #数据权限在实际开发中，需要设置用户只能查看哪些部门的数据，这种情况一般称为数据权限。例如对于销售，财务的数据，它们是非常敏感的，因此要求对数据权限进行控制， 对于基于集团性的应用系统而言，就更多需要控制好各自公司的数据了。如设置只能看本公司、或者本部门的数据，对于特殊的领导，可能需要跨部门的数据， 因此程序不能硬编码那个领导该访问哪些数据，需要进行后台的权限和数据权限的控制。 提示 默认系统管理员admin拥有所有数据权限（userId=1），默认角色拥有所有数据权限（如不需要数据权限不用设置数据权限操作） #注解参数说明 参数 类型 默认值 描述 deptAlias String 空 部门表的别名 userAlias String 空 用户表的别名 #数据权限使用1、在（系统管理-角色管理）设置需要数据权限的角色 目前支持以下几种权限 全部数据权限 自定数据权限 部门数据权限 部门及以下数据权限 仅本人数据权限 2、在需要数据权限控制方法上添加@DataScope注解，其中d和u用来表示表的别名 部门数据权限注解 12345@DataScope(deptAlias = "d")public List&lt;...&gt; select(...)&#123; return mapper.select(...);&#125; 部门及用户权限注解 12345@DataScope(deptAlias = "d", userAlias = "u")public List&lt;...&gt; select(...)&#123; return mapper.select(...);&#125; 3、在mybatis查询底部标签添加数据范围过滤 12345&lt;select id="select" parameterType="..." resultMap="...Result"&gt; &lt;include refid="select...Vo"/&gt; &lt;!-- 数据范围过滤 --&gt; $&#123;params.dataScope&#125;&lt;/select&gt; 例如：用户管理（未过滤数据权限的情况）： 1234567select u.user_id, u.dept_id, u.login_name, u.user_name, u.email , u.phonenumber, u.password, u.sex, u.avatar, u.salt , u.status, u.del_flag, u.login_ip, u.login_date, u.create_by , u.create_time, u.remark, d.dept_namefrom sys_user u left join sys_dept d on u.dept_id = d.dept_idwhere u.del_flag = '0' 例如：用户管理（已过滤数据权限的情况）： 123456789101112select u.user_id, u.dept_id, u.login_name, u.user_name, u.email , u.phonenumber, u.password, u.sex, u.avatar, u.salt , u.status, u.del_flag, u.login_ip, u.login_date, u.create_by , u.create_time, u.remark, d.dept_namefrom sys_user u left join sys_dept d on u.dept_id = d.dept_idwhere u.del_flag = '0' and u.dept_id in ( select dept_id from sys_role_dept where role_id = 2 ) 结果很明显，我们多了如下语句。通过角色部门表（sys_role_dept）完成了数据权限过滤 12345and u.dept_id in ( select dept_id from sys_role_dept where role_id = 2) 逻辑实现代码 com.ruoyi.framework.aspectj.DataScopeAspect 提示 仅实体继承BaseEntity才会进行处理，SQL语句会存放到BaseEntity对象中的params属性中，然后在xml中通过${params.dataScope}获取拼接后的语句。 #多数据源在实际开发中，经常可能遇到在一个应用中可能需要访问多个数据库的情况，在项目中使用注解来完成此项功能。 在需要被切换数据源的Service或Mapper方法上添加@DataSource注解，使用方法如下： 12345@DataSource(value = DataSourceType.MASTER)public List&lt;...&gt; select(...)&#123; return mapper.select(...);&#125; 其中value用来表示数据源名称，除MASTER和SLAVE其他均需要进行配置。 #注解参数说明 参数 类型 默认值 描述 value DataSourceType DataSourceType.MASTER 主库 #多数据源使用1、在application-druid.yml配置从库数据源 1234567# 从库数据源slave: # 从数据源开关/默认关闭 enabled: true url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8 username: root password: password 2、在DataSourceType类添加数据源枚举 1234/** * 从库 */SLAVE 3、在DruidConfig配置读取数据源 12345678@Bean@ConfigurationProperties("spring.datasource.druid.slave")@ConditionalOnProperty(prefix = "spring.datasource.druid.slave", name = "enabled", havingValue = "true")public DataSource slaveDataSource(DruidProperties druidProperties)&#123; DruidDataSource dataSource = DruidDataSourceBuilder.create().build(); return druidProperties.dataSource(dataSource);&#125; 4、在DruidConfig类dataSource方法添加数据源 1setDataSource(targetDataSources, DataSourceType.SLAVE.name(), "slaveDataSource"); 5、在需要使用多数据源方法或类上添加@DataSource注解，其中value用来表示数据源 12345@DataSource(value = DataSourceType.SLAVE)public List&lt;SysUser&gt; selectUserList(SysUser user)&#123; return userMapper.selectUserList(user);&#125; 123@Service@DataSource(value = DataSourceType.SLAVE)public class SysUserServiceImpl #手动切换数据源在需要切换数据源的方法中使用DynamicDataSourceContextHolder类实现手动切换，使用方法如下： 1234567public List&lt;SysUser&gt; selectUserList(SysUser user)&#123; DynamicDataSourceContextHolder.setDataSourceType(DataSourceType.SLAVE.name()); List&lt;SysUser&gt; userList = userMapper.selectUserList(user); DynamicDataSourceContextHolder.clearDataSourceType(); return userList;&#125; 逻辑实现代码 com.ruoyi.framework.aspectj.DataSourceAspect 1注意：目前配置了一个从库，默认关闭状态。如果不需要多数据源不用做任何配置。 另外可新增多个从库。支持不同数据源（Mysql、Oracle、SQLServer） 提示 如果有Service方法内多个注解无效的情况使用内部方法调用SpringUtils.getAopProxy(this).xxxxxx(xxxx); #代码生成大部分项目里其实有很多代码都是重复的，几乎每个基础模块的代码都有增删改查的功能，而这些功能都是大同小异， 如果这些功能都要自己去写，将会大大浪费我们的精力降低效率。所以这种重复性的代码可以使用代码生成。 #默认配置单应用在resources目录下的application.yml，多模块ruoyi-generator中的resources目录下的generator.yml，可以自己根据实际情况调整默认配置。 12345678910# 代码生成gen: # 开发者姓名，生成到类注释上 author: ruoyi # 默认生成包路径 system 需改成自己的模块名称 如 system monitor tool packageName: com.ruoyi.system # 自动去除表前缀，默认是false autoRemovePre: false # 表前缀（生成类名不会包含表前缀，多个用逗号分隔） tablePrefix: sys_ #单表结构新建数据库表结构（单表） 1234567891011drop table if exists sys_student;create table sys_student ( student_id int(11) auto_increment comment '编号', student_name varchar(30) default '' comment '学生名称', student_age int(3) default null comment '年龄', student_hobby varchar(30) default '' comment '爱好（0代码 1音乐 2电影）', student_sex char(1) default '0' comment '性别（0男 1女 2未知）', student_status char(1) default '0' comment '状态（0正常 1停用）', student_birthday datetime comment '生日', primary key (student_id)) engine=innodb auto_increment=1 comment = '学生信息表'; #树表结构新建数据库表结构（树表） 123456789drop table if exists sys_product;create table sys_product ( product_id bigint(20) not null auto_increment comment '产品id', parent_id bigint(20) default 0 comment '父产品id', product_name varchar(30) default '' comment '产品名称', order_num int(4) default 0 comment '显示顺序', status char(1) default '0' comment '产品状态（0正常 1停用）', primary key (product_id)) engine=innodb auto_increment=1 comment = '产品表'; #主子表结构新建数据库表结构（主子表） 1234567891011121314151617181920212223242526272829-- ------------------------------ 客户表-- ----------------------------drop table if exists sys_customer;create table sys_customer ( customer_id bigint(20) not null auto_increment comment '客户id', customer_name varchar(30) default '' comment '客户姓名', phonenumber varchar(11) default '' comment '手机号码', sex varchar(20) default null comment '客户性别', birthday datetime comment '客户生日', remark varchar(500) default null comment '客户描述', primary key (customer_id)) engine=innodb auto_increment=1 comment = '客户表';-- ------------------------------ 商品表-- ----------------------------drop table if exists sys_goods;create table sys_goods ( goods_id bigint(20) not null auto_increment comment '商品id', customer_id bigint(20) not null comment '客户id', name varchar(30) default '' comment '商品名称', weight int(5) default null comment '商品重量', price decimal(6,2) default null comment '商品价格', date datetime comment '商品时间', type char(1) default null comment '商品种类', primary key (goods_id)) engine=innodb auto_increment=1 comment = '商品表'; #代码生成使用1、登录系统（系统工具 -&gt; 代码生成 -&gt; 导入对应表） 2、代码生成列表中找到需要表（可预览、编辑、同步、删除生成配置） 3、点击生成代码会得到一个ruoyi.zip执行sql文件，按照包内目录结构复制到自己的项目中即可 代码生成支持编辑、预览、同步 预览：对生成的代码提前预览，防止出现一些不符合预期的情况。 同步：对原表的字段进行同步，包括新增、删除、修改的字段处理。 修改：对生成的代码基本信息、字段信息、生成信息做一系列的调整。 另外多模块所有代码生成的相关业务逻辑代码在ruoyi-generator模块，不需要可以自行删除模块。 #定时任务在实际项目开发中Web应用有一类不可缺少的，那就是定时任务。 定时任务的场景可以说非常广泛，比如某些视频网站，购买会员后，每天会给会员送成长值，每月会给会员送一些电影券； 比如在保证最终一致性的场景中，往往利用定时任务调度进行一些比对工作；比如一些定时需要生成的报表、邮件；比如一些需要定时清理数据的任务等。 所以我们提供方便友好的web界面，实现动态管理任务，可以达到动态控制定时任务启动、暂停、重启、删除、添加、修改等操作，极大地方便了开发过程。 提示 关于定时任务使用流程 1、后台添加定时任务处理类（支持Bean调用、Class类调用）Bean调用示例：需要添加对应Bean注解@Component或@Service。调用目标字符串：ryTask.ryParams(&#39;ry&#39;)Class类调用示例：添加类和方法指定包即可。调用目标字符串：com.ruoyi.quartz.task.RyTask.ryParams(&#39;ry&#39;) 1234567891011121314151617181920212223/** * 定时任务调度测试 * * @author ruoyi */@Component("ryTask")public class RyTask&#123; public void ryMultipleParams(String s, Boolean b, Long l, Double d, Integer i) &#123; System.out.println(StringUtils.format("执行多参方法： 字符串类型&#123;&#125;，布尔类型&#123;&#125;，长整型&#123;&#125;，浮点型&#123;&#125;，整形&#123;&#125;", s, b, l, d, i)); &#125; public void ryParams(String params) &#123; System.out.println("执行有参方法：" + params); &#125; public void ryNoParams() &#123; System.out.println("执行无参方法"); &#125;&#125; 2、前端新建定时任务信息（系统监控 -&gt; 定时任务）任务名称：自定义，如：定时查询任务状态任务分组：根据字典sys_job_group配置调用目标字符串：设置后台任务方法名称参数执行表达式：可查询官方cron表达式介绍执行策略：定时任务自定义执行策略并发执行：是否需要多个任务间同时执行状态：是否启动定时任务备注：定时任务描述信息 3、点击执行一次，测试定时任务是否正常及调度日志是否正确记录，如正常执行表示任务配置成功。 执行策略详解：立即执行（所有misfire的任务会马上执行）打个比方，如果9点misfire了，在10：15系统恢复之后，9点，10点的misfire会马上执行执行一次（会合并部分的misfire，正常执行下一个周期的任务）假设9，10的任务都misfire了，系统在10：15分起来了。只会执行一次misfire，下次正点执行。放弃执行(所有的misfire不管，执行下一个周期的任务) 方法参数详解：字符串（需要单引号’’标识 如：ryTask.ryParams(’ry’)）布尔类型（需要true false标识 如：ryTask.ryParams(true)）长整型（需要L标识 如：ryTask.ryParams(2000L)）浮点型（需要D标识 如：ryTask.ryParams(316.50D)）整型（纯数字即可） cron表达式语法:[秒] [分] [小时] [日] [月] [周] [年] 说明 必填 允许填写的值 允许的通配符 秒 是 0-59 , - * / 分 是 0-59 , - * / 时 是 0-23 , - * / 日 是 1-31 , - * / 月 是 1-12 / JAN-DEC , - * ? / L W 周 是 1-7 or SUN-SAT , - * ? / L # 年 是 1970-2099 , - * / 通配符说明:* 表示所有值。 例如:在分的字段上设置 ,表示每一分钟都会触发? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 ?- 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发, 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发/ 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)# 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：’L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同 常用表达式例子: 表达式 说明 0 0 2 1 ? 表示在每月的1日的凌晨2点调整任务 0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 0 0 10,14,16 ? 每天上午10点，下午2点，4点 0 0/30 9-17 ? 朝九晚五工作时间内每半小时 0 0 12 ? * WED 表示每个星期三中午12点 0 0 12 ? 每天中午12点触发 0 15 10 ? 每天上午10:15触发 0 15 10 ? 每天上午10:15触发 0 15 10 ? * 每天上午10:15触发 0 15 10 ? 2005 2005年的每天上午10:15触发 0 14 * ? 在每天下午2点到下午2:59期间的每1分钟触发 0 0/5 14 ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0-5 14 ? 在每天下午2点到下午2:05期间的每1分钟触发 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 15 10 15 * ? 每月15日上午10:15触发 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 多模块所有定时任务的相关业务逻辑代码在ruoyi-quartz模块，可以自行调整或剔除 1注意：不同数据源定时任务都有对应脚本，Oracle、Mysql已经有了，其他的可自行下载执行 #系统接口在现在的开发过程中还有很大一部分公司都是以口口相传的方式来进行前后端的联调，而接口文档很大一部分都只停留在了说说而已的地步，或者写了代码再写文档。 还有一点就是文档的修改，定义好的接口并不是一成不变的，可能在开发过程中文档修改不止一次的变化，这个时候就会很难受了。 只要不是强制性要求，没人会愿意写这东西，而且在写的过程中，一个字母的错误就会导致联调时候的很大麻烦，但是通过Swagger，我们可以省略了这一步，而且文档出错率近乎于零， 只要你在写代码的时候，稍加几个注解，文档自动生成。 1、在控制层Controller中添加注解来描述接口信息如: 1234@Api("参数配置")@Controller@RequestMapping("/system/config")public class ConfigController 2、在方法中配置接口的标题信息 12345678@ApiOperation("查询参数列表")@ResponseBodypublic TableDataInfo list(Config config)&#123; startPage(); List&lt;Config&gt; list = configService.selectConfigList(config); return getDataTable(list);&#125; 3、在系统工具-系统接口测试相关接口 1注意：SwaggerConfig可以指定根据注解或者包名扫描具体的API API详细说明 作用范围 API 使用位置 协议集描述 @Api 用于controller类上 对象属性 @ApiModelProperty 用在出入参数对象的字段上 协议描述 @ApiOperation 用在controller的方法上 Response集 @ApiResponses 用在controller的方法上 Response @ApiResponse 用在 @ApiResponses里边 非对象参数集 @ApiImplicitParams 用在controller的方法上 非对象参数描述 @ApiImplicitParam 用在@ApiImplicitParams的方法里边 描述返回对象的意义 @ApiModel 用在返回对象类上 api标记，用在类上，说明该类的作用。可以标记一个Controller类做为Swagger文档资源，使用方式： 1@Api(value = "/user", description = "用户管理") 与Controller注解并列使用。 属性配置： 属性名称 备注 value url的路径值 tags 如果设置这个值、value的值会被覆盖 description 对api资源的描述 basePath 基本路径可以不配置 position 如果配置多个Api 想改变显示的顺序位置 produces For example, “application/json, application/xml” consumes For example, “application/json, application/xml” protocols Possible values: http, https, ws, wss. authorizations 高级特性认证时配置 hidden 配置为true 将在文档中隐藏 ApiOperation标记，用在方法上，说明方法的作用，每一个url资源的定义,使用方式： 1@ApiOperation("获取用户信息") 与Controller中的方法并列使用，属性配置： 属性名称 备注 value url的路径值 tags 如果设置这个值、value的值会被覆盖 description 对api资源的描述 basePath 基本路径可以不配置 position 如果配置多个Api 想改变显示的顺序位置 produces For example, “application/json, application/xml” consumes For example, “application/json, application/xml” protocols Possible values: http, https, ws, wss. authorizations 高级特性认证时配置 hidden 配置为true将在文档中隐藏 response 返回的对象 responseContainer 这些对象是有效的 “List”, “Set” or “Map”.，其他无效 httpMethod “GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH” code http的状态码 默认 200 extensions 扩展属性 ApiParam标记，请求属性，使用方式： 1public TableDataInfo list(@ApiParam(value = "查询用户列表", required = true)User user) 与Controller中的方法并列使用，属性配置： 属性名称 备注 name 属性名称 value 属性值 defaultValue 默认属性值 allowableValues 可以不配置 required 是否属性必填 access 不过多描述 allowMultiple 默认为false hidden 隐藏该属性 example 举例子 ApiResponse标记，响应配置，使用方式： 1@ApiResponse(code = 400, message = "查询用户失败") 与Controller中的方法并列使用，属性配置： 属性名称 备注 code http的状态码 message 描述 response 默认响应类 Void reference 参考ApiOperation中配置 responseHeaders 参考 ResponseHeader 属性配置说明 responseContainer 参考ApiOperation中配置 ApiResponses标记，响应集配置，使用方式: 1@ApiResponses(&#123; @ApiResponse(code = 400, message = "无效的用户") &#125;) 与Controller中的方法并列使用，属性配置： 属性名称 备注 value 多个ApiResponse配置 ResponseHeader标记，响应头设置，使用方法 1@ResponseHeader(name="head",description="响应头设计") 与Controller中的方法并列使用，属性配置： 属性名称 备注 name 响应头名称 description 描述 response 默认响应类 void responseContainer 参考ApiOperation中配置 #防重复提交在接口方法上添加@RepeatSubmit注解即可，注解参数说明： 参数 类型 默认值 描述 interval int 5000 间隔时间(ms)，小于此时间视为重复提交 message String 不允许重复提交，请稍后再试 提示消息 示例1：采用默认参数 12345@RepeatSubmitpublic AjaxResult addSave(...)&#123; return success(...);&#125; 示例2：指定防重复时间和错误消息 12345@RepeatSubmit(interval = 1000, message = "请求过于频繁")public AjaxResult addSave(...)&#123; return success(...);&#125; #国际化支持在我们开发WEB项目的时候，项目可能涉及到在国外部署或者应用，也有可能会有国外的用户对项目进行访问，那么在这种项目中， 为客户展现的页面或者操作的信息就需要使用不同的语言，这就是我们所说的项目国际化。 目前项目已经支持多语言国际化，接下来我们介绍如何使用。 #后台国际化流程1、修改I18nConfig设置默认语言，如默认中文： 12// 默认语言，英文可以设置Locale.USslr.setDefaultLocale(Locale.SIMPLIFIED_CHINESE); 2、修改配置application.yml中的basename国际化文件，默认是i18n路径下messages文件（比如现在国际化文件是xx_zh_CN.properties、xx_en_US.properties，那么basename配置应为是i18n/xx 12345spring: # 资源信息 messages: # 国际化资源文件路径 basename: static/i18n/messages 3、i18n目录文件下定义资源文件美式英语 messages_en_US.properties 12345user.login.username=User nameuser.login.password=Passworduser.login.code=Security codeuser.login.remember=Remember meuser.login.submit=Sign In 中文简体 messages_zh_CN.properties 12345user.login.username=用户名user.login.password=密码user.login.code=验证码user.login.remember=记住我user.login.submit=登录 4、java代码使用MessageUtils获取国际化 12345MessageUtils.message("user.login.username")MessageUtils.message("user.login.password")MessageUtils.message("user.login.code")MessageUtils.message("user.login.remember")MessageUtils.message("user.login.submit") #前端国际化流程1、html使用国际化#{资源文件key} 1234567891011121314151617181920&lt;form id="signupForm"&gt; &lt;h4 class="no-margins"&gt;登录：&lt;/h4&gt; &lt;p class="m-t-md"&gt;你若不离不弃，我必生死相依&lt;/p&gt; &lt;input type="text" name="username" class="form-control uname" th:placeholder="#&#123;user.login.username&#125;" /&gt; &lt;input type="password" name="password" class="form-control pword" th:placeholder="#&#123;user.login.password&#125;" /&gt; &lt;div class="row m-t" th:if="$&#123;captchaEnabled==true&#125;"&gt; &lt;div class="col-xs-6"&gt; &lt;input type="text" name="validateCode" class="form-control code" th:placeholder="#&#123;user.login.code&#125;" maxlength="5" autocomplete="off"&gt; &lt;/div&gt; &lt;div class="col-xs-6"&gt; &lt;a href="javascript:void(0);" title="点击更换验证码"&gt; &lt;img th:src="@&#123;captcha/captchaImage(type=$&#123;captchaType&#125;)&#125;" class="imgcode" width="85%"/&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="checkbox-custom" th:classappend="$&#123;captchaEnabled==false&#125; ? 'm-t'"&gt; &lt;input type="checkbox" id="rememberme" name="rememberme"&gt; &lt;label for="rememberme" th:text="#&#123;user.login.remember&#125;"&gt;记住我&lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-success btn-block" id="btnSubmit" data-loading="正在验证登录，请稍后..." th:text="#&#123;user.login.submit&#125;"&gt;登录&lt;/button&gt;&lt;/form&gt; 2、js使用国际化 首先在文件引入jquery-i18n-properties依赖，然后在初始化后即可通过JS函数获取对应国际化文件的内容。 12345678910111213141516171819202122232425262728293031323334&lt;!--jQuery国际化插件--&gt;&lt;script src="../static/js/jquery.i18n.properties.min.js" th:src="@&#123;/js/jquery.i18n.properties.min.js&#125;"&gt;&lt;/script&gt;&lt;script th:inline="javascript"&gt; //获取应用路径 var ROOT = [[$&#123;#servletContext.contextPath&#125;]]; //获取默认语言 var LANG_COUNTRY = [[$&#123;#locale.language+'_'+#locale.country&#125;]]; //初始化i18n插件 $.i18n.properties(&#123; path: ROOT + '/i18n/',//这里表示访问路径 name: 'messages',//文件名开头 language: LANG_COUNTRY,//文件名语言 例如en_US mode: 'map'//默认值 &#125;); //初始化i18n函数 function i18n(msgKey) &#123; try &#123; return $.i18n.prop(msgKey); &#125; catch (e) &#123; return msgKey; &#125; &#125; //获取国际化翻译值 console.log(i18n('user.login.username')); console.log(i18n('user.login.password')); console.log(i18n('user.login.code')); console.log(i18n('user.login.remember')); console.log(i18n('user.login.submit'));&lt;/script&gt; 3、界面定义切换语言 12&lt;a href="?lang=en_US"&gt; 英语 &lt;/a&gt; &lt;a href="?lang=zh_CN"&gt; 中文 &lt;/a&gt; #新建子模块Maven多模块下新建子模块流程案例。 1、新建业务模块目录，例如：ruoyi-test。 2、在ruoyi-test业务模块下新建pom.xml文件以及src\main\java，src\main\resources目录。 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ruoyi&lt;/artifactId&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;version&gt;x.x.x&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;ruoyi-test&lt;/artifactId&gt; &lt;description&gt; test系统模块 &lt;/description&gt; &lt;dependencies&gt; &lt;!-- 通用工具--&gt; &lt;dependency&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;artifactId&gt;ruoyi-common&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3、根目录pom.xml依赖声明节点dependencies中添加依赖 123456&lt;!-- 测试模块--&gt;&lt;dependency&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;artifactId&gt;ruoyi-test&lt;/artifactId&gt; &lt;version&gt;$&#123;ruoyi.version&#125;&lt;/version&gt;&lt;/dependency&gt; 4、根目录pom.xml模块节点modules添加业务模块 1&lt;module&gt;ruoyi-test&lt;/module&gt; 5、ruoyi-admin目录pom.xml添加模块依赖 12345&lt;!-- 测试模块--&gt;&lt;dependency&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;artifactId&gt;ruoyi-test&lt;/artifactId&gt;&lt;/dependency&gt; 6、测试模块 在ruoyi-test业务模块添加com.ruoyi.test包，新建TestService.java 1234567public class TestService&#123; public String helloTest() &#123; return "hello"; &#125;&#125; 在ruoyi-admin新建测试类，调用helloTest成功返回hello代表成功。]]></content>
      <tags>
        <tag>ruoyi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot经典学习笔记]]></title>
    <url>%2F2020%2F02%2F28%2FSpringboot%E7%BB%8F%E5%85%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[导读：课程概览1. Spring Boot是什么我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低。 2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求在 Spring 框架中支持无容器 Web 应用程序体系结构。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录： 我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 main()方法引导的 Spring 容器内嵌入和统一这些常用Web 容器服务的配置。 这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.0.3 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。 它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。 2. 为什么学习Spring Boot2.1 从Spring官方来看我们打开 Spring 的官方网站，可以看到下图： 我们可以看到图中官方对 Spring Boot 的定位：Build Anything， Build任何东西。Spring Boot旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。 同时我们也来看一下官方对后面两个的定位： SpringCloud：Coordinate Anything，协调任何事情；SpringCloud Data Flow：Connect everything，连接任何东西。 仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow三者定位的措辞非常有味道，同时也可以看出，Spring 官方对这三个技术非常重视，是现在以及今后学习的重点（SpringCloud 相关达人课课程届时也会上线）。 2.2 从Spring Boot的优点来看Spring Boot 有哪些优点？主要给我们解决了哪些问题呢？我们以下图来说明： 2.2.1 良好的基因Spring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。 2.2.2 简化编码举个例子，比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下： 12345678910111213&lt;!-- .....省略其他依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.7.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.7.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。 2.2.3 简化配置Spring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子： 我新建一个类，但是我不用 @Service注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要@Configuration 和@Bean两个注解即可，如下： 12345public class TestService &#123; public String sayHello () &#123; return "Hello Spring Boot!"; &#125;&#125; 12345678910import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class JavaConfig &#123; @Bean public TestService getTestService() &#123; return new TestService(); &#125;&#125; @Configuration表示该类是个配置类，@Bean表示该方法返回一个 Bean。这样就把TestService作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用@Resource注解注入进来即可使用，非常方便。 12@Resourceprivate TestService testService; 另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。 2.2.4 简化部署在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 java -jar xxx.jar一键式启动项目。 另外，也降低对运行环境的基本要求，环境变量中有JDK即可。 2.2.5 简化监控我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。 2.3 从未来发展的趋势来看微服务是未来发展的趋势，项目会从传统架构慢慢转向微服务架构，因为微服务可以使不同的团队专注于更小范围的工作职责、使用独立的技术、更安全更频繁地部署。而 继承了 Spring 的优良特性，与 Spring 一脉相承，而且 支持各种REST API 的实现方式。Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。 3. 本课程能学到什么本课程使用目前 Spring Boot 最新版本2.0.3 RELEASE，课程文章均为作者在实际项目中剥离出来的场景和demo，目标是带领学习者快速上手 Spring Boot，将 Spring Boot 相关技术点快速运用在微服务项目中。全篇分为两部分：基础篇和进阶篇。 基础篇（01—10课）主要介绍 Spring Boot 在项目中最常使用的一些功能点，旨在带领学习者快速掌握 Spring Boot 在开发时需要的知识点，能够把 Spring Boot 相关技术运用到实际项目架构中去。该部分以 Spring Boot 框架为主线，内容包括Json数据封装、日志记录、属性配置、MVC支持、在线文档、模板引擎、异常处理、AOP 处理、持久层集成等等。 进阶篇（11—17课）主要是介绍 Spring Boot 在项目中拔高一些的技术点，包括集成的一些组件，旨在带领学习者在项目中遇到具体的场景时能够快速集成，完成对应的功能。该部分以 Spring Boot 框架为主线，内容包括拦截器、监听器、缓存、安全认证、分词插件、消息队列等等。 认真读完该系列文章之后，学习者会快速了解并掌握 Spring Boot 在项目中最常用的技术点，作者课程的最后，会基于课程内容搭建一个 Spring Boot 项目的空架构，该架构也是从实际项目中剥离出来，学习者可以运用该架构于实际项目中，具备使用 Spring Boot 进行实际项目开发的能力。 课程所有源码提供免费下载：下载地址。 4. 适合阅读的人群本课程适合以下人群阅读： 有一定的Java语言基础，了解Spring、Maven的在校学生或自学者 有传统项目经验，想往微服务方向发展的工作人员 热衷于新技术并对 Spring Boot 感兴趣的人员 希望了解 Spring Boot 2.0.3 的研究人员 5. 本课程开发环境和插件本课程的开发环境： 开发工具：IDEA 2017 JDK版本： JDK 1.8 Spring Boot版本：2.0.3 RELEASE Maven版本：3.5.2 涉及到的插件： FastJson Swagger2 Thymeleaf MyBatis Redis ActiveMQ Shiro Lucence 6. 课程目录 导读：课程概览 第01课：Spring Boot开发环境搭建和项目启动 第02课：Spring Boot返回Json数据及数据封装 第03课：Spring Boot使用slf4j进行日志记录 第04课：Spring Boot中的项目属性配置 第05课：Spring Boot中的MVC支持 第06课：Spring Boot集成Swagger2展现在线接口文档 第07课：Spring Boot集成Thymeleaf模板引擎 第08课：Spring Boot中的全局异常处理 第09课：Spring Boot中的切面AOP处理 第10课：Spring Boot中集成MyBatis 第11课：Spring Boot事务配置管理 第12课：Spring Boot中使用监听器 第13课：Spring Boot中使用拦截器 第14课：Spring Boot中集成Redis 第15课：Spring Boot中集成ActiveMQ 第16课：Spring Boot中集成Shiro 第17课：Spring Boot中结成Lucence 第18课：Spring Boot搭建实际项目开发中的架构 第01课：Spring Boot开发环境搭建和项目启动上一节对 SpringBoot 的特性做了一个介绍，本节主要对 jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析。 1. jdk 的配置本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开File-&gt;Project Structure，如下图所： 选择 SDKs 在 JDK home path 中选择本地 jdk 的安装目录 在 Name 中为 jdk 自定义名字 通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的朋友，可以通过两步骤添加： window-&gt;preference-&gt;java-&gt;Instralled JRES来添加本地 jdk。 window--&gt;preference--&gt;java--&gt;Compiler选择 jre，和 jdk 保持一致。 2. Spring Boot 工程的构建2.1 IDEA 快速构建IDEA 中可以通过File-&gt;New-&gt;Project来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。 Group：填企业域名，本课程使用com.itcodai Artifact：填项目名称，本课程中每一课的工程名以course+课号命令，这里使用 course01 Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。 2.2 官方构建第二种方式可以通过官方构建，步骤如下： 访问 http://start.spring.io/。 在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。 解压后，使用 IDEA 导入该 maven 工程：File-&gt;New-&gt;Model from Existing Source，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的朋友，可以通过Import-&gt;Existing Maven Projects-&gt;Next，然后选择解压后的项目文件夹即可。 2.3 maven配置创建了 Spring Boot 项目之后，需要进行 maven 配置。打开File-&gt;settings，搜索 maven，配置一下本地的 maven 信息。如下： 在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 如果是使用 eclipse 的朋友，可以通过window--&gt;preference--&gt;Maven--&gt;User Settings来配置，配置方式和上面一致。 2.4 编码配置同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。 IDEA 中，仍然是打开File-&gt;settings，搜索 encoding，配置一下本地的编码信息。如下： 如果是使用 eclipse 的朋友，有两个地方需要设置一下编码： window–&gt; perferences–&gt;General–&gt;Workspace，将Text file encoding改成utf-8 window–&gt;perferences–&gt;General–&gt;content types，选中Text，将Default encoding填入utf-8 OK，编码设置完成即可启动项目工程了。 3. Spring Boot 项目工程结构Spring Boot 项目总共有三个模块，如下图所示： src/main/java路径：主要编写业务程序 src/main/resources路径：存放静态文件和配置文件 src/test/java路径：主要编写测试程序 默认情况下，如上图所示会创建一个启动类 Course01Application，该类上面有个@SpringBootApplication注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。 到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下： 1234567891011121314package com.itcodai.course01.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/start")public class StartController &#123; @RequestMapping("/springboot") public String startSpringBoot() &#123; return "Welcome to the world of Spring Boot!"; &#125;&#125; 重新运行 main 方法启动项目，在浏览器中输入 localhost:8080/start/springboot，如果看到 “Welcome to the world of Spring Boot!”，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 server.port 来人为指定端口，如8001端口： 12server: port: 8001 4. 总结本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。课程源代码下载地址：戳我下载 第02课：Spring Boot返回Json数据及数据封装在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用@RestController注解即可返回 Json 格式的数据，@RestController也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。 12345678@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController &#123; String value() default "";&#125; 可以看出， @RestController 注解包含了原来的 @Controller 和 @ResponseBody 注解，使用过 Spring 的朋友对 @Controller 注解已经非常了解了，这里不再赘述， @ResponseBody 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 @RestController 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 spring-boot-starter-web 依赖，可以看到一个 spring-boot-starter-json 依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; Spring Boot 中对依赖都做了很好的封装，可以看到很多 spring-boot-starter-xxx 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 spring-boot-starter-json 依赖，可以看到： 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。 1. Spring Boot 默认对Json的处理在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。 1.1 创建 User 实体类为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。 123456public class User &#123; private Long id; private String username; private String password; /* 省略get、set和带参构造方法 */&#125; 1.2 创建Controller类然后我们创建一个 Controller，分别返回 User对象、List&lt;User&gt; 和 Map&lt;String, Object&gt;。 1234567891011121314151617181920212223242526272829303132333435363738import com.itcodai.course02.entity.User;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@RestController@RequestMapping("/json")public class JsonController &#123; @RequestMapping("/user") public User getUser() &#123; return new User(1, "倪升武", "123456"); &#125; @RequestMapping("/list") public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); User user1 = new User(1, "倪升武", "123456"); User user2 = new User(2, "达人课", "123456"); userList.add(user1); userList.add(user2); return userList; &#125; @RequestMapping("/map") public Map&lt;String, Object&gt; getMap() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3); User user = new User(1, "倪升武", "123456"); map.put("作者信息", user); map.put("博客地址", "http://blog.itcodai.com"); map.put("CSDN地址", "http://blog.csdn.net/eson_15"); map.put("粉丝数量", 4153); return map; &#125;&#125; 1.3 测试不同数据类型返回的jsonOK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。 在浏览器中输入：localhost:8080/json/user 返回 json 如下： 1&#123;"id":1,"username":"倪升武","password":"123456"&#125; 在浏览器中输入：localhost:8080/json/list 返回 json 如下： 1[&#123;"id":1,"username":"倪升武","password":"123456"&#125;,&#123;"id":2,"username":"达人课","password":"123456"&#125;] 在浏览器中输入：localhost:8080/json/map 返回 json 如下： 1&#123;"作者信息":&#123;"id":1,"username":"倪升武","password":"123456"&#125;,"CSDN地址":"http://blog.csdn.net/eson_15","粉丝数量":4153,"博客地址":"http://blog.itcodai.com"&#125; 可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。 1.4 jackson 中对null的处理在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 “” 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类： 12345678910111213141516171819202122232425262728import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.databind.JsonSerializer;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializerProvider;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;import java.io.IOException;@Configurationpublic class JacksonConfig &#123; @Bean @Primary @ConditionalOnMissingBean(ObjectMapper.class) public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) &#123; ObjectMapper objectMapper = builder.createXmlMapper(false).build(); objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() &#123; @Override public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123; jsonGenerator.writeString(""); &#125; &#125;); return objectMapper; &#125;&#125; 然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下： 12345678910@RequestMapping("/map")public Map&lt;String, Object&gt; getMap() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3); User user = new User(1, "倪升武", null); map.put("作者信息", user); map.put("博客地址", "http://blog.itcodai.com"); map.put("CSDN地址", null); map.put("粉丝数量", 4153); return map;&#125; 重启项目，再次输入：localhost:8080/json/map，可以看到 jackson 已经将所有 null 字段转成了空字符串了。 1&#123;"作者信息":&#123;"id":1,"username":"倪升武","password":""&#125;,"CSDN地址":"","粉丝数量":4153,"博客地址":"http://blog.itcodai.com"&#125; 2. 使用阿里巴巴FastJson的设置2.1 jackson 和 fastJson 的对比有很多朋友习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。 选项 fastJson jackson 上手难易程度 容易 中等 高级特性支持 中等 丰富 官方文档、Example支持 中文 英文 处理json速度 略快 快 关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。 2.2 fastJson依赖导入使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt;&lt;/dependency&gt; 2.2 使用 fastJson 处理 null使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承 WebMvcConfigurationSupport 类，然后覆盖 configureMessageConverters 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import com.alibaba.fastjson.serializer.SerializerFeature;import com.alibaba.fastjson.support.config.FastJsonConfig;import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.List;@Configurationpublic class fastJsonConfig extends WebMvcConfigurationSupport &#123; /** * 使用阿里 FastJson 作为JSON MessageConverter * @param converters */ @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig config = new FastJsonConfig(); config.setSerializerFeatures( // 保留map空的字段 SerializerFeature.WriteMapNullValue, // 将String类型的null转成"" SerializerFeature.WriteNullStringAsEmpty, // 将Number类型的null转成0 SerializerFeature.WriteNullNumberAsZero, // 将List类型的null转成[] SerializerFeature.WriteNullListAsEmpty, // 将Boolean类型的null转成false SerializerFeature.WriteNullBooleanAsFalse, // 避免循环引用 SerializerFeature.DisableCircularReferenceDetect); converter.setFastJsonConfig(config); converter.setDefaultCharset(Charset.forName("UTF-8")); List&lt;MediaType&gt; mediaTypeList = new ArrayList&lt;&gt;(); // 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = "application/json" mediaTypeList.add(MediaType.APPLICATION_JSON); converter.setSupportedMediaTypes(mediaTypeList); converters.add(converter); &#125;&#125; 3. 封装统一返回的数据结构以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。 3.1 定义统一的 json 结构由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class JsonResult&lt;T&gt; &#123; private T data; private String code; private String msg; /** * 若没有数据返回，默认状态码为0，提示信息为：操作成功！ */ public JsonResult() &#123; this.code = "0"; this.msg = "操作成功！"; &#125; /** * 若没有数据返回，可以人为指定状态码和提示信息 * @param code * @param msg */ public JsonResult(String code, String msg) &#123; this.code = code; this.msg = msg; &#125; /** * 有数据返回时，状态码为0，默认提示信息为：操作成功！ * @param data */ public JsonResult(T data) &#123; this.data = data; this.code = "0"; this.msg = "操作成功！"; &#125; /** * 有数据返回，状态码为0，人为指定提示信息 * @param data * @param msg */ public JsonResult(T data, String msg) &#123; this.data = data; this.code = "0"; this.msg = msg; &#125; // 省略get和set方法&#125; 3.2 修改 Controller 中的返回值类型及测试由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下： 12345678910111213141516171819202122232425262728293031@RestController@RequestMapping("/jsonresult")public class JsonResultController &#123; @RequestMapping("/user") public JsonResult&lt;User&gt; getUser() &#123; User user = new User(1, "倪升武", "123456"); return new JsonResult&lt;&gt;(user); &#125; @RequestMapping("/list") public JsonResult&lt;List&gt; getUserList() &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); User user1 = new User(1, "倪升武", "123456"); User user2 = new User(2, "达人课", "123456"); userList.add(user1); userList.add(user2); return new JsonResult&lt;&gt;(userList, "获取用户列表成功"); &#125; @RequestMapping("/map") public JsonResult&lt;Map&gt; getMap() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3); User user = new User(1, "倪升武", null); map.put("作者信息", user); map.put("博客地址", "http://blog.itcodai.com"); map.put("CSDN地址", null); map.put("粉丝数量", 4153); return new JsonResult&lt;&gt;(map); &#125;&#125; 我们重新在浏览器中输入：localhost:8080/jsonresult/user 返回 json 如下： 1&#123;"code":"0","data":&#123;"id":1,"password":"123456","username":"倪升武"&#125;,"msg":"操作成功！"&#125; 输入：localhost:8080/jsonresult/list，返回 json 如下： 1&#123;"code":"0","data":[&#123;"id":1,"password":"123456","username":"倪升武"&#125;,&#123;"id":2,"password":"123456","username":"达人课"&#125;],"msg":"获取用户列表成功"&#125; 输入：localhost:8080/jsonresult/map，返回 json 如下： 1&#123;"code":"0","data":&#123;"作者信息":&#123;"id":1,"password":"","username":"倪升武"&#125;,"CSDN地址":null,"粉丝数量":4153,"博客地址":"http://blog.itcodai.com"&#125;,"msg":"操作成功！"&#125; 通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。 4. 总结本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。课程源代码下载地址：戳我下载 第03课：Spring Boot使用slf4j进行日志记录在开发中，我们经常使用 System.out.println() 来打印一些信息，但是这样不好，因为大量的使用 System.out 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。 1. slf4j 介绍引用百度百科里的一段话： SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。 这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。 正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j： 1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 “强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用 LoggerFactory 创建即可。 1234567import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Test &#123; private static final Logger logger = LoggerFactory.getLogger(Test.class); // ……&#125; 2. application.yml 中对日志的配置Spring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。application.yml 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 application.properties 文件，个人比较细化用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。 我们看一下 application.yml 文件中对日志的配置： 1234logging: config: logback.xml level: com.itcodai.course03.dao: trace logging.config 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 logback.xml 文件，关于日志的相关配置信息，都放在 logback.xml 文件中了。logging.level 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 com.itcodai.course03.dao 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。 常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。 3. logback.xml 配置文件解析在上面 application.yml 文件中，我们指定了日志配置文件 logback.xml，logback.xml 文件中主要用来做日志的相关配置。在 logback.xml 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下： 3.1 定义日志输出格式和存储路径1234&lt;configuration&gt; &lt;property name="LOG_PATTERN" value="%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n" /&gt; &lt;property name="FILE_PATH" value="D:/logs/course03/demo.%d&#123;yyyy-MM-dd&#125;.%i.log" /&gt;&lt;/configuration&gt; 我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 %date 表示日期，%thread 表示线程名，%-5level 表示级别从左显示5个字符宽度，%logger{36} 表示 logger 名字最长36个字符，%msg 表示日志消息，%n 是换行符。 然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。%i 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。 3.2 定义控制台输出12345678&lt;configuration&gt; &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt; &lt;pattern&gt;$&#123;LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt;&lt;/configuration&gt; 使用 &lt;appender&gt; 节点设置个控制台输出（class=&quot;ch.qos.logback.core.ConsoleAppender&quot;）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 ${} 引用进来即可。 3.3 定义日志文件的相关参数12345678910111213141516171819&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 按照上面配置的FILE_PATH路径来保存日志 --&gt; &lt;fileNamePattern&gt;$&#123;FILE_PATH&#125;&lt;/fileNamePattern&gt; &lt;!-- 日志保存15天 --&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;!-- 单个日志文件的最大，超过则新建日志文件存储 --&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt; &lt;pattern&gt;$&#123;LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt;&lt;/configuration&gt; 使用 &lt;appender&gt; 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。 3.4 定义日志输出级别1234567&lt;configuration&gt; &lt;logger name="com.itcodai.course03" level="INFO" /&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="CONSOLE" /&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; 有了上面那些定义后，最后我们使用 &lt;logger&gt; 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 &lt;root&gt; 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。 4. 使用Logger在项目中打印日志在代码中，我们一般使用 Logger 对象来打印出一些 log 信息，可以指定打印出的日志级别，也支持占位符，很方便。 1234567891011121314151617181920212223242526import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/test")public class TestController &#123; private final static Logger logger = LoggerFactory.getLogger(TestController.class); @RequestMapping("/log") public String testLog() &#123; logger.debug("=====测试日志debug级别打印===="); logger.info("======测试日志info级别打印====="); logger.error("=====测试日志error级别打印===="); logger.warn("======测试日志warn级别打印====="); // 可以使用占位符打印出一些参数信息 String str1 = "blog.itcodai.com"; String str2 = "blog.csdn.net/eson_15"; logger.info("======倪升武的个人博客：&#123;&#125;；倪升武的CSDN博客：&#123;&#125;", str1, str2); return "success"; &#125;&#125; 启动该项目，在浏览器中输入 localhost:8080/test/log 后可以看到控制台的日志记录： ======测试日志info级别打印==========测试日志error级别打印==========测试日志warn级别打印===========倪升武的个人博客：blog.itcodai.com；倪升武的CSDN博客：blog.csdn.net/eson_15 因为 INFO 级别比 DEBUG 级别高，所以 debug 这条没有打印出来，如果将 logback.xml 中的日志级别设置成 DEBUG，那么四条语句都会打印出来，这个大家自己去测试了。同时可以打开 D:\logs\course03\ 目录，里面有刚刚项目启动，以后后面生成的所有日志记录。在项目部署后，我们大部分都是通过查看日志文件来定位问题。 5. 总结本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 logback.xml 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。课程源代码下载地址：戳我下载 第04课：Spring Boot中的项目属性配置我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 application.yml 文件中。 1. 少量配置信息的情形举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置： 1234567server: port: 8001# 配置微服务的地址url: # 订单微服务的地址 orderUrl: http://localhost:8002 然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 @Value 注解来解决。在对应的类中加上一个属性，在属性上使用 @Value 注解即可获取到配置文件中的配置信息，如下： 123456789101112131415161718192021import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/test")public class ConfigController &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ConfigController.class); @Value("$&#123;url.orderUrl&#125;") private String orderUrl; @RequestMapping("/config") public String testConfig() &#123; LOGGER.info("=====获取的订单服务地址为：&#123;&#125;", orderUrl); return "success"; &#125;&#125; @Value 注解上通过 ${key} 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 localhost:8080/test/config 请求服务后，可以看到控制台会打印出订单服务的地址： 1=====获取的订单服务地址为：http://localhost:8002 说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。 2. 多个配置信息的情形这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 @Value 注解引入相应的微服务地址的话，太过于繁琐，也不科学。 所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好： 12345678# 配置多个微服务的地址url: # 订单微服务的地址 orderUrl: http://localhost:8002 # 用户微服务的地址 userUrl: http://localhost:8003 # 购物车微服务的地址 shoppingUrl: http://localhost:8004 也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 MicroServiceUrl 类来专门保存微服务的 url，如下： 123456789@Component@ConfigurationProperties(prefix = "url")public class MicroServiceUrl &#123; private String orderUrl; private String userUrl; private String shoppingUrl; // 省去get和set方法&#125; 细心的朋友应该可以看到，使用 @ConfigurationProperties 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 @Component 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。 需要注意的是，使用 @ConfigurationProperties 注解需要导入它的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; OK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 @Resource 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下： 123456789101112131415161718@RestController@RequestMapping("/test")public class TestController &#123; private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class); @Resource private MicroServiceUrl microServiceUrl; @RequestMapping("/config") public String testConfig() &#123; LOGGER.info("=====获取的订单服务地址为：&#123;&#125;", microServiceUrl.getOrderUrl()); LOGGER.info("=====获取的用户服务地址为：&#123;&#125;", microServiceUrl.getUserUrl()); LOGGER.info("=====获取的购物车服务地址为：&#123;&#125;", microServiceUrl.getShoppingUrl()); return "success"; &#125;&#125; 再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容： 1234=====获取的订单服务地址为：http://localhost:8002=====获取的订单服务地址为：http://localhost:8002=====获取的用户服务地址为：http://localhost:8003=====获取的购物车服务地址为：http://localhost:8004 3. 指定项目配置文件我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。 最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。 我们新建两个配置文件： application-dev.yml 和 application-pro.yml，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002. 123# 开发环境配置文件server: port: 8001 123# 开发环境配置文件server: port: 8002 然后在 application.yml 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 applicationn-dev.yml 文件，如下： 1234spring: profiles: active: - dev 这样就可以在开发的时候，指定读取 application-dev.yml 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 application.yml 中指定的文件改成 application-pro.yml 即可，然后使用 8002 端口访问，非常方便。 4. 总结本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第05课：Spring Boot中的MVC支持Spring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 @RestController、 @RequestMapping、@PathVariable、@RequestParam 以及 @RequestBody。主要介绍这几个注解常用的使用方式和特点。 1. @RestController@RestController 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。 12345678@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController &#123; String value() default "";&#125; 可以看出， @RestController 注解包含了原来的 @Controller 和 @ResponseBody 注解，使用过 Spring 的朋友对 @Controller 注解已经非常了解了，这里不再赘述， @ResponseBody 注解是将返回的数据结构转换为 Json 格式。所以 @RestController 可以看作是 @Controller 和 @ResponseBody 的结合体，相当于偷个懒，我们使用 @RestController 之后就不用再使用 @Controller 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用@RestController 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用@RestController了，比如： 123public String getUser() &#123; return "user";&#125; 其实是需要返回到 user.html 页面的，如果使用 @RestController 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 @Controller 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。 2. @RequestMapping@RequestMapping 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。 该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。 value 属性：指定请求的实际地址，value 可以省略不写 method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET produces属性：指定返回内容类型，如 produces = “application/json; charset=UTF-8” @RequestMapping 注解比较简单，举个例子： 123456789@RestController@RequestMapping(value = "/test", produces = "application/json; charset=UTF-8")public class TestController &#123; @RequestMapping(value = "/get", method = RequestMethod.GET) public String testGet() &#123; return "success"; &#125;&#125; 这个很简单，启动项目在浏览器中输入 localhost:8080/test/get 测试一下即可。 针对四种不同的请求方式，是有相应注解的，不用每次在 @RequestMapping 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 @GetMapping(&quot;/get&quot;) 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 @PutMapping、@PostMapping 和 DeleteMapping。 3. @PathVariable@PathVariable 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 @PathVariable 注解。如下： 12345@GetMapping("/user/&#123;id&#125;")public String testPathVariable(@PathVariable Integer id) &#123; System.out.println("获取到的id为：" + id); return "success";&#125; 这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 @PathVariable 中的 value 属性来指定对应关系。如下： 12345@RequestMapping("/user/&#123;idd&#125;")public String testPathVariable(@PathVariable(value = "idd") Integer id) &#123; System.out.println("获取到的id为：" + id); return "success";&#125; 对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：/xxx/{id}/user。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如： 123456@GetMapping("/user/&#123;idd&#125;/&#123;name&#125;") public String testPathVariable(@PathVariable(value = "idd") Integer id, @PathVariable String name) &#123; System.out.println("获取到的id为：" + id); System.out.println("获取到的name为：" + name); return "success"; &#125; 运行项目，在浏览器中请求 localhost:8080/test/user/2/zhangsan 可以看到控制台输出如下信息： 12获取到的id为：2获取到的name为：zhangsan 所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。 4. @RequestParam@RequestParam 注解顾名思义，也是获取请求参数的，上面我们介绍了 @PathValiable 注解也是获取请求参数的，那么 @RequestParam 和 @PathVariable 有什么不同呢？主要区别在于： @PathValiable 是从 url 模板中获取参数值， 即这种风格的 url：http://localhost:8080/user/{id} ；而 @RequestParam 是从 request 里面获取参数值，即这种风格的 url：http://localhost:8080/user?id=1 。我们使用该 url 带上参数 id 来测试一下如下代码： 12345@GetMapping("/user")public String testRequestParam(@RequestParam Integer id) &#123; System.out.println("获取到的id为：" + id); return "success";&#125; 可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：http://localhost:8080/user?idd=1 12345@RequestMapping("/user")public String testRequestParam(@RequestParam(value = "idd", required = false) Integer id) &#123; System.out.println("获取到的id为：" + id); return "success";&#125; 除了 value 属性外，还有个两个属性比较常用： required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。 defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。 从 url 中可以看出，@RequestParam 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 @RequestParam 来接收，用法和上面一样。 123456@PostMapping("/form1") public String testForm(@RequestParam String username, @RequestParam String password) &#123; System.out.println("获取到的username为：" + username); System.out.println("获取到的password为：" + password); return "success"; &#125; 我们使用 postman 来模拟一下表单提交，测试一下接口： 那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 @RequestParam 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。 12345public class User &#123; private String username; private String password; // set get&#125; 使用实体接收的话，我们不能在前面加 @RequestParam 注解了，直接使用即可。 123456@PostMapping("/form2") public String testForm(User user) &#123; System.out.println("获取到的username为：" + user.getUsername()); System.out.println("获取到的password为：" + user.getPassword()); return "success"; &#125; 使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多。 5. @RequestBody@RequestBody 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 @RequestBody 接收会非常方便。例如： 12345public class User &#123; private String username; private String password; // set get&#125; 123456@PostMapping("/user")public String testRequestBody(@RequestBody User user) &#123; System.out.println("获取到的username为：" + user.getUsername()); System.out.println("获取到的password为：" + user.getPassword()); return "success";&#125; 我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。 同时看一下后台控制台输出的日志： 12获取到的username为：倪升武获取到的password为：123456 可以看出，@RequestBody 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。 6. 总结本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 @RestController、 @RequestMapping、@PathVariable、 @RequestParam 和 @RequestBody 四个注解的使用方式，由于 @RestController 中集成了 @ResponseBody 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第06课：Spring Boot集成 Swagger2 展现在线接口文档1. Swagger 简介1.1 解决的问题随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。 那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。 1.2 Swagger 官方我们打开 Swagger 官网，官方对 Swagger 的定义为： The Best APIs are Built with Swagger Tools 翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示： 本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。 2. Swagger2 的 maven 依赖使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 2.8.0，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.2.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.2.2 版本来展开，依赖如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 3. Swagger2 的配置使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 @Configuration 注解外，还需要添加 @EnableSwagger2 注解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author shengwu ni */@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) // 指定构建api文档的详细信息的方法：apiInfo() .apiInfo(apiInfo()) .select() // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口 .apis(RequestHandlerSelectors.basePackage("com.itcodai.course06.controller")) .paths(PathSelectors.any()) .build(); &#125; /** * 构建api文档的详细信息 * @return */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() // 设置页面标题 .title("Spring Boot集成Swagger2接口总览") // 设置接口描述 .description("跟武哥一起学Spring Boot第06课") // 设置联系方式 .contact("倪升武，" + "CSDN：http://blog.csdn.net/eson_15") // 设置版本 .version("1.0") // 构建 .build(); &#125;&#125; 在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 localhost:8080/swagger-ui.html，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。 结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。 【友情提示】可能有很多朋友在配置 Swagger 的时候会遇到下面的情况，而且还关不掉的，这是因为浏览器缓存引起的，清空一下浏览器缓存即可解决问题。 4. Swagger2 的使用上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。 4.1 实体类注解本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 @ApiModel 和 @ApiModelProperty 注解，同时为后面的测试做准备。 1234567891011121314151617import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;@ApiModel(value = "用户实体类")public class User &#123; @ApiModelProperty(value = "用户唯一标识") private Long id; @ApiModelProperty(value = "用户姓名") private String username; @ApiModelProperty(value = "用户密码") private String password; // 省略set和get方法&#125; 解释下 @ApiModel 和 @ApiModelProperty 注解： @ApiModel 注解用于实体类，表示对类进行说明，用于参数用实体类接收。@ApiModelProperty 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。 该注解在在线 API 文档中的具体效果在下文说明。 4.2 Controller 类中相关注解我们写一个 TestController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。 1234567891011121314151617181920212223import com.itcodai.course06.entiy.JsonResult;import com.itcodai.course06.entiy.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/swagger")@Api(value = "Swagger2 在线接口文档")public class TestController &#123; @GetMapping("/get/&#123;id&#125;") @ApiOperation(value = "根据用户唯一标识获取用户信息") public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = "用户唯一标识") Long id) &#123; // 模拟数据库中根据id获取User信息 User user = new User(id, "倪升武", "123456"); return new JsonResult(user); &#125;&#125; 我们来学习一下 @Api 、 @ApiOperation 和 @ApiParam 注解。 @Api 注解用于类上，表示标识这个类是 swagger 的资源。@ApiOperation 注解用于方法，表示一个 http 请求的操作。@ApiParam 注解用于参数上，用来标明参数信息。 这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 localhost:8080/swagger-ui.html 看一下 Swagger 页面的接口状态。 可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为1，看一下返回数据： 可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。 123456@PostMapping("/insert") @ApiOperation(value = "添加用户信息") public JsonResult&lt;Void&gt; insertUser(@RequestBody @ApiParam(value = "用户信息") User user) &#123; // 处理添加逻辑 return new JsonResult&lt;&gt;(); &#125; 重启项目，在浏览器中输入 localhost:8080/swagger-ui.html 看一下效果： 5. 总结OK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。 课程源代码下载地址：戳我下载 第07课：Spring Boot集成Thymeleaf模板引擎1. Thymeleaf 介绍 Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。 以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。 什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如： 1234&lt;div class="ui right aligned basic segment"&gt; &lt;div class="ui orange basic label" th:text="$&#123;blog.flag&#125;"&gt;静态原创信息&lt;/div&gt;&lt;/div&gt;&lt;h2 class="ui center aligned header" th:text="$&#123;blog.title&#125;"&gt;这是静态标题&lt;/h2&gt; 类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，th:text 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 th:text），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。 2. 依赖导入在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入： 1&lt;html xmlns:th="http://www.thymeleaf.org"&gt; 3. Thymeleaf相关配置因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。 123spring: thymeleaf: cache: false #关闭缓存 否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。 4. Thymeleaf 的使用4.1 访问静态页面这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 这是404页面&lt;/body&gt;&lt;/html&gt; 我们再写一个 controller 来测试一下 404 和 500 页面： 123456789101112131415@Controller@RequestMapping("/thymeleaf")public class ThymeleafController &#123; @RequestMapping("/test404") public String test404() &#123; return "index"; &#125; @RequestMapping("/test500") public String test500() &#123; int i = 1 / 0; return "index"; &#125;&#125; 当我们在浏览器中输入 localhost:8080/thymeleaf/test400 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。当我们在浏览器中输入 localhost:8088/thymeleaf/test505 时，会抛出异常，然后会自动跳转到 500.html 显示。 【注】这里有个问题需要注意一下，前面的课程中我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 @RestController 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 @RestController 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 @RestController 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 @Controller 注解。 4.2 Thymeleaf 中处理对象我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如： 123456public class Blogger &#123; private Long id; private String name; private String pass; // 省去set和get&#125; 然后在controller层中初始化一下： 123456@GetMapping("/getBlogger")public String getBlogger(Model model) &#123; Blogger blogger = new Blogger(1L, "倪升武", "123456"); model.addAttribute("blogger", blogger); return "blogger";&#125; 我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;博主信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="" th:object="$&#123;blogger&#125;" &gt; 用户编号：&lt;input name="id" th:value="$&#123;blogger.id&#125;"/&gt;&lt;br&gt; 用户姓名：&lt;input type="text" name="username" th:value="$&#123;blogger.getName()&#125;" /&gt;&lt;br&gt; 登陆密码：&lt;input type="text" name="password" th:value="*&#123;pass&#125;" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 可以看出，在 thymeleaf 模板中，使用 th:object=&quot;${}&quot; 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下： 使用 th:value=&quot;*{属性名}&quot;使用 th:value=&quot;${对象.属性名}&quot;，对象指的是上面使用 th:object 获取的对象使用 th:value=&quot;${对象.get方法}&quot;，对象指的是上面使用 th:object 获取的对象 可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 localhost:8080/thymeleaf/getBlogger 来测试一下数据： 4.3 Thymeleaf 中处理 List处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。 12345678910@GetMapping("/getList")public String getList(Model model) &#123; Blogger blogger1 = new Blogger(1L, "倪升武", "123456"); Blogger blogger2 = new Blogger(2L, "达人课", "123456"); List&lt;Blogger&gt; list = new ArrayList&lt;&gt;(); list.add(blogger1); list.add(blogger2); model.addAttribute("list", list); return "list";&#125; 接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;博主信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="" th:each="blogger : $&#123;list&#125;" &gt; 用户编号：&lt;input name="id" th:value="$&#123;blogger.id&#125;"/&gt;&lt;br&gt; 用户姓名：&lt;input type="text" name="password" th:value="$&#123;blogger.name&#125;"/&gt;&lt;br&gt; 登录密码：&lt;input type="text" name="username" th:value="$&#123;blogger.getPass()&#125;"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 th:each 进行遍历，${} 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 ${对象.属性名} 来获取 list 中对象的属性值，也可以使用 ${对象.get方法} 来获取，这点和上面处理对象信息是一样的，但是不能使用 *{属性名} 来获取对象中的属性，thymeleaf 模板获取不到。 4.4 其他常用 thymeleaf 操作我们来总结一下 thymeleaf 中的一些常用的标签操作，如下： 标签 功能 例子 th:value 给属性赋值 &lt;input th:value=&quot;${blog.name}&quot; /&gt; th:style 设置样式 th:style=&quot;&#39;display:&#39;+@{(${sitrue}?&#39;none&#39;:&#39;inline-block&#39;)} + &#39;&#39;&quot; th:onclick 点击事件 th:onclick=&quot;&#39;getInfo()&#39;&quot; th:if 条件判断 &lt;a th:if=&quot;${userId == collect.userId}&quot; &gt; th:href 超链接 &lt;a th:href=&quot;@{/blogger/login}&quot;&gt;Login&lt;/a&gt; /&gt; th:unless 条件判断和th:if相反 &lt;a th:href=&quot;@{/blogger/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; th:switch 配合th:case &lt;div th:switch=&quot;${user.role}&quot;&gt; th:case 配合th:switch &lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;administator&lt;/p&gt; th:src 地址引入 &lt;img alt=&quot;csdn logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt; th:action 表单提交的地址 &lt;form th:action=&quot;@{/blogger/update}&quot;&gt; Thymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的官方文档（v3.0）。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。 5. 总结Thymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。 课程源代码下载地址：戳我下载 第08课：Spring Boot中的全局异常处理在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。 1. 定义返回的统一 json 结构前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。这个统一的 json 结构这可以参考第02课：Spring Boot 返回 JSON 数据及数据封装中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下： 12345678910111213141516171819202122public class JsonResult &#123; /** * 异常码 */ protected String code; /** * 异常信息 */ protected String msg; public JsonResult() &#123; this.code = "200"; this.msg = "操作成功"; &#125; public JsonResult(String code, String msg) &#123; this.code = code; this.msg = msg; &#125; // get set&#125; 2. 处理系统异常新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 @ControllerAdvice 注解即可拦截项目中抛出的异常，如下： 1234567@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; // 打印log private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); // ……&#125; 我们点开 @ControllerAdvice 注解可以看到，@ControllerAdvice 注解包含了 @Component 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 basePackages 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。@ResponseBody 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 @ExceptionHandler 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。 2.1 处理参数缺失异常在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。 参数缺失的时候，会抛出 HttpMessageNotReadableException，我们可以拦截该异常，做一个友好处理，如下： 123456789101112/*** 缺少请求参数异常* @param ex HttpMessageNotReadableException* @return*/@ExceptionHandler(MissingServletRequestParameterException.class)@ResponseStatus(value = HttpStatus.BAD_REQUEST)public JsonResult handleHttpMessageNotReadableException( MissingServletRequestParameterException ex) &#123; logger.error("缺少请求参数，&#123;&#125;", ex.getMessage()); return new JsonResult("400", "缺少必要的请求参数");&#125; 我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。 1234567891011121314@RestController@RequestMapping("/exception")public class ExceptionController &#123; private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class); @PostMapping("/test") public JsonResult test(@RequestParam("name") String name, @RequestParam("pass") String pass) &#123; logger.info("name：&#123;&#125;", name); logger.info("pass：&#123;&#125;", pass); return new JsonResult(); &#125;&#125; 然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下： 2.2 处理空指针异常空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下： 123456789101112131415161718@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 空指针异常 * @param ex NullPointerException * @return */ @ExceptionHandler(NullPointerException.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleTypeMismatchException(NullPointerException ex) &#123; logger.error("空指针异常，&#123;&#125;", ex.getMessage()); return new JsonResult("500", "空指针异常了"); &#125;&#125; 这个我就不测试了，代码中 ExceptionController 有个 testNullPointException 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息： 1&#123;"code":"500","msg":"空指针异常了"&#125; 2.3 一劳永逸？当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸： 1234567891011121314151617@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 系统异常 预期以外异常 * @param ex * @return */ @ExceptionHandler(Exception.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleUnexpectedServer(Exception ex) &#123; logger.error("系统异常：", ex); return new JsonResult("500", "系统发生异常，请联系管理员"); &#125;&#125; 但是项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。 3. 拦截自定义异常在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很平凡，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。 3.1 定义异常信息由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如： 123456789101112131415161718192021222324252627282930/** * 业务异常提示信息枚举类 * @author shengwu ni */public enum BusinessMsgEnum &#123; /** 参数异常 */ PARMETER_EXCEPTION("102", "参数异常!"), /** 等待超时 */ SERVICE_TIME_OUT("103", "服务调用超时！"), /** 参数过大 */ PARMETER_BIG_EXCEPTION("102", "输入的图片数量不能超过50张!"), /** 500 : 一劳永逸的提示也可以在这定义 */ UNEXPECTED_EXCEPTION("500", "系统发生异常，请联系管理员！"); // 还可以定义更多的业务异常 /** * 消息码 */ private String code; /** * 消息内容 */ private String msg; private BusinessMsgEnum(String code, String msg) &#123; this.code = code; this.msg = msg; &#125; // set get方法&#125; 3.2 拦截自定义异常然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下： 1234567891011121314151617181920212223/** * 自定义业务异常 * @author shengwu ni */public class BusinessErrorException extends RuntimeException &#123; private static final long serialVersionUID = -7480022450501760611L; /** * 异常码 */ private String code; /** * 异常提示信息 */ private String message; public BusinessErrorException(BusinessMsgEnum businessMsgEnum) &#123; this.code = businessMsgEnum.code(); this.message = businessMsgEnum.msg(); &#125; // get set方法&#125; 在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。 123456789101112131415161718@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 拦截业务异常，返回业务异常信息 * @param ex * @return */ @ExceptionHandler(BusinessErrorException.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleBusinessError(BusinessErrorException ex) &#123; String code = ex.getCode(); String message = ex.getMessage(); return new JsonResult(code, message); &#125;&#125; 在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下： 12345678910111213141516@RestController@RequestMapping("/exception")public class ExceptionController &#123; private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class); @GetMapping("/business") public JsonResult testException() &#123; try &#123; int i = 1 / 0; &#125; catch (Exception e) &#123; throw new BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION); &#125; return new JsonResult(); &#125;&#125; 运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功： 1&#123;"code":"500","msg":"系统发生异常，请联系管理员！"&#125; 4. 总结本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。 课程源代码下载地址：戳我下载 第09课：Spring Boot中的切面AOP处理1. 什么是AOPAOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？ 对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！ 这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。 2. Spring Boot 中的 AOP 处理2.1 AOP 依赖使用AOP，首先需要引入AOP的依赖。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 实现 AOP 切面Spring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个@Aspect注解即可。@Aspect 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。@Component 注解让该类交给 Spring 来管理。 12345@Aspect@Componentpublic class LogAspectHandler &#123;&#125; 这里主要介绍几个常用的注解及使用： 1.@Pointcut：定义一个切面，即上面所描述的关注的某件事入口。2.@Before：在做某件事之前做的事。3.@After：在做某件事之后做的事。4.@AfterReturning：在做某件事之后，对其返回值做增强处理。5.@AfterThrowing：在做某件事抛出异常时，处理。 2.2.1 @Pointcut 注解@Pointcut 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。 12345678910@Aspect@Componentpublic class LogAspectHandler &#123; /** * 定义一个切面，拦截com.itcodai.course09.controller包和子包下的所有方法 */ @Pointcut("execution(* com.itcodai.course09.controller..*.*(..))") public void pointCut() &#123;&#125;&#125; @Pointcut 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 execution()，另一个是使用 annotation()。以 execution(* com.itcodai.course09.controller..*.*(..))) 表达式为例，语法如下： execution() 为表达式主体第一个 * 号的位置：表示返回值类型，* 表示所有类型包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.itcodai.course09.controller 包、子包下所有类的方法第二个 * 号的位置：表示类名，* 表示所有类*(..) ：这个星号表示方法名，* 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数 annotation() 方式是针对某个注解来定义切面，比如我们对具有@GetMapping注解的方法做切面，可以如下定义切面： 12@Pointcut("@annotation(org.springframework.web.bind.annotation.GetMapping)")public void annotationCut() &#123;&#125; 然后使用该切面的话，就会切入注解是 @GetMapping 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 @GetMapping、@PostMapping、@DeleteMapping 等。所以这种按照注解的切入方式在实际项目中也很常用。 2.2.2 @Before 注解@Before 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如： 1234567891011121314151617181920212223242526272829303132@Aspect@Componentpublic class LogAspectHandler &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 在上面定义的切面方法之前执行该方法 * @param joinPoint jointPoint */ @Before("pointCut()") public void doBefore(JoinPoint joinPoint) &#123; logger.info("====doBefore方法进入了===="); // 获取签名 Signature signature = joinPoint.getSignature(); // 获取切入的包名 String declaringTypeName = signature.getDeclaringTypeName(); // 获取即将执行的方法名 String funcName = signature.getName(); logger.info("即将执行方法为: &#123;&#125;，属于&#123;&#125;包", funcName, declaringTypeName); // 也可以用来记录一些信息，比如获取请求的url和ip ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); // 获取请求url String url = request.getRequestURL().toString(); // 获取请求ip String ip = request.getRemoteAddr(); logger.info("用户请求的url为：&#123;&#125;，ip地址为：&#123;&#125;", url, ip); &#125;&#125; JointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，包括参数（通过 joinPoint.getArgs() 获取）等等。 2.2.3 @After 注解@After 注解和 @Before 注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。 12345678910111213141516171819202122232425@Aspect@Componentpublic class LogAspectHandler &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 定义一个切面，拦截com.itcodai.course09.controller包下的所有方法 */ @Pointcut("execution(* com.itcodai.course09.controller..*.*(..))") public void pointCut() &#123;&#125; /** * 在上面定义的切面方法之后执行该方法 * @param joinPoint jointPoint */ @After("pointCut()") public void doAfter(JoinPoint joinPoint) &#123; logger.info("====doAfter方法进入了===="); Signature signature = joinPoint.getSignature(); String method = signature.getName(); logger.info("方法&#123;&#125;已经执行完", method); &#125;&#125; 到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下： 123456789@RestController@RequestMapping("/aop")public class AopController &#123; @GetMapping("/&#123;name&#125;") public String testAop(@PathVariable String name) &#123; return "Hello " + name; &#125;&#125; 启动项目，在浏览器中输入 localhost:8080/aop/CSDN，观察一下控制台的输出信息： 12345====doBefore方法进入了==== 即将执行方法为: testAop，属于com.itcodai.course09.controller.AopController包 用户请求的url为：http://localhost:8080/aop/name，ip地址为：0:0:0:0:0:0:0:1 ====doAfter方法进入了==== 方法testAop已经执行完 从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 @Before 和 @After 两个注解的实际作用。 2.2.4 @AfterReturning 注解@AfterReturning 注解和 @After 有些类似，区别在于 @AfterReturning 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如： 123456789101112131415161718192021@Aspect@Componentpublic class LogAspectHandler &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强 * @param joinPoint joinPoint * @param result result */ @AfterReturning(pointcut = "pointCut()", returning = "result") public void doAfterReturning(JoinPoint joinPoint, Object result) &#123; Signature signature = joinPoint.getSignature(); String classMethod = signature.getName(); logger.info("方法&#123;&#125;执行完毕，返回参数为：&#123;&#125;", classMethod, result); // 实际项目中可以根据业务做具体的返回值增强 logger.info("对返回参数进行业务上的增强：&#123;&#125;", result + "增强版"); &#125;&#125; 需要注意的是：在 @AfterReturning注解 中，属性 returning 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 doAfterReturning 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）： 12方法testAop执行完毕，返回参数为：Hello CSDN 对返回参数进行业务上的增强：Hello CSDN增强版 2.2.5 @AfterThrowing 注解顾名思义，@AfterThrowing 注解是当被切方法执行时抛出异常时，会进入 @AfterThrowing 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 throwing 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。 123456789101112131415161718192021222324/** * 使用AOP处理log * @author shengwu ni * @date 2018/05/04 20:24 */@Aspect@Componentpublic class LogAspectHandler &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 在上面定义的切面方法执行抛异常时，执行该方法 * @param joinPoint jointPoint * @param ex ex */ @AfterThrowing(pointcut = "pointCut()", throwing = "ex") public void afterThrowing(JoinPoint joinPoint, Throwable ex) &#123; Signature signature = joinPoint.getSignature(); String method = signature.getName(); // 处理异常的逻辑 logger.info("执行方法&#123;&#125;出错，异常为：&#123;&#125;", method, ex); &#125;&#125; 该方法我就不测试了，大家可以自行测试一下。 3. 总结本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第10课：Spring Boot集成MyBatis1. MyBatis 介绍大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。 2. MyBatis 的配置2.1 依赖导入Spring Boot 集成 MyBatis，需要导入 mybatis-spring-boot-starter 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 我们点开 mybatis-spring-boot-starter 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。 123456789&lt;!-- 省去其他 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 properties.yml配置我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？ 12345678910111213141516171819202122232425# 服务端口号server: port: 8080# 数据库地址datasource: url: localhost:3306/blog_testspring: datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://$&#123;datasource.url&#125;?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10 username: root password: 123456 hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000mybatis: # 指定别名设置的包为所有entity type-aliases-package: com.itcodai.course10.entity configuration: map-underscore-to-camel-case: true # 驼峰命名规范 mapper-locations: # mapper映射文件位置 - classpath:mapper/*.xml 我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的朋友可以去百度或者谷歌搜一搜，了解一下。 这里说明一下 map-underscore-to-camel-case: true， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：user_name， 那么在实体类中可以定义属性为 userName （甚至可以写成 username，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。 3. 基于 xml 的整合使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：classpath:mapper/*.xml，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件。 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itcodai.course10.dao.UserMapper"&gt; &lt;resultMap id="BaseResultMap" type="com.itcodai.course10.entity.User"&gt; &lt;id column="id" jdbcType="BIGINT" property="id" /&gt; &lt;result column="user_name" jdbcType="VARCHAR" property="username" /&gt; &lt;result column="password" jdbcType="VARCHAR" property="password" /&gt; &lt;/resultMap&gt; &lt;select id="getUserByName" resultType="User" parameterType="String"&gt; select * from user where user_name = #&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; 这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， &lt;resultMap&gt; 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。 实体类中有 id，username 和 password，我不在这贴代码，大家可以下载源码查看。UserMapper.java 文件中写一个接口即可： 1User getUserByName(String username); 中间省略 service 的代码，我们写一个 Controller 来测试一下： 1234567891011@RestControllerpublic class TestController &#123; @Resource private UserService userService; @RequestMapping("/getUserByName/&#123;name&#125;") public User getUserByName(@PathVariable String name) &#123; return userService.getUserByName(name); &#125;&#125; 启动项目，在浏览器中输入：http://localhost:8080/getUserByName/CSDN 即可查询到数据库表中用户名为 CSDN 的用户信息（事先搞两个数据进去即可）： 1&#123;"id":2,"username":"CSDN","password":"123456"&#125; 这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 @Mapper 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 @Mapper 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加@MaperScan 注解，来扫描一个包下的所有 mapper。如下： 12345678@SpringBootApplication@MapperScan("com.itcodai.course10.dao")public class Course10Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Course10Application.class, args); &#125;&#125; 这样的话，com.itcodai.course10.dao 包下的所有 mapper 都会被扫描到了。 4. 基于注解的整合基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 @Select， @Insert， @Update， Delete 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子： 12@Select("select * from user where id = #&#123;id&#125;")User getUser(Long id); 这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 @Param 注解来指定每一个参数的对应关系，如下： 12@Select("select * from user where id = #&#123;id&#125; and user_name=#&#123;name&#125;")User getUserByIdAndName(@Param("id") Long id, @Param("name") String username); 可以看出，@Param 指定的参数应该要和 sql 中 #{} 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下，接口都在源码中，文章中我就不贴测试代码和结果了。 有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 @Results 注解来解决。 123456@Select("select * from user where id = #&#123;id&#125;")@Results(&#123; @Result(property = "username", column = "user_name"), @Result(property = "password", column = "password")&#125;)User getUser(Long id); @Results 中的 @Result 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。 当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 @ResultMap 注解来替代 @Results 注解，如下： 123@Select("select * from user where id = #&#123;id&#125;")@ResultMap("BaseResultMap")User getUser(Long id); @ResultMap 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 &lt;resultMap&gt; 时对应的 id 值： 1&lt;resultMap id="BaseResultMap" type="com.itcodai.course10.entity.User"&gt; 这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。 5. 总结本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。 课程源代码下载地址：戳我下载 第11课：Spring Boot事务配置管理1. 事务相关场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。 事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。 事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。 2. Spring Boot 事务配置2.1 依赖导入在 Spring Boot 中使用事务，需要导入 mysql 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 @Transactional 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。 2.2 事务的测试我们首先在数据库表中插入一条数据： id user_name password 1 倪升武 123456 然后我们写一个插入的 mapper： 12345public interface UserMapper &#123; @Insert("insert into user (user_name, password) values (#&#123;username&#125;, #&#123;password&#125;)") Integer insertUser(User user);&#125; OK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。 123456789101112131415@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override @Transactional public void isertUser(User user) &#123; // 插入用户信息 userMapper.insertUser(user); // 手动抛出异常 throw new RuntimeException(); &#125;&#125; 我们来测试一下： 12345678910111213141516@RestControllerpublic class TestController &#123; @Resource private UserService userService; @PostMapping("/adduser") public String addUser(@RequestBody User user) throws Exception &#123; if (null != user) &#123; userService.isertUser(user); return "success"; &#125; else &#123; return "false"; &#125; &#125;&#125; 我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此…… 3. 常见问题总结从上面的内容中可以看出，Spring Boot 中使用事务非常简单，@Transactional 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。 这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。 3.1 异常并没有被 ”捕获“ 到首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子： 123456789101112131415@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override @Transactional public void isertUser2(User user) throws Exception &#123; // 插入用户信息 userMapper.insertUser(user); // 手动抛出异常 throw new SQLException("数据库异常"); &#125;&#125; 我们看上面这个代码，其实并没有什么问题，手动抛出一个 SQLException 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。 那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 @Transactional 注解中使用 rollbackFor 属性来指定异常，比如 @Transactional(rollbackFor = Exception.class)，这样就没有问题了，所以在实际项目中，一定要指定异常。 3.2 异常被 ”吃“ 掉这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try…catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码： 12345678910111213141516171819@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override @Transactional(rollbackFor = Exception.class) public void isertUser3(User user) &#123; try &#123; // 插入用户信息 userMapper.insertUser(user); // 手动抛出异常 throw new SQLException("数据库异常"); &#125; catch (Exception e) &#123; // 异常处理逻辑 &#125; &#125;&#125; 读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try…catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。 那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。 3.3 事务的范围事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。 我来写个 demo： 12345678910111213@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override @Transactional(rollbackFor = Exception.class) public synchronized void isertUser4(User user) &#123; // 实际中的具体业务…… userMapper.insertUser(user); &#125;&#125; 可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。 但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。 从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。 这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。 4. 总结本章主要总结了 Spring Boot 中如何使用事务，只要使用 @Transactional 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的朋友。 课程源代码下载地址：戳我下载 第12课：Spring Boot中使用监听器1. 监听器介绍什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。 2. Spring Boot中监听器的使用web 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。 2.1 监听Servlet上下文对象监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。 针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。 下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据： 123456789101112@Servicepublic class UserService &#123; /** * 获取用户信息 * @return */ public User getUser() &#123; // 实际中会根据具体的业务场景，从数据库中查询对应的信息 return new User(1L, "倪升武", "123456"); &#125;&#125; 然后写一个监听器，实现 ApplicationListener&lt;ContextRefreshedEvent&gt; 接口，重写 onApplicationEvent 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下： 1234567891011121314151617181920/** * 使用ApplicationListener来初始化一些数据到application域中的监听器 * @author shengni ni * @date 2018/07/05 */@Componentpublic class MyServletContextListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; @Override public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) &#123; // 先获取到application上下文 ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext(); // 获取对应的service UserService userService = applicationContext.getBean(UserService.class); User user = userService.getUser(); // 获取application域对象，将查到的信息放到application域中 ServletContext application = applicationContext.getBean(ServletContext.class); application.setAttribute("user", user); &#125;&#125; 正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。 12345678910@RestController@RequestMapping("/listener")public class TestController &#123; @GetMapping("/user") public User getUser(HttpServletRequest request) &#123; ServletContext application = request.getServletContext(); return (User) application.getAttribute("user"); &#125;&#125; 启动项目，在浏览器中输入 http://localhost:8080/listener/user 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。 2.2 监听HTTP会话 Session对象监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。 1234567891011121314151617181920212223242526272829/** * 使用HttpSessionListener统计在线用户数的监听器 * @author shengwu ni * @date 2018/07/05 */@Componentpublic class MyHttpSessionListener implements HttpSessionListener &#123; private static final Logger logger = LoggerFactory.getLogger(MyHttpSessionListener.class); /** * 记录在线的用户数量 */ public Integer count = 0; @Override public synchronized void sessionCreated(HttpSessionEvent httpSessionEvent) &#123; logger.info("新用户上线了"); count++; httpSessionEvent.getSession().getServletContext().setAttribute("count", count); &#125; @Override public synchronized void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123; logger.info("用户下线了"); count--; httpSessionEvent.getSession().getServletContext().setAttribute("count", count); &#125;&#125; 可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 sessionCreated 和 sessionDestroyed 方法，在 sessionCreated 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，sessionDestroyed 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。 123456789101112131415@RestController@RequestMapping("/listener")public class TestController &#123; /** * 获取当前在线人数，该方法有bug * @param request * @return */ @GetMapping("/total") public String getTotalUser(HttpServletRequest request) &#123; Integer count = (Integer) request.getSession().getServletContext().getAttribute("count"); return "当前在线人数：" + count; &#125;&#125; 该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 localhost:8080/listener/total 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下： 12345678910111213141516@GetMapping("/total2")public String getTotalUser(HttpServletRequest request, HttpServletResponse response) &#123; Cookie cookie; try &#123; // 把sessionId记录在浏览器中 cookie = new Cookie("JSESSIONID", URLEncoder.encode(request.getSession().getId(), "utf-8")); cookie.setPath("/"); //设置cookie有效期为2天，设置长一点 cookie.setMaxAge( 48*60 * 60); response.addCookie(cookie); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; Integer count = (Integer) request.getSession().getServletContext().getAttribute("count"); return "当前在线人数：" + count;&#125; 可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。 2.3 监听客户端请求Servlet Request对象使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下： 1234567891011121314151617181920212223242526272829/** * 使用ServletRequestListener获取访问信息 * @author shengwu ni * @date 2018/07/05 */@Componentpublic class MyServletRequestListener implements ServletRequestListener &#123; private static final Logger logger = LoggerFactory.getLogger(MyServletRequestListener.class); @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123; HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest(); logger.info("session id为：&#123;&#125;", request.getRequestedSessionId()); logger.info("request url为：&#123;&#125;", request.getRequestURL()); request.setAttribute("name", "倪升武"); &#125; @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123; logger.info("request end"); HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest(); logger.info("request域中保存的name值为：&#123;&#125;", request.getAttribute("name")); &#125;&#125; 这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。 12345@GetMapping("/request")public String getRequestInfo(HttpServletRequest request) &#123; System.out.println("requestListener中的初始化的name数据：" + request.getAttribute("name")); return "success";&#125; 3. Spring Boot中自定义事件监听在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。 3.1 自定义事件自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下： 12345678910111213141516/** * 自定义事件 * @author shengwu ni * @date 2018/07/05 */public class MyEvent extends ApplicationEvent &#123; private User user; public MyEvent(Object source, User user) &#123; super(source); this.user = user; &#125; // 省去get、set方法&#125; 3.2 自定义监听器接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 ApplicationListener 接口即可。如下： 1234567891011121314151617/** * 自定义监听器，监听MyEvent事件 * @author shengwu ni * @date 2018/07/05 */@Componentpublic class MyEventListener implements ApplicationListener&lt;MyEvent&gt; &#123; @Override public void onApplicationEvent(MyEvent myEvent) &#123; // 把事件中的信息获取到 User user = myEvent.getUser(); // 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等 System.out.println("用户名：" + user.getUsername()); System.out.println("密码：" + user.getPassword()); &#125;&#125; 然后重写 onApplicationEvent 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。 OK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下： 12345678910111213141516171819202122/** * UserService * @author shengwu ni */@Servicepublic class UserService &#123; @Resource private ApplicationContext applicationContext; /** * 发布事件 * @return */ public User getUser2() &#123; User user = new User(1L, "倪升武", "123456"); // 发布事件 MyEvent event = new MyEvent(this, user); applicationContext.publishEvent(event); return user; &#125;&#125; 在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。 最后，在 Controller 中写一个接口来测试一下： 12345@GetMapping("/request")public String getRequestInfo(HttpServletRequest request) &#123; System.out.println("requestListener中的初始化的name数据：" + request.getAttribute("name")); return "success";&#125; 在浏览器中输入 http://localhost:8080/listener/publish，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。 4. 总结本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望读者认真消化。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第13课：Spring Boot中使用拦截器拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。 1. 拦截器的快速使用使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。 1.1 定义拦截器定义拦截器，只需要实现 HandlerInterceptor 接口，HandlerInterceptor 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： preHandle(……)、postHandle(……) 和 afterCompletion(……) 。 preHandle(……) 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 preHandle(……) 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。postHandle(……) 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。afterCompletion(……) 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 preHandle(……) 被成功执行后并且返回 true 才会被执行。 了解了该接口，接下来自定义一个拦截器。 123456789101112131415161718192021222324252627282930/** * 自定义拦截器 * @author shengwu ni * @date 2018/08/03 */public class MyInterceptor implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); String methodName = method.getName(); logger.info("====拦截到了方法：&#123;&#125;，在该方法执行之前执行====", methodName); // 返回true才会继续执行，返回false则取消当前请求 return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; logger.info("执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; logger.info("整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了"); &#125;&#125; OK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。 1.2 配置拦截器在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 addInterceptors 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下： 123456789@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurationSupport &#123; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**"); super.addInterceptors(registry); &#125;&#125; 在该配置中重写 addInterceptors 方法，将我们上面自定义的拦截器添加进去，addPathPatterns 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下： 123456789@Controller@RequestMapping("/interceptor")public class InterceptorController &#123; @RequestMapping("/test") public String test() &#123; return "hello"; &#125;&#125; 让其跳转到 hello.html 页面，直接在 hello.html 中输出 hello interceptor 即可。启动项目，在浏览器中输入 localhost:8080/interceptor/test 看一下控制台的日志： 123====拦截到了方法：test，在该方法执行之前执行==== 执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染 整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了 可以看出拦截器已经生效，并能看出其执行顺序。 1.3 解决静态资源被拦截问题上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。 也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。 如何放开呢？除了在 MyInterceptorConfig 配置类中重写 addInterceptors 方法外，还需要再重写一个方法：addResourceHandlers，将静态资源放开： 123456789/** * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问 * @param registry */@Overrideprotected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/**").addResourceLocations("classpath:/static/"); super.addResourceHandlers(registry);&#125; 这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。 我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 addInterceptors 方法，将自定义的拦截器添加进去即可，如下： 12345678@Configurationpublic class MyInterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 实现WebMvcConfigurer不会导致静态资源被拦截 registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**"); &#125;&#125; 这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。 这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。 2. 拦截器使用实例2.1 判断用户有没有登录一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 preHandle 方法，如下： 123456789101112131415161718@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); String methodName = method.getName(); logger.info("====拦截到了方法：&#123;&#125;，在该方法执行之前执行====", methodName); // 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token String token = request.getParameter("token"); if (null == token || "".equals(token)) &#123; logger.info("用户未登录，没有权限执行……请登录"); return false; &#125; // 返回true才会继续执行，返回false则取消当前请求 return true;&#125; 重启项目，在浏览器中输入 localhost:8080/interceptor/test 后查看控制台日志，发现被拦截，如果在浏览器中输入 localhost:8080/interceptor/test?token=123 即可正常往下走。 2.2 取消拦截操作根据上文，如果我要拦截所有 /admin 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 /admin 开头的，但是不能拦截，比如 /admin/login 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？ 是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解： 1234567/** * 该注解用来指定某个方法不用拦截 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UnInterception &#123;&#125; 然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下： 1234567891011121314151617@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); String methodName = method.getName(); logger.info("====拦截到了方法：&#123;&#125;，在该方法执行之前执行====", methodName); // 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截 // @UnInterception 是我们自定义的注解 UnInterception unInterception = method.getAnnotation(UnInterception.class); if (null != unInterception) &#123; return true; &#125; // 返回true才会继续执行，返回false则取消当前请求 return true;&#125; Controller 中的方法代码可以参见源码，重启项目在浏览器中输入 http://localhost:8080/interceptor/test2?token=123 测试一下，可以看出，加了该注解的方法不会被拦截。 3. 总结本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第14课：Spring Boot 中集成Redis1. Redis 介绍Redis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。NoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。Redis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图： Redis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。 2. Redis 安装本课程是在 vmvare 虚拟机中来安装的 redis （centos 7），学习的时候如果有自己的阿里云服务器，也可以在阿里云中来安装 redis，都可以。只要能 ping 的通云主机或者虚拟机的 ip，然后在虚拟机或者云主机中放行对应的端口（或者关掉防火墙）即可访问 redis。下面来介绍一下 redis 的安装过程： 安装 gcc 编译 因为后面安装redis的时候需要编译，所以事先得先安装gcc编译。阿里云主机已经默认安装了 gcc，如果是自己安装的虚拟机，那么需要先安装一下 gcc： 1yum install gcc-c++ 下载 redis 有两种方式下载安装包，一种是去官网上下载（https://redis.io），然后将安装包考到 centos 中，另种方法是直接使用 wget 来下载： 1wget http://download.redis.io/releases/redis-3.2.8.tar.gz 如果没有安装过 wget，可以通过如下命令安装： 1yum install wget 解压安装 解压安装包： 1tar –vzxf redis-3.2.8.tar.gz 然后将解压的文件夹 redis-3.2.8 放到 /usr/local/ 下，一般安装软件都放在 /usr/local 下。然后进入 /usr/local/redis-3.2.8/ 文件夹下，执行 make 命令即可完成安装。【注】如果 make 失败，可以尝试如下命令： 12make MALLOC=libcmake install 修改配置文件 安装成功之后，需要修改一下配置文件，包括允许接入的 ip，允许后台执行，设置密码等等。打开 redis 配置文件：vi redis.conf在命令模式下输入 /bind 来查找 bind 配置，按 n 来查找下一个，找到配置后，将 bind 配置成 0.0.0.0，允许任意服务器来访问 redis，即： 1bind 0.0.0.0 使用同样的方法，将 daemonize 改成 yes （默认为 no），允许 redis 在后台执行。将 requirepass 注释打开，并设置密码为 123456（密码自己设置）。 启动 redis 在 redis-3.2.8 目录下，指定刚刚修改好的配置文件 redis.conf 来启动 redis： 1redis-server ./redis.conf 再启动 redis 客户端： 1redis-cli 由于我们设置了密码，在启动客户端之后，输入 auth 123456 即可登录进入客户端。然后我们来测试一下，往 redis 中插入一个数据： 1set name CSDN 然后来获取 name 1get name 如果正常获取到 CSDN，则说明没有问题。 3. Spring Boot 集成 Redis3.1 依赖导入Spring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--阿里巴巴fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt;&lt;/dependency&gt; 这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。 3.2 Redis 配置导入了依赖之后，我们在 application.yml 文件里配置 redis： 123456789101112131415161718192021server: port: 8080spring: #redis相关配置 redis: database: 5 # 配置redis的主机地址，需要修改成自己的 host: 192.168.48.190 port: 6379 password: 123456 timeout: 5000 jedis: pool: # 连接池中的最大空闲连接，默认值也是8。 max-idle: 500 # 连接池中的最小空闲连接，默认值也是0。 min-idle: 50 # 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽) max-active: 1000 # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException max-wait: 2000 3.3 常用 api 介绍Spring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。 有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。 3.3.1 redis:string 类型新建一个 RedisService，注入 StringRedisTemplate，使用 stringRedisTemplate.opsForValue() 可以获取 ValueOperations&lt;String, String&gt; 对象，通过该对象即可读写 redis 数据库了。如下： 1234567891011121314151617181920212223public class RedisService &#123; @Resource private StringRedisTemplate stringRedisTemplate; /** * set redis: string类型 * @param key key * @param value value */ public void setString(String key, String value)&#123; ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue(); valueOperations.set(key, value); &#125; /** * get redis: string类型 * @param key key * @return */ public String getString(String key)&#123; return stringRedisTemplate.opsForValue().get(key); &#125; 该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下： 123456789101112131415161718192021@RunWith(SpringRunner.class)@SpringBootTestpublic class Course14ApplicationTests &#123; private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class); @Resource private RedisService redisService; @Test public void contextLoads() &#123; //测试redis的string类型 redisService.setString("weichat","程序员私房菜"); logger.info("我的微信公众号为：&#123;&#125;", redisService.getString("weichat")); // 如果是个实体，我们可以使用json工具转成json字符串， User user = new User("CSDN", "123456"); redisService.setString("userInfo", JSON.toJSONString(user)); logger.info("用户信息：&#123;&#125;", redisService.getString("userInfo")); &#125;&#125; 先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下： 12我的微信公众号为：程序员私房菜用户信息：&#123;&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;CSDN&quot;&#125; 3.3.2 redis:hash 类型hash 类型其实原理和 string 一样的，但是有两个 key，使用 stringRedisTemplate.opsForHash() 可以获取 HashOperations&lt;String, Object, Object&gt; 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。 123456789101112131415161718192021222324252627@Servicepublic class RedisService &#123; @Resource private StringRedisTemplate stringRedisTemplate; /** * set redis: hash类型 * @param key key * @param filedKey filedkey * @param value value */ public void setHash(String key, String filedKey, String value)&#123; HashOperations&lt;String, Object, Object&gt; hashOperations = stringRedisTemplate.opsForHash(); hashOperations.put(key,filedKey, value); &#125; /** * get redis: hash类型 * @param key key * @param filedkey filedkey * @return */ public String getHash(String key, String filedkey)&#123; return (String) stringRedisTemplate.opsForHash().get(key, filedkey); &#125;&#125; 可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下： 123456789101112131415@SpringBootTestpublic class Course14ApplicationTests &#123; private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class); @Resource private RedisService redisService; @Test public void contextLoads() &#123; //测试redis的hash类型 redisService.setHash("user", "name", JSON.toJSONString(user)); logger.info("用户姓名：&#123;&#125;", redisService.getHash("user","name")); &#125;&#125; 3.3.3 redis:list 类型使用 stringRedisTemplate.opsForList() 可以获取 ListOperations&lt;String, String&gt; listOperations redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。 12345678910111213141516171819202122232425262728@Servicepublic class RedisService &#123; @Resource private StringRedisTemplate stringRedisTemplate; /** * set redis:list类型 * @param key key * @param value value * @return */ public long setList(String key, String value)&#123; ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList(); return listOperations.leftPush(key, value); &#125; /** * get redis:list类型 * @param key key * @param start start * @param end end * @return */ public List&lt;String&gt; getList(String key, long start, long end)&#123; return stringRedisTemplate.opsForList().range(key, start, end); &#125;&#125; 可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下： 1234567891011121314151617181920@RunWith(SpringRunner.class)@SpringBootTestpublic class Course14ApplicationTests &#123; private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class); @Resource private RedisService redisService; @Test public void contextLoads() &#123; //测试redis的list类型 redisService.setList("list", "football"); redisService.setList("list", "basketball"); List&lt;String&gt; valList = redisService.getList("list",0,-1); for(String value :valList)&#123; logger.info("list中有：&#123;&#125;", value); &#125; &#125;&#125; 4. 总结本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第15课： Spring Boot中集成ActiveMQ1. JMS 和 ActiveMQ 介绍1.1 JMS 是啥百度百科的解释： JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。 JMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型： 连接工厂：ConnectionFactoryJMS连接：ConnectionJMS会话：SessionJMS目的：DestinationJMS生产者：ProducerJMS消费者：ConsumerJMS消息两种类型：点对点和发布/订阅。 可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。 1.2 ActiveMQActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。 异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。 2. ActiveMQ安装使用 ActiveMQ 首先需要去官网下载，官网地址为：http://activemq.apache.org/本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3 的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个 activemq-all-5.15.3.jar，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。 在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64 两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费启动完成后，在浏览器中输入 http://127.0.0.1:8161/admin/ 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下： 我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？ 点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。 发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。 3. ActiveMQ集成3.1 依赖导入和配置在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; 然后在 application.yml 配置文件中，对 activemq 做一下配置： 12345678spring: activemq: # activemq url broker-url: tcp://localhost:61616 in-memory: true pool: # 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate enabled: false 3.2 Queue 和 Topic 的创建首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下： 12345678910111213141516171819202122232425/** * activemq的配置 * @author shengwu ni */@Configurationpublic class ActiveMqConfig &#123; /** * 发布/订阅模式队列名称 */ public static final String TOPIC_NAME = "activemq.topic"; /** * 点对点模式队列名称 */ public static final String QUEUE_NAME = "activemq.queue"; @Bean public Destination topic() &#123; return new ActiveMQTopic(TOPIC_NAME); &#125; @Bean public Destination queue() &#123; return new ActiveMQQueue(QUEUE_NAME); &#125;&#125; 可以看出创建 Queue 和 Topic 两种消息，分别使用 new ActiveMQQueue 和 new ActiveMQTopic 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。 3.3 消息的发送接口在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下： 1234567891011121314/** * 消息发送者 * @author shengwu ni */@Servicepublic class MsgProducer &#123; @Resource private JmsMessagingTemplate jmsMessagingTemplate; public void sendMessage(Destination destination, String msg) &#123; jmsMessagingTemplate.convertAndSend(destination, msg); &#125;&#125; convertAndSend 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。 3.4 点对点消息生产与消费3.4.1 点对点消息的生产消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在 Controller 中我们直接注入进来即可。然后调用上文的消息发送方法 sendMessage 即可成功生产一条消息。 1234567891011121314151617181920212223/** * ActiveMQ controller * @author shengwu ni */@RestController@RequestMapping("/activemq")public class ActiveMqController &#123; private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class); @Resource private MsgProducer producer; @Resource private Destination queue; @GetMapping("/send/queue") public String sendQueueMessage() &#123; logger.info("===开始发送点对点消息==="); producer.sendMessage(queue, "Queue: hello activemq!"); return "success"; &#125;&#125; 3.4.2 点对点消息的消费点对点消息的消费很简单，只要我们指定目的地即可，jms 监听器一直在监听是否有消息过来，如果有，则消费。 12345678910111213141516/** * 消息消费者 * @author shengwu ni */@Servicepublic class QueueConsumer &#123; /** * 接收点对点消息 * @param msg */ @JmsListener(destination = ActiveMqConfig.QUEUE_NAME) public void receiveQueueMsg(String msg) &#123; System.out.println("收到的消息为：" + msg); &#125;&#125; 可以看出，使用 @JmsListener 注解来指定要监听的目的地，在消息接收方法内部，我们可以根据具体的业务需求做相应的逻辑处理即可。 3.4.3 测试一下启动项目，在浏览器中输入：http://localhost:8081/activemq/send/queue，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。 1收到的消息为：Queue: hello activemq! 3.5 发布/订阅消息的生产和消费3.5.1 发布/订阅消息的生产和点对点消息一样，我们注入 topic 并调用 producer 的 sendMessage 方法即可发送订阅消息，如下，不再赘述： 12345678910111213141516171819@RestController@RequestMapping("/activemq")public class ActiveMqController &#123; private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class); @Resource private MsgProducer producer; @Resource private Destination topic; @GetMapping("/send/topic") public String sendTopicMessage() &#123; logger.info("===开始发送订阅消息==="); producer.sendMessage(topic, "Topic: hello activemq!"); return "success"; &#125;&#125; 3.5.2 发布/订阅消息的消费发布/订阅消息的消费和点对点不同，订阅消息支持多个消费者一起消费。其次，Spring Boot 中默认的时点对点消息，所以在使用 topic 时，会不起作用，我们需要在配置文件 application.yml 中添加一个配置： 123spring: jms: pub-sub-domain: true 该配置是 false 的话，则为点对点消息，也是 Spring Boot 默认的。这样是可以解决问题，但是如果这样配置的话，上面提到的点对点消息又不能正常消费了。所以二者不可兼得，这并非一个好的解决办法。 比较好的解决办法是，我们定义一个工厂，@JmsListener 注解默认只接收 queue 消息，如果要接收 topic 消息，需要设置一下 containerFactory。我们还在上面的那个 ActiveMqConfig 配置类中添加： 123456789101112131415161718192021/** * activemq的配置 * * @author shengwu ni */@Configurationpublic class ActiveMqConfig &#123; // 省略其他内容 /** * JmsListener注解默认只接收queue消息,如果要接收topic消息,需要设置containerFactory */ @Bean public JmsListenerContainerFactory topicListenerContainer(ConnectionFactory connectionFactory) &#123; DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); // 相当于在application.yml中配置：spring.jms.pub-sub-domain=true factory.setPubSubDomain(true); return factory; &#125;&#125; 经过这样的配置之后，我们在消费的时候，在 @JmsListener 注解中指定这个容器工厂即可消费 topic 消息。如下： 1234567891011121314151617/** * Topic消息消费者 * @author shengwu ni */@Servicepublic class TopicConsumer1 &#123; /** * 接收订阅消息 * @param msg */ @JmsListener(destination = ActiveMqConfig.TOPIC_NAME, containerFactory = "topicListenerContainer") public void receiveTopicMsg(String msg) &#123; System.out.println("收到的消息为：" + msg); &#125;&#125; 指定 containerFactory 属性为上面我们自己配置的 topicListenerContainer 即可。由于 topic 消息可以多个消费，所以该消费的类可以拷贝几个一起测试一下，这里我就不贴代码了，可以参考我的源码测试。 3.5.3 测试一下启动项目，在浏览器中输入：http://localhost:8081/activemq/send/topic，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。 12收到的消息为：Topic: hello activemq!收到的消息为：Topic: hello activemq! 4. 总结本章主要介绍了 jms 和 activemq 的相关概念、activemq 的安装与启动。详细分析了 Spring Boot 中点对点消息和发布/订阅消息两种方式的配置、消息生产和消费方式。ActiveMQ 是能力强劲的开源消息总线，在异步消息的处理上很有用，希望大家好好消化一下。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第16课：Spring Boot中集成 ShiroShiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。 1. Shiro 三大核心组件Shiro 有三大核心的组件：Subject、SecurityManager 和 Realm。先来看一下它们之间的关系。 Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。 Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；Credentials：凭证。常见有密码，数字证书等等。 说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。 SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。 Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。 1. Shiro 身份和权限认证1.2 Shiro 身份认证我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图： Step1：应用程序代码在调用 Subject.login(token) 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。 Step2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。 Step3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。 1.3 Shiro 权限认证权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。 权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利；角色（role）：指的是用户担任的的角色，一个角色可以有多个权限；用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。 它们之间的的关系可以用下图来表示： 一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。 2. Spring Boot 集成 Shiro 过程2.1 依赖导入Spring Boot 2.0.3 集成 Shiro 需要导入如下 starter 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 2.2 数据库表数据初始化这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。 123456789101112131415161718192021222324CREATE TABLE `t_role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `rolename` varchar(20) DEFAULT NULL COMMENT '角色名称', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8CREATE TABLE `t_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户主键', `username` varchar(20) NOT NULL COMMENT '用户名', `password` varchar(20) NOT NULL COMMENT '密码', `role_id` int(11) DEFAULT NULL COMMENT '外键关联role表', PRIMARY KEY (`id`), KEY `role_id` (`role_id`), CONSTRAINT `t_user_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8CREATE TABLE `t_permission` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `permissionname` varchar(50) NOT NULL COMMENT '权限名', `role_id` int(11) DEFAULT NULL COMMENT '外键关联role', PRIMARY KEY (`id`), KEY `role_id` (`role_id`), CONSTRAINT `t_permission_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。t_user 表： id username password role_id 1 csdn1 123456 1 2 csdn2 123456 2 3 csdn3 123456 3 t_role 表： id rolename 1 admin 2 teacher 3 student t_permission 表： id permissionname role_id 1 user:* 1 2 student:* 2 解释一下这里的权限：user:*表示权限可以是 user:create 或者其他，* 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。 2.2 自定义 Realm有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法： doGetAuthenticationInfo() 方法：用来验证当前登录的用户，获取认证信息doGetAuthorizationInfo() 方法：用来为当前登陆成功的用户授予权限和角色 具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观： 1234567891011121314151617181920212223242526272829303132333435363738/** * 自定义realm * @author shengwu ni */public class MyRealm extends AuthorizingRealm &#123; @Resource private UserService userService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; // 获取用户名 String username = (String) principalCollection.getPrimaryPrincipal(); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); // 给该用户设置角色，角色信息存在t_role表中取 authorizationInfo.setRoles(userService.getRoles(username)); // 给该用户设置权限，权限信息存在t_permission表中取 authorizationInfo.setStringPermissions(userService.getPermissions(username)); return authorizationInfo; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; // 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释 String username = (String) authenticationToken.getPrincipal(); // 根据用户名从数据库中查询该用户 User user = userService.getByUsername(username); if(user != null) &#123; // 把当前用户存到session中 SecurityUtils.getSubject().getSession().setAttribute("user", user); // 传入用户名和密码进行身份认证，并返回认证信息 AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), "myRealm"); return authcInfo; &#125; else &#123; return null; &#125; &#125;&#125; 从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。 2.3 Shiro 配置自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下： 配置自定义 realm： 12345678910111213141516@Configurationpublic class ShiroConfig &#123; private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class); /** * 注入自定义的realm * @return MyRealm */ @Bean public MyRealm myAuthRealm() &#123; MyRealm myRealm = new MyRealm(); logger.info("====myRealm注册完成====="); return myRealm; &#125;&#125; 配置安全管理器 SecurityManager： 1234567891011121314151617@Configurationpublic class ShiroConfig &#123; private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class); /** * 注入安全管理器 * @return SecurityManager */ @Bean public SecurityManager securityManager() &#123; // 将自定义realm加进来 DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(myAuthRealm()); logger.info("====securityManager注册完成===="); return securityManager; &#125;&#125; 配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。 配置 Shiro 过滤器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Configurationpublic class ShiroConfig &#123; private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class); /** * 注入Shiro过滤器 * @param securityManager 安全管理器 * @return ShiroFilterFactoryBean */ @Bean public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) &#123; // 定义shiroFactoryBean ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); // 设置自定义的securityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置默认登录的url，身份认证失败会访问该url shiroFilterFactoryBean.setLoginUrl("/login"); // 设置成功之后要跳转的链接 shiroFilterFactoryBean.setSuccessUrl("/success"); // 设置未授权界面，权限认证失败会访问该url shiroFilterFactoryBean.setUnauthorizedUrl("/unauthorized"); // LinkedHashMap是有序的，进行顺序拦截器配置 Map&lt;String,String&gt; filterChainMap = new LinkedHashMap&lt;&gt;(); // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行 filterChainMap.put("/css/**", "anon"); filterChainMap.put("/imgs/**", "anon"); filterChainMap.put("/js/**", "anon"); filterChainMap.put("/swagger-*/**", "anon"); filterChainMap.put("/swagger-ui.html/**", "anon"); // 登录url 放行 filterChainMap.put("/login", "anon"); // “/user/admin” 开头的需要身份认证，authc表示要身份认证 filterChainMap.put("/user/admin*", "authc"); // “/user/student” 开头的需要角色认证，是“admin”才允许 filterChainMap.put("/user/student*/**", "roles[admin]"); // “/user/teacher” 开头的需要权限认证，是“user:create”才允许 filterChainMap.put("/user/teacher*/**", "perms[\"user:create\"]"); // 配置logout过滤器 filterChainMap.put("/logout", "logout"); // 设置shiroFilterFactoryBean的FilterChainDefinitionMap shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap); logger.info("====shiroFilterFactoryBean注册完成===="); return shiroFilterFactoryBean; &#125;&#125; 配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -&gt; SecurityManager -&gt; filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有： 默认登录的 url：身份认证失败会访问该 url认证成功之后要跳转的 url权限认证失败会访问该 url需要拦截或者放行的 url：这些都放在一个 map 中 从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。 Filter 说明 anon 开放权限，可以理解为匿名用户或游客，可以直接访问的 authc 需要身份认证的 logout 注销，执行后会直接跳转到 shiroFilterFactoryBean.setLoginUrl(); 设置的 url，即登录页面 roles[admin] 参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[“admin，user”]，当有多个参数时必须每个参数都通过才算通过 perms[user] 参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过 2.4 使用 Shiro 进行认证到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口： 接口一： 使用 http://localhost:8080/user/admin 来验证身份认证接口二： 使用 http://localhost:8080/user/student 来验证角色认证接口三： 使用 http://localhost:8080/user/teacher 来验证权限认证接口四： 使用 http://localhost:8080/user/login 来实现用户登录 然后来一下认证的流程： 流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。流程三： 访问接口二，测试角色认证是否成功。流程四： 访问接口三，测试权限认证是否成功。 2.4.1 身份、角色、权限认证接口1234567891011121314151617181920212223242526272829303132333435@Controller@RequestMapping("/user")public class UserController &#123; /** * 身份认证测试接口 * @param request * @return */ @RequestMapping("/admin") public String admin(HttpServletRequest request) &#123; Object user = request.getSession().getAttribute("user"); return "success"; &#125; /** * 角色认证测试接口 * @param request * @return */ @RequestMapping("/student") public String student(HttpServletRequest request) &#123; return "success"; &#125; /** * 权限认证测试接口 * @param request * @return */ @RequestMapping("/teacher") public String teacher(HttpServletRequest request) &#123; return "success"; &#125;&#125; 这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。 2.4.2 用户登录接口123456789101112131415161718192021222324252627282930@Controller@RequestMapping("/user")public class UserController &#123; /** * 用户登录接口 * @param user user * @param request request * @return string */ @PostMapping("/login") public String login(User user, HttpServletRequest request) &#123; // 根据用户名和密码创建token UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword()); // 获取subject认证主体 Subject subject = SecurityUtils.getSubject(); try&#123; // 开始认证，这一步会跳到我们自定义的realm中 subject.login(token); request.getSession().setAttribute("user", user); return "success"; &#125;catch(Exception e)&#123; e.printStackTrace(); request.getSession().setAttribute("user", user); request.setAttribute("error", "用户名或密码错误！"); return "login"; &#125; &#125;&#125; 我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 subject.login(token) 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 doGetAuthenticationInfo 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。 2.4.3 测试一下最后，启动项目，测试一下：浏览器请求 http://localhost:8080/user/admin 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 /login 接口，然后跳转到 login.html 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 http://localhost:8080/user/student 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 http://localhost:8080/user/teacher 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 user:*，满足配置中的 user:create，所以认证通过。 接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。 3. 总结本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第17课：Spring Boot中集成Lucence1. Lucence 和全文检索Lucene 是什么？看一下百度百科： Lucene是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。——《百度百科》 1.1 全文检索这里提到了全文检索的概念，我们先来分析一下什么是全文检索，理解了全文检索之后，再理解 Lucene 的原理就非常简单了。 何为全文检索？举个例子，比如现在要在一个文件中查找某个字符串，最直接的想法就是从头开始检索，查到了就OK，这种对于小数据量的文件来说，很实用，但是对于大数据量的文件来说，就有点吃力了。或者说找包含某个字符串的文件，也是这样，如果在一个拥有几十个 G 的硬盘中找那效率可想而知，是很低的。 文件中的数据是属于非结构化数据，也就是说它没有什么结构可言，要解决上面提到的效率问题，首先我们得将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这就叫全文搜索。即先建立索引，再对索引进行搜索的过程。 1.2 Lucene 建立索引的方式那么 Lucene 中是如何建立索引的呢？假设现在有两篇文章，内容如下： 文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.文章2的内容为：He once lived in Shanghai. 首先第一步是将文档传给分词组件（Tokenizer），分词组件会将文档分成一个个单词，并去除标点符号和停词。所谓的停词指的是没有特别意义的词，比如英文中的 a，the，too 等。经过分词后，得到词元（Token） 。如下： 文章1经过分词后的结果：[Tom] [lives] [Guangzhou] [I] [live] [Guangzhou]文章2经过分词后的结果：[He] [lives] [Shanghai] 然后将词元传给语言处理组件（Linguistic Processor），对于英语，语言处理组件一般会将字母变为小写，将单词缩减为词根形式，如 ”lives” 到 ”live” 等，将单词转变为词根形式，如 ”drove” 到 ”drive” 等。然后得到词（Term）。如下： 文章1经过处理后的结果：[tom] [live] [guangzhou] [i] [live] [guangzhou]文章2经过处理后的结果：[he] [live] [shanghai] 最后将得到的词传给索引组件（Indexer），索引组件经过处理，得到下面的索引结构： 关键词 文章号[出现频率] 出现位置 guangzhou 1[2] 3,6 he 2[1] 1 i 1[1] 4 live 1[2],2[1] 2,5,2 shanghai 2[1] 3 tom 1[1] 1 以上就是Lucene 索引结构中最核心的部分。它的关键字是按字符顺序排列的，因此 Lucene 可以用二元搜索算法快速定位关键词。实现时 Lucene 将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）和位置文件（positions）保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。搜索的过程是先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果，然后就可以在具体的文章中根据出现位置找到该词了。所以 Lucene 在第一次建立索引的时候可能会比较慢，但是以后就不需要每次都建立索引了，就快了。 理解了 Lucene 的分词原理，接下来我们在 Spring Boot 中集成 Lucene 并实现索引和搜索的功能。 2. Spring Boot 中集成 Lucence2.1 依赖导入首先需要导入 Lucene 的依赖，它的依赖有好几个，如下： 12345678910111213141516171819202122232425262728293031323334&lt;!-- Lucence核心包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Lucene查询解析包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 常规的分词（英文） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--支持分词高亮 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-highlighter&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--支持中文分词 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-smartcn&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt; 最后一个依赖是用来支持中文分词的，因为默认是支持英文的。那个高亮的分词依赖是最后我要做一个搜索，然后将搜到的内容高亮显示，模拟当前互联网上的做法，大家可以运用到实际项目中去。 2.2 快速入门根据上文的分析，全文检索有两个步骤，先建立索引，再检索。所以为了测试这个过程，我新建两个 java 类，一个用来建立索引的，另一个用来检索。 2.2.1 建立索引我们自己弄几个文件，放到 D:\lucene\data 目录下，新建一个 Indexer 类来实现建立索引功能。首先在构造方法中初始化标准分词器和写索引实例。 12345678910111213141516171819202122public class Indexer &#123; /** * 写索引实例 */ private IndexWriter writer; /** * 构造方法，实例化IndexWriter * @param indexDir * @throws Exception */ public Indexer(String indexDir) throws Exception &#123; Directory dir = FSDirectory.open(Paths.get(indexDir)); //标准分词器，会自动去掉空格啊，is a the等单词 Analyzer analyzer = new StandardAnalyzer(); //将标准分词器配到写索引的配置中 IndexWriterConfig config = new IndexWriterConfig(analyzer); //实例化写索引对象 writer = new IndexWriter(dir, config); &#125;&#125; 在构造放发中传一个存放索引的文件夹路径，然后构建标准分词器（这是英文的），再使用标准分词器来实例化写索引对象。接下来就开始建立索引了，我将解释放到代码注释里，方便大家跟进。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 索引指定目录下的所有文件 * @param dataDir * @return * @throws Exception */public int indexAll(String dataDir) throws Exception &#123; // 获取该路径下的所有文件 File[] files = new File(dataDir).listFiles(); if (null != files) &#123; for (File file : files) &#123; //调用下面的indexFile方法，对每个文件进行索引 indexFile(file); &#125; &#125; //返回索引的文件数 return writer.numDocs();&#125;/** * 索引指定的文件 * @param file * @throws Exception */private void indexFile(File file) throws Exception &#123; System.out.println("索引文件的路径：" + file.getCanonicalPath()); //调用下面的getDocument方法，获取该文件的document Document doc = getDocument(file); //将doc添加到索引中 writer.addDocument(doc);&#125;/** * 获取文档，文档里再设置每个字段，就类似于数据库中的一行记录 * @param file * @return * @throws Exception */private Document getDocument(File file) throws Exception &#123; Document doc = new Document(); //开始添加字段 //添加内容 doc.add(new TextField("contents", new FileReader(file))); //添加文件名，并把这个字段存到索引文件里 doc.add(new TextField("fileName", file.getName(), Field.Store.YES)); //添加文件路径 doc.add(new TextField("fullPath", file.getCanonicalPath(), Field.Store.YES)); return doc;&#125; 这样就建立好索引了，我们在该类中写一个 main 方法测试一下： 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; //索引保存到的路径 String indexDir = "D:\\lucene"; //需要索引的文件数据存放的目录 String dataDir = "D:\\lucene\\data"; Indexer indexer = null; int indexedNum = 0; //记录索引开始时间 long startTime = System.currentTimeMillis(); try &#123; // 开始构建索引 indexer = new Indexer(indexDir); indexedNum = indexer.indexAll(dataDir); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != indexer) &#123; indexer.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //记录索引结束时间 long endTime = System.currentTimeMillis(); System.out.println("索引耗时" + (endTime - startTime) + "毫秒"); System.out.println("共索引了" + indexedNum + "个文件"); &#125; 我搞了两个 tomcat 相关的文件放到 D:\lucene\data 下了，执行完之后，看到控制台输出： 1234索引文件的路径：D:\lucene\data\catalina.properties索引文件的路径：D:\lucene\data\logging.properties索引耗时882毫秒共索引了2个文件 然后我们去 D:\lucene\ 目录下可以看到一些索引文件，这些文件不能删除，删除了就需要重新构建索引，否则没了索引，就无法去检索内容了。 ####2.2.2 检索内容 上面把这两个文件的索引建立好了，接下来我们就可以写检索程序了，在这两个文件中查找特定的词。 1234567891011121314151617181920212223242526272829303132333435public class Searcher &#123; public static void search(String indexDir, String q) throws Exception &#123; //获取要查询的路径，也就是索引所在的位置 Directory dir = FSDirectory.open(Paths.get(indexDir)); IndexReader reader = DirectoryReader.open(dir); //构建IndexSearcher IndexSearcher searcher = new IndexSearcher(reader); //标准分词器，会自动去掉空格啊，is a the等单词 Analyzer analyzer = new StandardAnalyzer(); //查询解析器 QueryParser parser = new QueryParser("contents", analyzer); //通过解析要查询的String，获取查询对象，q为传进来的待查的字符串 Query query = parser.parse(q); //记录索引开始时间 long startTime = System.currentTimeMillis(); //开始查询，查询前10条数据，将记录保存在docs中 TopDocs docs = searcher.search(query, 10); //记录索引结束时间 long endTime = System.currentTimeMillis(); System.out.println("匹配" + q + "共耗时" + (endTime-startTime) + "毫秒"); System.out.println("查询到" + docs.totalHits + "条记录"); //取出每条查询结果 for(ScoreDoc scoreDoc : docs.scoreDocs) &#123; //scoreDoc.doc相当于docID,根据这个docID来获取文档 Document doc = searcher.doc(scoreDoc.doc); //fullPath是刚刚建立索引的时候我们定义的一个字段，表示路径。也可以取其他的内容，只要我们在建立索引时有定义即可。 System.out.println(doc.get("fullPath")); &#125; reader.close(); &#125;&#125; ok，这样我们检索的代码就写完了，每一步解释我写在代码中的注释上了，下面写个 main 方法来测试一下： 12345678910public static void main(String[] args) &#123; String indexDir = "D:\\lucene"; //查询这个字符串 String q = "security"; try &#123; search(indexDir, q); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 查一下 security 这个字符串，执行一下看控制台打印的结果： 123匹配security共耗时23毫秒查询到1条记录D:\lucene\data\catalina.properties 可以看出，耗时了23毫秒在两个文件中找到了 security 这个字符串，并输出了文件的名称。上面的代码我写的很详细，这个代码已经比较全了，可以用在生产环境上。 2.3 中文分词检索高亮实战上文已经写了建立索引和检索的代码，但是在实际项目中，我们往往是结合页面做一些查询结果的展示，比如我要查某个关键字，查到了之后，将相关的信息点展示出来，并将查询的关键字高亮等等。这种需求在实际项目中非常常见，而且大多数网站中都会有这种效果。所以这一小节我们就使用 Lucene 来实现这种效果。 2.3.1 中文分词我们新建一个 ChineseIndexer 类来建立中文索引，建立过程和英文索引一样的，不同的地方在于使用的是中文分词器。除此之外，这里我们不用通过读取文件去建立索引，我们模拟一下用字符串来建立，因为在实际项目中，绝大部分情况是获取到一些文本字符串，然后根据一些关键字去查询相关内容等等。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ChineseIndexer &#123; /** * 存放索引的位置 */ private Directory dir; //准备一下用来测试的数据 //用来标识文档 private Integer ids[] = &#123;1, 2, 3&#125;; private String citys[] = &#123;"上海", "南京", "青岛"&#125;; private String descs[] = &#123; "上海是个繁华的城市。", "南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，自古以来就是一座崇文重教的城市，有“天下文枢”、“东南第一学”的美誉。截至2013年，南京有高等院校75所，其中211高校8所，仅次于北京上海；国家重点实验室25所、国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。", "青岛是一个美丽的城市。" &#125;; /** * 生成索引 * @param indexDir * @throws Exception */ public void index(String indexDir) throws Exception &#123; dir = FSDirectory.open(Paths.get(indexDir)); // 先调用 getWriter 获取IndexWriter对象 IndexWriter writer = getWriter(); for(int i = 0; i &lt; ids.length; i++) &#123; Document doc = new Document(); // 把上面的数据都生成索引，分别用id、city和desc来标识 doc.add(new IntField("id", ids[i], Field.Store.YES)); doc.add(new StringField("city", citys[i], Field.Store.YES)); doc.add(new TextField("desc", descs[i], Field.Store.YES)); //添加文档 writer.addDocument(doc); &#125; //close了才真正写到文档中 writer.close(); &#125; /** * 获取IndexWriter实例 * @return * @throws Exception */ private IndexWriter getWriter() throws Exception &#123; //使用中文分词器 SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer(); //将中文分词器配到写索引的配置中 IndexWriterConfig config = new IndexWriterConfig(analyzer); //实例化写索引对象 IndexWriter writer = new IndexWriter(dir, config); return writer; &#125; public static void main(String[] args) throws Exception &#123; new ChineseIndexer().index("D:\\lucene2"); &#125;&#125; 这里我们用 id、city、desc 分别代表 id、城市名称和城市描述，用他们作为关键字来建立索引，后面我们获取内容的时候，主要来获取城市描述。南京的描述我故意写的长一点，因为下文检索的时候，根据不同的关键字会检索到不同部分的信息，有个权重的概念在里面。然后执行一下 main 方法，将索引保存到 D:\lucene2\ 中。 2.3.2 中文分词查询中文分词查询代码逻辑和默认的查询差不多，有一些区别在于，我们需要将查询出来的关键字标红加粗等需要处理，需要计算出一个得分片段，这是什么意思呢？比如我搜索 “南京文化” 跟搜索 “南京文明”，这两个搜索结果应该根据关键字出现的位置，返回的结果不一样才对，这在下文会测试。我们先看一下代码和注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ChineseSearch &#123; private static final Logger logger = LoggerFactory.getLogger(ChineseSearch.class); public static List&lt;String&gt; search(String indexDir, String q) throws Exception &#123; //获取要查询的路径，也就是索引所在的位置 Directory dir = FSDirectory.open(Paths.get(indexDir)); IndexReader reader = DirectoryReader.open(dir); IndexSearcher searcher = new IndexSearcher(reader); //使用中文分词器 SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer(); //由中文分词器初始化查询解析器 QueryParser parser = new QueryParser("desc", analyzer); //通过解析要查询的String，获取查询对象 Query query = parser.parse(q); //记录索引开始时间 long startTime = System.currentTimeMillis(); //开始查询，查询前10条数据，将记录保存在docs中 TopDocs docs = searcher.search(query, 10); //记录索引结束时间 long endTime = System.currentTimeMillis(); logger.info("匹配&#123;&#125;共耗时&#123;&#125;毫秒", q, (endTime - startTime)); logger.info("查询到&#123;&#125;条记录", docs.totalHits); //如果不指定参数的话，默认是加粗，即&lt;b&gt;&lt;b/&gt; SimpleHTMLFormatter simpleHTMLFormatter = new SimpleHTMLFormatter("&lt;b&gt;&lt;font color=red&gt;","&lt;/font&gt;&lt;/b&gt;"); //根据查询对象计算得分，会初始化一个查询结果最高的得分 QueryScorer scorer = new QueryScorer(query); //根据这个得分计算出一个片段 Fragmenter fragmenter = new SimpleSpanFragmenter(scorer); //将这个片段中的关键字用上面初始化好的高亮格式高亮 Highlighter highlighter = new Highlighter(simpleHTMLFormatter, scorer); //设置一下要显示的片段 highlighter.setTextFragmenter(fragmenter); //取出每条查询结果 List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(ScoreDoc scoreDoc : docs.scoreDocs) &#123; //scoreDoc.doc相当于docID,根据这个docID来获取文档 Document doc = searcher.doc(scoreDoc.doc); logger.info("city:&#123;&#125;", doc.get("city")); logger.info("desc:&#123;&#125;", doc.get("desc")); String desc = doc.get("desc"); //显示高亮 if(desc != null) &#123; TokenStream tokenStream = analyzer.tokenStream("desc", new StringReader(desc)); String summary = highlighter.getBestFragment(tokenStream, desc); logger.info("高亮后的desc:&#123;&#125;", summary); list.add(summary); &#125; &#125; reader.close(); return list; &#125;&#125; 每一步的注释我写的很详细，在这就不赘述了。接下来我们来测试一下效果。 2.3.3 测试一下这里我们使用 thymeleaf 来写个简单的页面来展示获取到的数据，并高亮展示。在 controller 中我们指定索引的目录和需要查询的字符串，如下： 1234567891011121314151617181920@Controller@RequestMapping("/lucene")public class IndexController &#123; @GetMapping("/test") public String test(Model model) &#123; // 索引所在的目录 String indexDir = "D:\\lucene2"; // 要查询的字符// String q = "南京文明"; String q = "南京文化"; try &#123; List&lt;String&gt; list = ChineseSearch.search(indexDir, q); model.addAttribute("list", list); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return "result"; &#125;&#125; 直接返回到 result.html 页面，该页面主要来展示一下 model 中的数据即可。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:each="desc : $&#123;list&#125;"&gt; &lt;div th:utext="$&#123;desc&#125;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里注意一下，不能使用 th:test，否则字符串中的 html 标签都会被转义，不会被渲染到页面。下面启动服务，在浏览器中输入 http://localhost:8080/lucene/test，测试一下效果，我们搜索的是 “南京文化”。 再将 controller 中的搜索关键字改成 “南京文明”，看下命中的效果。 可以看出，不同的关键词，它会计算一个得分片段，也就是说不同的关键字会命中不同位置的内容，然后将关键字根据我们自己设定的形式高亮显示。从结果中可以看出，Lucene 也可以很智能的将关键字拆分命中，这在实际项目中会很好用。 3. 总结本节课首先详细的分析了全文检索的理论规则，然后结合 Lucene，系统的讲述了在 Spring Boot 的集成步骤，首先快速带领大家从直观上感受 Lucene 如何建立索引已经如果检索，其次通过中文检索的具体实例，展示了 Lucene 在全文检索中的广泛应用。Lucene 不难，主要就是步骤比较多，代码不用死记硬背，拿到项目中根据实际情况做对应的修改即可。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第18课：Spring Boot搭建实际项目开发中的架构前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。 不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。 从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。 结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。 1. 统一的数据封装由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 统一返回对象 * @author shengwu ni * @param &lt;T&gt; */public class JsonResult&lt;T&gt; &#123; private T data; private String code; private String msg; /** * 若没有数据返回，默认状态码为0，提示信息为：操作成功！ */ public JsonResult() &#123; this.code = "0"; this.msg = "操作成功！"; &#125; /** * 若没有数据返回，可以人为指定状态码和提示信息 * @param code * @param msg */ public JsonResult(String code, String msg) &#123; this.code = code; this.msg = msg; &#125; /** * 有数据返回时，状态码为0，默认提示信息为：操作成功！ * @param data */ public JsonResult(T data) &#123; this.data = data; this.code = "0"; this.msg = "操作成功！"; &#125; /** * 有数据返回，状态码为0，人为指定提示信息 * @param data * @param msg */ public JsonResult(T data, String msg) &#123; this.data = data; this.code = "0"; this.msg = msg; &#125; /** * 使用自定义异常作为参数传递状态码和提示信息 * @param msgEnum */ public JsonResult(BusinessMsgEnum msgEnum) &#123; this.code = msgEnum.code(); this.msg = msgEnum.msg(); &#125; // 省去get和set方法&#125; 大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。 2. json的处理Json 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。 1234567891011121314151617181920/** * jacksonConfig * @author shengwu ni */@Configurationpublic class JacksonConfig &#123; @Bean @Primary @ConditionalOnMissingBean(ObjectMapper.class) public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) &#123; ObjectMapper objectMapper = builder.createXmlMapper(false).build(); objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() &#123; @Override public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123; jsonGenerator.writeString(""); &#125; &#125;); return objectMapper; &#125;&#125; 这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。 3. swagger2在线可调式接口有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置： 1234567891011121314151617181920212223242526272829303132333435363738/** * swagger配置 * @author shengwu ni */@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) // 指定构建api文档的详细信息的方法：apiInfo() .apiInfo(apiInfo()) .select() // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口 .apis(RequestHandlerSelectors.basePackage("com.itcodai.course18.controller")) .paths(PathSelectors.any()) .build(); &#125; /** * 构建api文档的详细信息 * @return */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() // 设置页面标题 .title("Spring Boot搭建实际项目中开发的架构") // 设置接口描述 .description("跟武哥一起学Spring Boot第18课") // 设置联系方式 .contact("倪升武，" + "微信公众号：程序员私房菜") // 设置版本 .version("1.0") // 构建 .build(); &#125;&#125; 到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。 1234567891011121314@RestController@Api(value = "用户信息接口")public class UserController &#123; @Resource private UserService userService; @GetMapping("/getUser/&#123;id&#125;") @ApiOperation(value = "根据用户唯一标识获取用户信息") public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = "用户唯一标识") Long id) &#123; User user = new User(id, "倪升武", "123456"); return new JsonResult&lt;&gt;(user); &#125;&#125; 然后启动项目，在浏览器中输入 localhost:8080/swagger-ui.html 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。 4. 持久层集成每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。 12345678910111213141516171819202122232425# 服务端口号server: port: 8080# 数据库地址datasource: url: localhost:3306/blog_testspring: datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://$&#123;datasource.url&#125;?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10 username: root password: 123456 hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000mybatis: # 指定别名设置的包为所有entity type-aliases-package: com.itcodai.course18.entity configuration: map-underscore-to-camel-case: true # 驼峰命名规范 mapper-locations: # mapper映射文件位置 - classpath:mapper/*.xml 配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。 123456789101112131415public interface UserMapper &#123; @Select("select * from user where id = #&#123;id&#125;") @Results(&#123; @Result(property = "username", column = "user_name"), @Result(property = "password", column = "password") &#125;) User getUser(Long id); @Select("select * from user where id = #&#123;id&#125; and user_name=#&#123;name&#125;") User getUserByIdAndName(@Param("id") Long id, @Param("name") String username); @Select("select * from user") List&lt;User&gt; getAll();&#125; 关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 @MapperScan(&quot;com.itcodai.course18.dao&quot;) 5. 拦截器拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。 123456789101112131415161718192021public class MyInterceptor implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.info("执行方法之前执行(Controller方法调用之前)"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; logger.info("执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; logger.info("整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了"); &#125;&#125; 然后将自定义的拦截器加入到拦截器配置中。 123456789101112@Configurationpublic class MyInterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 实现WebMvcConfigurer不会导致静态资源被拦截 registry.addInterceptor(new MyInterceptor()) // 拦截所有url .addPathPatterns("/**") // 放行swagger .excludePathPatterns("/swagger-resources/**"); &#125;&#125; 在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源： classpath:/staticclasspath:/publicclasspath:/resourcesclasspath:/META-INF/resources 上面代码中配置的 /** 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。 然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。 6. 全局异常处理全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下： 123456789101112131415161718192021222324252627282930313233public enum BusinessMsgEnum &#123; /** 参数异常 */ PARMETER_EXCEPTION("102", "参数异常!"), /** 等待超时 */ SERVICE_TIME_OUT("103", "服务调用超时！"), /** 参数过大 */ PARMETER_BIG_EXCEPTION("102", "输入的图片数量不能超过50张!"), /** 500 : 发生异常 */ UNEXPECTED_EXCEPTION("500", "系统发生异常，请联系管理员！"); /** * 消息码 */ private String code; /** * 消息内容 */ private String msg; private BusinessMsgEnum(String code, String msg) &#123; this.code = code; this.msg = msg; &#125; public String code() &#123; return code; &#125; public String msg() &#123; return msg; &#125;&#125; 在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 拦截业务异常，返回业务异常信息 * @param ex * @return */ @ExceptionHandler(BusinessErrorException.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleBusinessError(BusinessErrorException ex) &#123; String code = ex.getCode(); String message = ex.getMessage(); return new JsonResult(code, message); &#125; /** * 空指针异常 * @param ex NullPointerException * @return */ @ExceptionHandler(NullPointerException.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleTypeMismatchException(NullPointerException ex) &#123; logger.error("空指针异常，&#123;&#125;", ex.getMessage()); return new JsonResult("500", "空指针异常了"); &#125; /** * 系统异常 预期以外异常 * @param ex * @return */ @ExceptionHandler(Exception.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleUnexpectedServer(Exception ex) &#123; logger.error("系统异常：", ex); return new JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION); &#125;&#125; 其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。 7. 总结本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。 课程源代码下载地址：戳我下载 12 12]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot笔记]]></title>
    <url>%2F2019%2F12%2F23%2FSpringboot%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Spring Boot特性1.能够快速创建基于Spring的应用程序；2.能够直接使用java main方法启动内嵌的Tomcat,Jetty服务器运行Spring boot程序，不需要部署war包文件；3.提供约定的starter POM来简化Maven配置，让Maven的配置变得简单；4.根据项目的Maven依赖配置，Spring boot自动配置Spring,Spring mvc等；5.提供了程序的健康等功能；6.基本可以完全不使用XML配置文件，采用注解配置。 Spring Boot四大核心1.自动配置：针对很多Spring应用程序和常见的应用功能，Spring boot能自动提供相关配置；：2.起步依赖：告诉Spring boot需要什么功能,它就能引入需要的依赖库；3.Actuator:让你能够深入运行中的Spring Boot应用程序，一探Spring boot程序的内部信息；4.命令行界面:这是Spring Boot的可选特性，主要针对Groovy语言使用。 Spring boot下的Spring MVC下的注解@Controller 被Controller注解的类将会是一个控制器类，即MVC中的C的角色 它不需要继承其它的类，也不需要实现接口 它也不用@Component来注解，但也会被@ComponentScan扫描到，并会被作为Spring的bean置于容器中进行管理 处理http请求 @RestController 它本质上是一个组合注解，即@Controller+@ResponseBody的组合 默认情况下，它注解的每一个控制器方法都等于使用了@ResponseBody注解，也就是说，方法的返回值被写到响应体中 用于返回字符串或json数据 方法的返回值将被写入到HTTP的响应体中，这些内容 不放到模型中 不会解释为视图名 @RequestMapping 可以注解类或是方法 用于映射请求与处理方法 即URL和对应的方法 path与value互为别名，用于配置URI method为映射的请求配置参数标识 consumes为配置请求的数据类型，如JSON produces为配置响应的数据类型，如application/json 类似的几个注解 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文正则表达式匹配-正则中文匹配&&日语韩语等常用正则表达式]]></title>
    <url>%2F2019%2F12%2F03%2F%E4%B8%AD%E6%96%87%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-%E6%AD%A3%E5%88%99%E4%B8%AD%E6%96%87%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[正则表达式 判断是否是中文（一）字母、数字、下划线、汉字正则表达式 只有字母、数字和下划线且不能以下划线开头和结尾的正则表达式：^(?!)(?!.*?$)[a-zA-Z0-9_]+$ 只有字母和数字的： ^[a-zA-Z0-9_]+$ 至少一个汉字、数字、字母、下划线: “[a-zA-Z0-9_\u4e00-\u9fa5]+” 至少一个汉字的正则表达式：”^[\u4e00-\u9fa5]” 最多10个汉字: ValidationExpression=”^[\u4e00-\u9fa5]{0,10}” 只含有汉字、数字、字母、下划线不能以下划线开头和结尾：^(?!)(?!.*?$)[a-zA-Z0-9_\u4e00-\u9fa5]+$ 解释： ^ 与字符串开始的地方匹配 (?!_) 不能以_开头 (?!.*?_$) 不能以_结尾 [a-zA-Z0-9_\u4e00-\u9fa5]+ 至少一个汉字、数字、字母、下划线 $ 与字符串结束的地方匹配 6.一个正则表达式，只含有汉字、数字、字母、下划线不能以下划线开头和结尾： ^(?!)(?!.*?$)[a-zA-Z0-9_\u4e00-\u9fa5]+$ 解释： ^ 与字符串开始的地方匹配 (?!) 不能以开头 (?!.*?$) 不能以结尾 [a-zA-Z0-9_\u4e00-\u9fa5]+ 至少一个汉字、数字、字母、下划线 $ 与字符串结束的地方匹配 放在程序里前面加@，否则需要\进行转义 @”^(?!)(?!.*?$)[a-zA-Z0-9_\u4e00-\u9fa5]+$” （或者：@”^(?!)\w*(?&lt;!)$” 或者 @” ^[\u4E00-\u9FA50-9a-zA-Z_]+$ “ ) 7、只含有汉字、数字、字母、下划线，下划线位置不限： ^[a-zA-Z0-9_\u4e00-\u9fa5]+$ 8、由数字、26个英文字母或者下划线组成的字符串 ^\w+$ 9、2~4个汉字 @”^[\u4E00-\u9FA5]{2,4}$”; （二） 整数与浮点数 ^[1-9]\d$ //匹配正整数^-[1-9]\d$ //匹配负整数^-?[1-9]\d$ //匹配整数^[1-9]\d|0$ //匹配非负整数（正整数 + 0）^-[1-9]\d|0$ //匹配非正整数（负整数 + 0）^[1-9]\d.\d|0.\d[1-9]\d$ //匹配正浮点数^-([1-9]\d.\d|0.\d[1-9]\d)$ //匹配负浮点数^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ //匹配浮点数^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]\d.\d|0.\d[1-9]\d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0） E-Mail正则表达式： email正则表达式：两种方式都可以 (1) \w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* (2) ^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*((\\.[A-Za-z]{2,}){1}$) 国际域名格式如下: 域名由各国文字的特定字符集、英文字母、数字及“-”(即连字符或减号)任意组合而成, 但开头及结尾均不能含有“-”，“-”不能连续出现 。 域名中字母不分大小写。域名最长可达60个字节(包括后缀.com、.net、.org等)。 /^a-z@([a-z0-9][-_]?[a-z0-9]+)+[.][a-z]{2,3}([.][a-z]{2})?$/i; 解释： /内容/i 构成一个不区分大小写的正则表达式; ^ 匹配开始 $ 匹配结束 [a-z] E-Mail前缀必需是一个英文字母开头 ([a-z0-9][-_]?[a-z0-9]+) 和_a_2、aaa11、_1_a_2匹配，和a1_、aaff_33a_、a__aa不匹配，如果是空字符，也是匹配的，*表示0个或者多个。 * 表示0个或多个前面的字符. [a-z0-9]* 匹配0个或多个英文字母或者数字 [-_]? 匹配0个或1“-”，因为“-”不能连续出现 [a-z0-9]+ 匹配1个或多个英文字母或者数字，因为“-”不能做为结尾 @ 必需有个有@ ([a-z0-9][-_]?[a-z0-9]+)+ 见上面([a-z0-9][-_]?[a-z0-9]+)*解释，但是不能为空，+表示一个或者为多个。 [.] 将特殊字符(.)当成普通字符 [a-z]{2,3} 匹配2个至3个英文字母，一般为com或者net等. ([.][a-z]{2})? 匹配0个或者1个[.][a-z]{2}(比如.cn等) 我不知道一般.com.cn最后部份是不是都是两位的,如果不是请修改{2}为{起始字数,结束字数} 1234567891011121314151617181920212223242526272829public bool RegexName(string str) &#123; bool flag=Regex.IsMatch(str,@&quot;^[a-zA-Z0-9_\u4e00-\u9fa5]+$&quot;); return flag; &#125; Regex reg=new Regex(&quot;^[a-zA-Z_0-9]+$&quot;); if(reg.IsMatch(s)) &#123; \\符合规则 &#125; else &#123; \\存在非法字符 &#125;import java.util.regex.Matcher;import java.util.regex.Pattern;public List&lt;Map&lt;String, String&gt;&gt; getUser(String deptId) &#123; Pattern pattern = Pattern.compile(&quot;^[a-zA-Z0-9_]+$&quot;); Matcher matcher = pattern.matcher(deptId); if (matcher.find()) &#123; //如果匹配 &#125;else&#123; //不匹配 &#125;&#125; 日语韩语等常用正则表达式1.基础\d 匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持\D 匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持\f 匹配一个换页符。等价于\x0c和\cL。\n 匹配一个换行符。等价于\x0a和\cJ。\r 匹配一个回车符。等价于\x0d和\cM。\s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。\S 匹配任何可见字符。等价于[^ \f\n\r\t\v]。\t 匹配一个制表符。等价于\x09和\cI。\v 匹配一个垂直制表符。等价于\x0b和\cK。\w 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。\n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。\nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。\nml 如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 2.常用 1234567891011121314151617181920^[0-9]*$ 数字 ^\d&#123;m,n&#125;$ m-n位的数字 ^[0-9]+(.[0-9]&#123;2&#125;)?$ 有两位小数的正实数 ^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 浮点数 ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$ 手机号码 /^[a-z0-9]+([._\\-]*[a-z0-9])*@([a-z0-9]+[-a-z0-9]*[a-z0-9]+.)&#123;1,63&#125;[a-z0-9]+$/ Email地址 [a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 域名 [a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ URL ^\d&#123;15&#125;|\d&#123;18&#125;$ 身份证号(15位、18位数字) ^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125; 日期格式 [\u4e00-\u9fa5] 中文字符的正则表达式 ^[ァ-ヶー]&#123;1,45&#125;$日语的正则表达式 /x3130-/x318F (韩文 /xAC00-/xD7A3 (韩文) [1-9][0-9]&#123;4,&#125; 腾讯QQ号 [1-9]\d&#123;5&#125;(?!\d) 中国邮政编码 ^(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5]).(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5]) .(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5]).(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5])$ IP地址 ^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ xml文件 ^((0-9)+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$正浮点数 密码必须包含：半角数字、大写英文，小写英文、标点符号这4类中至少3种: ^(?![0-9a-z]+$)(?![0-9A-Z]+$)(?![0-9!#\$%&amp;=|\-\^@\[:\]\,\./\+\?]+$)(?![a-z!#\$%&amp;=|\-\^@\[:\]\,\./\+\?]+$) (?![a-zA-Z]+$)(?![A-Z!#\$%&amp;=|\-\^@\[:\]\,\./\+\?]+$)[a-zA-Z0-9!#\$%&amp;=|\-\^@\[:\]\,\./\+\?]&#123;8,16&#125;$(特殊字符根据需要添加，个别字符需要转译)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java正则表达式判断中文]]></title>
    <url>%2F2019%2F12%2F03%2FJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%A4%E6%96%AD%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[Java编程下正则表达式判断是否包含中文 123456789101112131415161718192021import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Test &#123; public static void main(String[] args) &#123; Scanner sc =new Scanner(System.in); System.out.println(isContainChinese(sc.next())); &#125; public static boolean isContainChinese(String str) &#123;//判断是否含有中文 Pattern p = Pattern.compile("[\u4e00-\u9fa5]"); Matcher m = p.matcher(str); if (m.find()) &#123; return true;//有中文 &#125; return false;//无中文 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔试题注意问题]]></title>
    <url>%2F2019%2F10%2F24%2FJava%E7%AC%94%E8%AF%95%E9%A2%98%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[如何介绍自己：面试官必为的问题回答范例：我叫XX，今年X岁，XXXX年毕业于XX大学。我对技术有深厚的兴趣，专业知识面宽，责任心强，思路清晰，沟通力能好，熟悉Java语言，熟悉MVC。平常有时间看看博客，并且在搭建的博客上写技术类的文章和笔记。 刁难题 如果对方说:”你的经历太简单，而我们需要社会经验丰富的人。你的回答是：“我确信如果我有缘加入贵单位，我将很快成为社会经验丰富的人，我希望自己有这样的一段经历。 如果对方说：“我们需要名牌学校的学生，你并非毕业于名牌学校。你的回答是：“听说比尔盖茨也未毕业于哈佛大学。” 如果对方说：“你的专业与所选的专业并不对口。你可以这样回答：“据说，21世纪最需要的就是复合型人才。而外行的灵感也许会超过内行的灵感，因为他们没有思维定式，没有条条框框 String是最基本的数据类型吗? 不是，基本数据类型包括：byte,short,int,long,float,double,Boolean,char, 而String是字符串类型。 • String s=new String(“abc”)；这句话创建几个对象？ 两个， 1：String s定义了一个变量s没有创建对象； 2：=赋值，将某个对象的引用赋给s没有创建对象； 3：“abc”创建一个对象； 4：new String()创建一个对象 • String 和StringBuffer的区别 ? String对一串字符串进行操作不可变的类。 StringBuffer对一串字符串进行操作，但是可变类。 Java关键字 Abrstact:抽象方法，抽象类的的修饰类 Assert：判断条件是否满足 Boolean:布尔数据类型 Break：跳出循环或者label代码段 Btye：8-bit有符号数据类型 Case：switch语句的一个条件 Catch：和try搭配捕捉异常信息 Char：16-bit Unicode字符数据类型 Cass：定义类 Const:未使用 Continue：不执行循环体剩余部分 Default:switch语句中默认的分支 Enum:枚举类型 Entends：表示一个类是另一个类的子类 Final：表示方法不能被重写，或者一个类不能有子类 Finally：为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码 Float：32-bit单精度浮点类型 For：for循环语句 Goto：未使用 If：条件语句 Implements：表示一个类实现了接口 Import：导入类 Instanof：测试一个类是否某个类的实例 Int：32位整形数 Interface：接口一种抽象类型，仅有方法和常亮的定义 Long：64位整形数 Native:表示方法用非Java代码实现 New：分配新的类实例 Package：一系列相关类组成的包 Private：表示私有的字段或者方法等，只能从类内部访问 Protected：表示字段只能通过类或子类访问，本包中 Public：有共同的属性或者方法 Return：方法返回值 Short：16位数字 Static：表示类别定义，所有实例共享的 Stricetfp：浮点数比较使用严格的规则 Super：表示基数 Switch：选择语句 Synchronized：表示在同一时间内只能由一个代码块访问 This：调用当前实例或者调用另外一个构造函数 Try：代码块要做处理或者finally配合表示是否抛出异常都执行finally中的代码 Throw：抛出异常 Throws：定义方法可能抛出的异常 Transient：修饰不要序列化的字段 Void：标记方法不反悔任何值 Volatile：字段可能被多个线程同时访问而不做同步 While：while循环 1、下面代码的运行结果为：（） 1234567891011121314import java.io.*;import java.util.*;public class foo&#123; public static void main (String[] args)&#123; String s; System.out.println("s=" + s); &#125;&#125; A 代码得到编译，并输出“s=” B 代码得到编译，并输出“s=null” C 由于String s没有初始化，代码不能编译通过 D 代码得到编译，但捕获到 NullPointException异常 答案：C 解析：开始以为会输出null什么的，运行后才发现Java中所有定义的基本类型或对象都必须初始化才能输出值。 2、什么是Java面向对象编程 面向对象程序设计的三大特征： 封装性； 继承性； 多态性； 面向对象就是：把数据及对数据的操作方法放在一起，作为相互依赖的整体 在面向对象的编程方式中，对象拥有多种特性，如手机有高度、宽度、厚度、颜色、重量等特性，这些特性被称为对象的属性。对象还有很多功能，如手机可以听音乐、打电话、发信息、看电影等工作功能，这些功能被称为对象的方法，实际上这些方法是一种函数。 用生活中的方法来说： 例如：一个主人养了一只猫和一只狗 获取例子中的对象：人，猫（猫吃鱼），狗（狗啃骨头）就是对象 从对象中抽象出类： 主人可以抽象出主人类people类 猫可以抽象出猫的类cat类 狗可以抽象出狗的类dog类 猫和狗是动物就可以继承动物类Animal类 假设猫喜欢吃的食物为鱼，因此可以提炼出鱼类Fish 假设狗喜欢吃的食物为骨头，因此可以提炼出骨头类Bone 因为鱼类和骨头类可以提炼出食物类Food 创建实体类 类是由属性和动作组成的 3、什么是重载，什么是重写 重载(Overload)：（1）Overloading是一个类中多态性的一种表现，让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。（2）重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同，也可以不相同。无法以返回型别作为重载函数的区分标准。 重写（Override):（1） 父类与子类之间的多态性，对父类的函数进行重新定义。即在子类中定义某方法与其父类有相同的名称和参数。（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。 4. ==跟equals()的区别 ==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。 equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。]]></content>
      <tags>
        <tag>Java笔试题注意问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改电脑的Mac地址]]></title>
    <url>%2F2019%2F10%2F23%2F%E4%BF%AE%E6%94%B9%E7%94%B5%E8%84%91%E7%9A%84Mac%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[win10怎么修改mac地址 如何修改网卡的物理地址1、开始菜单里点击设置 2、点击网络和Internet 3、点击更改适配器选项 4、鼠标右键点击以太网或者是本地连接，然后点击属性 5、进入以太网属性点击配置 6、然后点击高级在属性下选择网络地址然后在旁边输入要改的mac地址就可以了]]></content>
      <categories>
        <category>修改Mac地址</category>
      </categories>
      <tags>
        <tag>修改Mac地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jqGridColModel参数]]></title>
    <url>%2F2019%2F07%2F29%2FjqGridColModel%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[jqGrid|初始化|参数 名称 描述 url 获取数据地址 datatype 从服务器端返回的数据类型，默认为xml。可选类型有：xml，local，json等。 mtype ajax提交方式，POST或者GET。默认GET。 colNames 列显示名称，是一个对象数组。 colModel 常用到的属性：name：列显示的名称； index：传到服务器端用来排列用的列名称；width：列宽度；align：对齐方式；sortable：是否可以排序； pager 定义翻页用的导航栏，必须是有效的html元素。翻页工具可以放在页面的任意位置。 rowNum 在grid上显示记录条数，这个参数要被传递到后台。 rowList 一个下拉选择框，用来改变显示记录数，当选择时会覆盖rowNum参数传递到后台。 viewrecords 定义是否要显示总记录数 caption 表格名称 direction 表格中文字的显示方向，从左向右（ltr）或者从右向左（rtl） editurl 定义对form编辑时的url height 表格高度，可以是数字，像素值或者百分比 prmNames Default valuesprmNames: {page:“page”,rows:“rows”, sort: “sidx”,order: “sord”, search:“_search”, nd:“nd”, npage:null} 当参数为null时不会被发到服务器端 jqGrid colModel 参数ColModel 是jqGrid里最重要的一个属性，设置表格列的属性。 属性 描述 align 对齐方式。可选：left，center，right； classes 设置列的css。多个class之间用空格分隔，如：‘class1 class2’。表格默认的css属性是ui-ellipsis。 datefmt “/”，“-”，“.”都是有效的日期分隔符。日期格式，string Y-m-d editable 单元格是否可编辑 editoptions 编辑的一系列选项。{name：‘goodsId’， index：‘goodsId’， width：200， editable：true， edittype：‘select’， editoptions：{dataUrl：“goods_goodsEdit.do”}}。动态从服务器端获取数据的例子。 editrules 编辑的规则{name：‘age’， index：‘age’， width：90， editable：true， editrules：{edithidden：true， required：true， number：true， minValue：10， maxValue：100}}，设定年龄的最大值为100，最小值为10，而且为数字类型，并且必输字段。 fixed 列宽度是否要固定不可变 formoptions 对于form进行编辑时的属性设置 formatoptions 对某些列进行格式化的设置 formatter 对列进行格式化时设置的函数名或者类型。 {name：‘sex’， index：‘sex’， align：‘center’， width：60， editable：true， edittype：‘select’， editoptions：{value：‘0：待定；1：男；2：女’}， formatter：function（cellvalue， options， rowObject）{ var temp = “&lt;img src = ‘./img/” if (cellvalue == 1) { temp = temp + “male.png”; } else if (cellvalue == 2) { temp = temp + “female.png”; } else { temp = temp + “user.png”; } temp = temp + “ ‘border = ‘ 0’/&gt; “ return temp; }}, //返回性别的图标 hidden 在初始化表格时是否要隐藏此列。 index 索引。其和后台交互的参数是sidx label 如果colNames为空则用此值来作为列的显示名称，如果都没有设置则使用name值。 name 表格列的名称，所有关键字、保留字都不能作为名称使用，包括subgrid，cb，rn sortable 是否可排序 sorttype 用在当datatype为local时，定义搜索列的类型，可选值：int/integer，对integer排序； float/number/currency，排序数字； date：排序日期； text：排序文本。 width 默认列的宽度，只能是像素值，不能使百分比 unformat ‘unformat’单元格值 edittype 可编辑的类型。可选值：text， textarea， select， checkbox， password， button， image， file。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mvc入门笔记]]></title>
    <url>%2F2019%2F07%2F26%2FSpringmvc%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Spring MVC中MVC指的是什么 MVC是一种设计模式，目的是让HTML代码和业务逻辑代码分开，让代码看起来更加清晰，便于开发。 Model（数据模型）:与后台数据库联系，用来和View(视图)之间的数据交互、传值。 View(视图)：指视图页面，包含（JSP、freeMarker、Velocity、Thymeleaf、Tile等）。 Controller(控制器)：Spring MVC 的注解@Controller的类。 三层架构 Dao(数据访问层) Service(业务处理层) Web层（J2ee的内容） Mvc样例代码：wdk9]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring入门]]></title>
    <url>%2F2019%2F07%2F17%2Fspring%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring的IOC的底层原理实现 ​ 传统方式开发 ​ spring 优点： 轻量级框架 Ioc容器—–控制反转 Aop 面向切面编程 对事物的支持 对框架的支持 导入相应的jar包 在中使用 ​ 组织的唯一标识​ 项目的唯一标识​ 项目的版本]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java常见异常]]></title>
    <url>%2F2019%2F07%2F12%2Fjava%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Exception和RuntimeException的概念： Exception：在程序中必须使用try…catch进行处理。 RuntimeException：可以不使用try…catch进行处理，但是如果有异常产生，则异常将由JVM进行处理。 对于RuntimeException的子类最好也使用异常处理机制。虽然RuntimeException的异常可以不使用try…catch进行处理，但是如果一旦发生异常，则肯定会导致程序中断执行，所以，为了保证程序再出错后依然可以执行，在开发代码时最好使用try…catch的异常处理机制进行处理。 常见的非运行时异常 常见的java异常有哪些 1、常见的java运行时异常有哪些 操作数据库异常：SQLException 输入输出异常：IOException 文件未找到异常：FileNotFoundException 反射操作异常：ReflectiveOperationException 类未找到异常: ClassNotFoundException 方法未找到异常：NoSuchMethodException 字段未找到异常：NoSuchFieldException 非法访问权限异常：IllegalAccessException 实例化异常：InstantiationException 不支持克隆异常：CloneNotSupportedException 被中止异常：InterruptedException 2、什么情况下会抛出这些异常 1.java.lang.SQLException sql语句异常种类十分多，通常都是sql语句、数据库执行错误导致，常见的表现有： invalid column name 无效列名 table or view does not exist 表或者视图不存在 cannot insert NULL into () 不能将空值插入 缺少表达式 SQL 命令未正确结束 在操作数据库时需要考虑全面，尽量避免该异常。 2.java.lang.IOException 该异常种类也十分多（拥有很多子类），尤其对文件的操作，以及android开发。常见的表现有： FileNotFoundException 文件找不到。 InvalidPropertiesFormatException 输入内容不符合属性集的正确 XML 文档类型。 3.java.lang.FileNotFoundException 该异常的解释是：文件不存在异常。该异常继承于 IOException。这个异常通常是获取文件时，文件路径或文件名称错误导致的。 4.java.lang.ReflectiveOperationException 该异常的解释是：反射操作相关的异常。 由于反射的特殊性，类、方法、属性均使用String作为名称进行操作，对于该类异常一定要十分注意。 了解反射看这里：什么是java中的反射 5.java.lang.ClassNotFoundException 该异常的解释是：指定的类不存在。该异常继承于ReflectiveOperationException。 这个异常通常是在使用反射时，或者服务端引入jar包时抛出。 使用反射时，根据类名（字符串）获取Class时，包、类名有误会造成该异常。 6.java.lang.NoSuchMethodException 该异常的解释是：指定的方法不存在。该异常继承于ReflectiveOperationException。 这个异常通常是在使用反射时抛出。 使用反射时，根据方法名（字符串）调用Method时，方法名有误会造成该异常。 7.java.lang.NoSuchFieldException** 该异常的解释是：指定的字段不存在。该异常继承于ReflectiveOperationException。 这个异常通常是在使用反射时抛出。 使用反射时，根据字段名（字符串）获取、操作Field时，字段名有误会造成该异常。 8.java.lang.IllegalAccessException 该异常的解释是：没有访问权限。 当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。 最常见的地方即在使用反射调用private方法/属性时会抛出该异常，将private方法/属性共有化public即可。 9.java.lang.InstantiationException 该异常的解释是：实例化异常。该异常继承于ReflectiveOperationException。 当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。 10.java.lang.CloneNotSupportedException 该异常的解释是：不支持克隆异常。该异常继承于 ReflectiveOperationException。 当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。 11.java.lang.InterruptedException 该异常的解释是：被中止异常。 当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis3]]></title>
    <url>%2F2019%2F07%2F09%2FMyBatis3%2F</url>
    <content type="text"><![CDATA[使用MyBatis实现CURD的操作，必须先创建出SqlSessionFactory对象。 根据XML 文件中的配置创建SqlSessionFactory对象的核心Test.java类的代码如下 12345678910111213141516171819202122package mybatis1;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class Test &#123; public static void main(String[] args) throws IOException &#123; String configFile = "mybatis-config.xml"; InputStream configStream = Resources.getResourceAsStream(configFile); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); // org.apache.ibatis.session.SqlSessionFactory // org.apache.ibatis.session.defaults.DefaultSqlSessionFactory@17f6480 SqlSessionFactory factory = builder.build(configStream); System.out.println(factory); &#125;&#125; mybatis-config.xml配置文件 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>MyBatis3框架</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div+css布局2]]></title>
    <url>%2F2019%2F05%2F26%2Fdiv-css%E5%B8%83%E5%B1%802%2F</url>
    <content type="text"><![CDATA[盒模型以及浮动布局 谈到盒模型，有经验的小伙伴一定滚瓜烂熟，无非就是 内容(content)、填充(padding)、边框(border)、边界(margin)； 这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。 先上图： 上图清晰的表明了盒模型的具体表现样式； margin外边距+border边框+padding内边距+content内容； 既然盒模型叫做盒模型~那么我们可以把它比作一个 液晶屏幕包装盒子（楼主刚刚买了一台，所以拿它来比喻了，大家都知道的 这玩意儿快递的时候padding可不少啊） 拆快递的时候，里面的显示屏就是内容（content） 而泡沫呢？就是内边距（padding） 外面的壳子就是（border） 然后呢 就是盒子与其他盒子之间的距离（margin） 这就组成了我们css中的盒模型； css中盒模型有很多种表现形式：其中 block（块状）、inline（行内）、（inline-block以块状形式表现的行内元素） 设置css display可以改变盒子的表现形式 下面会详细介绍 个人觉得css可以这么去理解：它规定了盒子的包装样式，盒子的摆放位置，盒子的长宽高等等等等，浏览器就像是一个房子，等待人们用箱子填满它； 下面呢，楼主简单介绍一下 内容(content)、填充(padding)、边框(border)、边界(margin)在css中的具体表现，以及他们所带的看似bug的另类属性。 1.内容(content) 内容包括了文本，块状盒子，图片，内容盒子的盒模型等等……栗子： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;demohtml&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style type=&quot;text/css&quot;&gt; .div1&#123; background: red;&#125; &lt;/style&gt; &lt;div class=&quot;div1&quot;&gt; div标签默认是一个块状（block）盒子 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 上图代码得到的结果是：（楼主直接敲在编辑器里了） div标签默认是一个块状（block）盒子 div标签其默认的表现形式是block，通过观察我们可以得到 block块状盒子默认的宽度是100%，而高度右文字撑开，文字就是它的（content内容）；如果没有文字，并且没有规定高度，那么它的高度为0； 看图 文字的高度是21 边框 内边距 外边距 都为0 宽度为100% （楼主屏幕14寸的 小啊）； block（块状），它通常是一个外部容器 用来承载需要的内容 常用的块级元素有 div，p，h1 ， header，footer，nav 等等…… inline（行内） 行内元素，顾名思义，一行内的元素，块状里面的元素，常见的有a标签，i（倾斜标签），em，span，s（删除线），strong（加粗），b等等等等 行内元素的表现形式主要在于填充内容，它默认是没有上下外边距的，只可以左右； 1234&lt;div class=&quot;div1&quot;&gt; div标签默认是一个块状（block）盒子 &lt;a href=&quot;#&quot;&gt;这是一个超级链接&lt;/a&gt; &lt;/div&gt; 上图与代码表示了行内元素的表现形式 其宽高等于内容的宽高 且，不可以直接设置它的宽度和高度，设置宽度和高度并没有什么卵用； 我们可以使用 display：block；来让它变成块状。block也可以使用display：inline；来让块状变成行内； 这里由于篇幅过长，楼主点到即止，关于block与inline 传送门：block，inline和inline-block概念和区别 2.内边距(padding) 内边距规定了内容与边框之间的填充距离，栗子： 1234567&lt;style type=&quot;text/css&quot;&gt; .div2&#123; padding: 20px; border: 1px solid #000099;&#125; .div2 a&#123; background: red;&#125; &lt;/style&gt; &lt;div class=&quot;div2&quot;&gt; &lt;a href=&quot;#&quot;&gt;div标签默认是一个块状（block）盒子&lt;/a&gt; &lt;/div&gt; div标签默认是一个块状（block）盒子 楼主将div2的内边距设为上下左右各20px，需要注意的是 现在div2的高度是 padding+content+边框，20x2+2= 42px 这在某些时候会产生一些令人疑惑的问题，但是以盒模型的概念，它是正确的； 即 盒子的高度包括内边距 但 css属性设置的是content的高度 比如div3高度设为100px，注意这个时候 div3的实际高度等于 100+40+2=142px 1234567&lt;style type=&quot;text/css&quot;&gt; .div3&#123; padding: 20px; border: 1px solid #000099; height:100px;&#125;/*注意这个时候 div1的实际高度等于 100+40+2=142px*/ .div3 a&#123; background: red;&#125; &lt;/style&gt; &lt;div class=&quot;div3&quot;&gt; &lt;a href=&quot;#&quot;&gt;div标签默认是一个块状（block）盒子&lt;/a&gt; &lt;/div&gt; div标签默认是一个块状（block）盒子 3.边框(border) border默认为0；你可以随意指定它的某一个边的边框；其属性楼主也就不一一介绍了，再来一个传送门：CSS border边框属性教程(color style) 4.外边距(margin) 外边距规定了盒子与盒子之间的距离，因此它不会被计算到盒子的总体宽高之中，盒子内的盒子的外边距则会影响父级元素的宽度和高度； margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”。 这里也是直接给一个传送门吧，写起来这篇博文可就太长了…… css外边距详解 浮动w3shool对浮动的解释： 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 以推箱子游戏为例，将箱子往左推 直到它碰到边界 或者另外一个箱子就会停止下来 看图： 蓝色盒子往左浮动 （float:left） 红色箱子紧跟着往左浮动（float:left;） 橙色箱子往右浮动(float:right;) 蓝色在遇到边界之后，停止在左上角。红色紧跟着左浮动，它遇到了同样是左浮动元素的蓝色，所以它停止在蓝色的结尾。 而橙色方块向右浮动直到遇到边界或者同样右浮动的元素则停止； 浮动元素会脱离当前文档流，以一种特殊的形式存在，因为它不再处于文档流中，所以它不占据空间； 框1向左浮动，因为框1不再存在文档流中，框2被框1遮盖，图2当三个框同时向左浮动时，它们同是float元素，成列状排列； 另外一个特性是：如果包含框宽度小于内部浮动元素的总宽度，浮动元素会向下移动，直到有足够的空间； 如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”： 行框和清理浮动框旁边的行框被缩短，从而给浮动框留出空间，行框围绕浮动框。 因此，创建浮动框可以使文本围绕图像： 123456789101112131415161718&lt;style type=&quot;text/css&quot;&gt; .div1&#123;height:200px; width: 100px; float: left; background: #ff9000;&#125; .div1 a&#123; background: red;&#125; .div2&#123;height:200px; width: 100px; float: left; background: red;&#125; .div3&#123;height:200px; width: 100px; float: right; background: #002A80;&#125; &lt;/style&gt; &lt;div class=&quot;div1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;div2&quot;&gt; &lt;/div&gt; &lt;div class=&quot;div3&quot;&gt; &lt;/div&gt; &lt;div class=&quot;text&quot;&gt; 这是文本 &lt;/div&gt; 如果要想文本另换一行，与浮动框互不干扰，需要对该框应用 clear 属性。clear 属性的值可以是 left、right、both 或 none，它表示框的哪些边不应该挨着浮动框。 1234567891011121314151617181920&lt;style type=&quot;text/css&quot;&gt; .div1&#123;height:200px; width: 100px; float: left; background: #ff9000;&#125; .div1 a&#123; background: red;&#125; .div2&#123;height:200px; width: 100px; float: left; background: red;&#125; .div3&#123;height:200px; width: 100px; float: right; background: #002A80;&#125; &lt;/style&gt; &lt;div class=&quot;div1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;div2&quot;&gt; &lt;/div&gt; &lt;div class=&quot;div3&quot;&gt; &lt;/div&gt; &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt; //清除上面浮动元素的影响 &lt;div class=&quot;text&quot;&gt; 这是文本 &lt;/div&gt; 什么是CSS清除浮动？在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。 引用W3C的例子，news容器没有包围浮动的元素。 1234567891011121314151617.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 清除浮动方法 方法一：使用带clear属性的空元素 在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;来进行清理。 12345678910111213141516171819202122.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.clear &#123; clear: both; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; 优点：简单，代码少，浏览器兼容性好。 缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。 方法二：使用CSS的overflow属性 给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。 在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 12345678910111213141516171819.news &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 方法三：给浮动的元素的容器添加浮动 给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 方法四：使用邻接元素处理 什么都不做，给浮动元素后面的元素添加clear属性。 12345678910111213141516171819202122.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.content&#123; clear:both; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt; 方法五：使用CSS的:after伪元素 结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。 给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 123456789101112131415161718192021222324252627282930.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.clearfix:after&#123; content: &quot;020&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123; /* 触发 hasLayout */ zoom: 1; &#125;&lt;div class=&quot;news clearfix&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。 总结 通过上面的例子，我们不难发现清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。 推荐 在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。 最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div+css布局]]></title>
    <url>%2F2019%2F05%2F25%2Fdiv-css%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1、DIV+CSS定义及优势Div+css 是什么?Div+css 是一种目前比较流行的网页布局技术 Div 来存放需要显示的数据(文字，图表..) , css 就是用来指定怎样显示， 从而做到数据和显示相互的效果 Div+css 优势 表现和内容相分离 代码简洁，提高页面浏览速度 易于维护和改版 提高搜索引擎对网页的索引效率 我们可以简单的这样理解div+css: div 是用于存放内容(文字,图片,元素)的容器。 css 是用于指定放在div中的内容如何显示,包括这些内容的位置和外观. 2、“无意义”的HTML元素div和span HTML只是赋予内容的手段，大部分HTML标签都有其意义（例如，标签p创建段落，h1标签创建标题等等）的，然而div和span标签似乎没有任何内容上的意义，听起来就像一个泡沫做成的锤子一样无用。但实际上，与CSS结合起来后，它们被用得十分广泛。你所需要记住的是span和div是“无意义”的标签。它们的存在纯粹是应用样式，所以当样式表失效时它就没有任何的作用 它们被用来组合成一大块的HTML代码并赋予一定的信息，大部分用类属性class和标识属性id与元素联系起来。span和div的不同之处在于span是内联的，用在一小块的内联HTML中。而div（division）元素是块级的（简单地说，它等同于其前后有断行），用于组合一大块的代码，为HTML 文档内大块的内容提供结构和背景的元素，可以包含段落、标题、表格甚至其他部分，这使div便于建立不同集成的类。 div的起始标签和结束标签之间的所有内容都是用来构成这个块的，其中所包含元素的特性由div标签的属性来控制，或者是通过使用样式表格式化这个块来进行控制 3、页面布局的盒子模型（1）盒子模型的相关属性 margin（外边距/边界） border（边框） padding（内边距/填充 ） ​ 我们看图理解一下各属性作用： ​ ​ 以上属性又分为上、右、下、左四个方向​​ 问题：页面元素的宽度width、高度height如何计算？ 答案：元素的实际占位尺寸 = 元素尺寸 + padding + 边框宽度 比如：元素实际占位高度 = height属性 + 上下padding + 上下边框宽度 （2）盒模型的层次关系 ​ 我们通过一个经典的盒模型3D立体结构图来理解，如图：​ ​ 从上往下看，层次关系如下：​ 第1层：盒子的边框(border)，​ 第2层：元素的内容(content)、内边距(padding)​ 第3层：背景图(background-image)​ 第4层：背景色(background-color)​ 第5层：盒子的外边距(margin) ​ 从这个层次关系中可以看出，当同时设置背景图和背景色时，背景​ 图将在背景色的上方显示 4、声明盒子模型的CSS属性 例如： 12345678910111213141516171819 &lt;html&gt; &lt;head&gt; &lt;title&gt;盒子模型&lt;/title&gt; &lt;style&gt; #box &#123; /* ID为box的盒子模型 */ width:200px; /* 盒子的宽度为200px */ height:200px; /* 盒子的高度为200px */ border:5px solid #ccc; /* 盒子边框实线各边宽5px */ padding:10px; /* 盒子的4个内填充为10px */ margin:20px; /* 盒子的4个外边距为10px */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;!-- 使用DIV声明一个盒子 --&gt; 内容区 &lt;!-- 盒子内容可再嵌套个盒子 --&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 水平居中和垂直居中 ​ 水平居中包含两种情况： 块级元素的水平居中：margin:0px auto;​ 文字内容的水平居中：text-align: center; ​ 垂直居中：​ 常见的单行文字的垂直居中可设置文字所在行的height与​ 行高样式属性一致，比如：​ div{​ width: 400px;​ height: 400px;​ line-height: 400px;/*行高与div高度一致*/​ } 5、和页面布局有关的CSS属性12345678910 #box &#123; /* 声明ID选择器，名称为box */ position:absolute; /* 设置层的定位为绝对定位 */ top:30px; /* 层距离顶点纵向坐标的距离为30个像素 */ left:100px; /* 层距离左点横向坐标的距离为100个像素 */ width:300px; /* 设置层的宽度为300个像素 */ height:150px; /* 设置层的高度为150个像素 */ overflow:auto; /* 当内容超出层的范围时显示滚动条 */ z-index:1; /* 设置层的先后顺序为覆盖关系 */ visibility:visible; /* 无论父层是否可见，子层都可见 */ &#125; 6、盒子区块框的定位层模型–绝对定位如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 如下面代码可以实现div元素相对于浏览器窗口向右移动100px，向下移动50px。 123456789div&#123; width:200px; height:200px; border:2px red solid; position:absolute; left:100px; top:50px;&#125;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 效果如下： 层模型–相对定位如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 如下代码实现相对于以前位置向下移动50px，向右移动100px; 12345678910#div1&#123; width:200px; height:200px; border:2px red solid; position:relative; left:100px; top:50px;&#125;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 效果图： 什么叫做“偏移前的位置保留不动”呢？ 大家可以做一个实验，在右侧代码编辑器的19行div标签的后面加入一个span标签，在标并在span标签中写入一些文字。如下代码： 123&lt;body&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;span&gt;偏移前的位置还保留不动，覆盖不了前面的div没有偏移前的位置&lt;/span&gt;&lt;/body&gt; 效果图： 从效果图中可以明显的看出，虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。 层模型–固定定位fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。以下代码可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。 12345678910 #div1&#123; width:200px; height:200px; border:2px red solid; position:fixed; left:100px; top:50px; &#125; &lt;p&gt;文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本。&lt;/p&gt;.... 7、盒子模型的浮动布局 理解浮动属性首先要搞清楚，什么是文档流？ 文档流：浏览器根据元素在html文档中出现的顺序， 从左向右，从上到下依次排列 浮动属性是CSS中的定位属性，用法如下： **float: 浮动方向(left、right、none);** left为左浮动、right为右浮动、none是默认值表示不浮动 ，**设置元素的浮动，该元素将脱离文档流，向左或向右移动 直到它的外边距碰到父元素的边框或另一个浮动元素的边 框为止** ​ 浮动示例，没有使用浮动的3个DIV：​ HTML结构代码： ​ &lt;div id=&quot;first&quot;&gt;第1块div&lt;/div&gt;​ &lt;div id=&quot;second&quot;&gt;第2块div&lt;/div&gt;​ &lt;div id=&quot;third&quot;&gt;第3块div&lt;/div&gt; ​ CSS样式代码：​ #first, #second, #third{​ width:100px;​ height:50px;​ border:1px #333 solid;​ margin:5px;​ } ​ 执行效果如图：​ 样式中加入 float:left; 执行效果如图： ![img](https://res.cloudinary.com/jian887/image/upload/v1558712332/Html/9_l8cpcv.jpg) 你再修改为 float: right试试右浮动是什么效果 16、让商品分类DIV、内容DIV和右侧DIV并排放置 ​ HTML结构代码：​ 123456789&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;header&quot;&gt;顶部（header）&lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;div class=&quot;cat&quot;&gt;商品分类(cat)&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;内容(content)&lt;/div&gt; &lt;div class=&quot;sidebar&quot;&gt;右侧(sidebar)&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;底部（footer）&lt;/div&gt; &lt;/div&gt; 123456789&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;header&quot;&gt;顶部（header）&lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;div class=&quot;cat&quot;&gt;商品分类(cat)&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;内容(content)&lt;/div&gt; &lt;div class=&quot;sidebar&quot;&gt;右侧(sidebar)&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;底部（footer）&lt;/div&gt; &lt;/div&gt; CSS样式代码(在第13节CSS代码基础上加入)： 12345678910.cat, .sidebar &#123; float:left; width:20%; height:100%; &#125; .content &#123; float:left; width:60%; height:100%; &#125; 17、clear清除 ​ clear只对块级元素有效，表示如果前一个元素存在左浮动或右浮动，则换行​ clear属性的取值：rigth、left、both、none]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划的核心是状态和状态转移方程]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yii2.0]]></title>
    <url>%2F2019%2F05%2F05%2Fyii2-0%2F</url>
    <content type="text"><![CDATA[yii 2.0 目录结构 composer.json Composer配置文件，描述包信息 config/ 包含应用配置及其他配置 ​ console.php 控制台应用配置信息 ​ web.php web应用配置信息 commands/ 包含控制台命令类 controllers/ 包含控制器类 MVC中的C models/ 包含模型类 MVC中的M runtime/ 包含Yii在运行时生成的文件，例如日志和缓存文件 vendor/ 包含已经安装的Composer包，包括Yii框架本身 views/ 包含视图文件 MVC中的V web/ Web 应用跟目录，包含Web入口文件 ​ assets/ 包含Yii发布的资源文件（JavaScript和css） ​ index.php 应用入口文件 yii Yii控制台命令执行脚本]]></content>
      <categories>
        <category>Yii框架</category>
      </categories>
      <tags>
        <tag>Yii2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2F2019%2F04%2F25%2FJava%2F</url>
    <content type="text"><![CDATA[1.接口 ​ 使用关键字interface来定义一个接口 例： interface jiekou { ​ final int MAX=100; ​ void add(); ​ float sum(float x, float y); ​ } 2.接口声明 interface 接口名字 ； 3.接口体 接口体只有抽象方法，没有普通的方法，且接口体中所有的常量的访问权限一定都是public，而且是static 常量(允许省略public final和static 修饰符) 接口实现]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个人next主题博客接入谷歌广告]]></title>
    <url>%2F2019%2F04%2F19%2Fhexo%E4%B8%AA%E4%BA%BAnext%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%8E%A5%E5%85%A5%E8%B0%B7%E6%AD%8C%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[前言个人博客搭了大概也有大半年的时间，陆陆续续更新了一些文章，虽然每天整个网站的浏览量不是特别高，但是也希望能够引入网站的流量变现（蚊子腿再小也是肉啊…），于是自己查阅了相关的资料，整理了一份完整的，接入谷歌广告联盟google adsense的一套完整流程，供大家参考～ 准备环境 使用hexo的next主题搭建博客 已翻墙，可以登录google adsense网站(本人是在搬瓦工上购买了一年的服务器，自己搭了了一套ShadowSocks环境) 注册账号注册账号流程比较简单，入口在这里：Google Adsense 添加广告代码注册账号完成之后，需要将谷歌提供给你的一份代码添加到你网站的中的 标记中，在你添加完成之后，点击确认，谷歌会到你的网站上进行核查和验收。 对于使用hexo的next主题博客的同学，只要将谷歌提供的代码 1234567&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;&lt;script&gt; (adsbygoogle = window.adsbygoogle || []).push(&#123; google_ad_client: &quot;ca-pub-8511538239750965&quot;, enable_page_level_ads: true &#125;);&lt;/script&gt; 放到\themes\next\layout_partials\head.swig 任意一个位置(本人放在了最后)即可，在给谷歌确认之前，可以自己先使用浏览器进行验证：打开自己的网站，点击右键，查看源码，搜索一下是否已经成功添加上述代码。确认无误之后，在google adsense上点击确认，开始验证，一般没问题的话几分钟就会出结果，有问题的话要等待一段时间。 根据我个人申请的流程，总结了一些经验，供大家参考： 网站文章不要太少，至少大于10篇博客以上。 网站上架半年以上，如果是新申请的网站，一般不容易过审。(这里建议大家有接入google adsense的新站长，等网站稍微成熟点再去申请，本人第一次申请就因为建站时间过短，还不到3个月被拒) 个性化配置广告位待通过审核之后，就可以开始考虑在自己的网站上进行广告位置的筛选和设计了，目前google adsense主要提供了自动广告和广告单元两种形式的广告添加方式。 自动广告自动广告是google adsense近来提供的一种广告形式，它能够通过分析你的博客布局结构，自定义的在你的网站中插入合适的广告，无论是内容，还是广告尺寸，都是完全契合网站内容本身的，算是一种比较高质量的广告。 但是根据我的使用经验，这种广告投放的几率比较小，往往好几篇文章或页面才会投放一个广告内容，效率比较低(唯一的好处是，如果你的网站支持移动端查看的话，会自动投放移动端自适应的广告)具体的代码插入方法，其实就是上述的用来检验的代码，一旦上述代码审核通过，其实已经自动接入了google adsense的自动广告。 广告单元为了能够最高效的利用自己博客的广告位，adsense还提供了三种固定广告位 文字广告和展示广告(即侧边栏，评论区之类的固定广告位) 信息流广告(插入在信息流内容的广告位置) 文章内嵌广告(主要是插入在每篇文章内部的开始，中间，结尾部分，展示次数比较多，强烈推荐) 由于本人的是博客网站，所以第二种信息流广告没有投入使用，这里主要使用了第一种和第三种。 具体的操作流程是，在网站上，选择广告单元-&gt;新建广告位-&gt;选择对应的广告类型-&gt;生成对应的广告代码。 这里，本人根据个人经验，提供几种针对hexo的next主题广告代码位置的插入。 插入评论区：将代码插入\themes\next\layout_partials\comments.swig 中的末尾即可。 插入侧边栏：将代码插入\themes\next\layout_macro\sidebar.swig 文件中 的最下侧即可 12345678910111213141516171819202122&lt;div class=&quot;sidebar-inner&quot;&gt;............ &#123;% if theme.sidebar.b2t %&#125; &lt;div class=&quot;back-to-top&quot;&gt; &lt;i class=&quot;fa fa-arrow-up&quot;&gt;&lt;/i&gt; &#123;% if theme.sidebar.scrollpercent %&#125; &lt;span id=&quot;scrollpercent&quot;&gt;&lt;span&gt;0&lt;/span&gt;%&lt;/span&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125; &lt;!-- 侧边栏广告 --&gt; &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;&lt;script&gt; (adsbygoogle = window.adsbygoogle || []).push(&#123; google_ad_client: &quot;ca-pub-8511538239750965&quot;, enable_page_level_ads: true &#125;);&lt;/script&gt;&lt;/div&gt; 插入文章头部：在 \themes\next\layout_custom\post.swig 目录下，新建google_adsense.swig，并将google提供的广告代码放入其中，然后将 1&#123;% include &apos;../_custom/google_adsense.swig&apos; %&#125; 插入\themes\next\layout_macro\post.swig 文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;div class=&quot;post-body&#123;% if theme.han %&#125; han-init-context&#123;% endif %&#125;&quot; itemprop=&quot;articleBody&quot;&gt; &#123;# Gallery support #&#125; &#123;% if post.photos and post.photos.length %&#125; &lt;div class=&quot;post-gallery&quot; itemscope itemtype=&quot;http://schema.org/ImageGallery&quot;&gt; &#123;% set COLUMN_NUMBER = 3 %&#125; &#123;% for photo in post.photos %&#125; &#123;% if loop.index0 % COLUMN_NUMBER === 0 %&#125;&lt;div class=&quot;post-gallery-row&quot;&gt;&#123;% endif %&#125; &lt;a class=&quot;post-gallery-img fancybox&quot; href=&quot;&#123;&#123; url_for(photo) &#125;&#125;&quot; rel=&quot;gallery_&#123;&#123; post._id &#125;&#125;&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot; itemprop=&quot;url&quot;&gt; &lt;img src=&quot;&#123;&#123; url_for(photo) &#125;&#125;&quot; itemprop=&quot;contentUrl&quot;/&gt; &lt;/a&gt; &#123;% if loop.index0 % COLUMN_NUMBER === 2 %&#125;&lt;/div&gt;&#123;% endif %&#125; &#123;% endfor %&#125; &#123;# Append end tag for `post-gallery-row` when (photos size mod COLUMN_NUMBER) is less than COLUMN_NUMBER #&#125; &#123;% if post.photos.length % COLUMN_NUMBER &gt; 0 %&#125;&lt;/div&gt;&#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125; &#123;% if is_index %&#125; &#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125; &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __(&apos;post.more&apos;) &#125;&#125;&#123;% endif %&#125;&quot; rel=&quot;contents&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif theme.auto_excerpt.enable %&#125; &#123;% set content = post.content | striptags %&#125; &#123;&#123; content.substring(0, theme.auto_excerpt.length) &#125;&#125; &#123;% if content.length &gt; theme.auto_excerpt.length %&#125;...&#123;% endif %&#125; &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __(&apos;post.more&apos;) &#125;&#125;&#123;% endif %&#125;&quot; rel=&quot;contents&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% else %&#125; &#123;% if post.type === &apos;picture&apos; %&#125; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;&#123;&#123; post.content &#125;&#125;&lt;/a&gt; &#123;% else %&#125; &#123;&#123; post.content &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% else %&#125; &#123;% include &apos;../_custom/google_adsense.swig&apos; %&#125; &#123;&#123; post.content &#125;&#125; &#123;% endif %&#125; &lt;/div&gt; 注意，这里不要搞错，误插入到\themes\next\layout\post.swig 文件中了，这样不仅仅会导致每篇文章里存在广告，在首页的列表中，每篇文章同样也都会带上广告，导致首页一次刷出来N个广告，影响网站布局和设计。 注意事项在成功接入AdSense广告之后，并不算结束，Google会根据几种方式和数据判断广告点击是否作弊，从而注销你的账号。所以不要心存侥幸心理，好好发原创文章，提高网站的质量才是王道。 作弊广告点击者的IP地址与你Adsense账户登录IP地址相同 作弊广告点击的CTR数据太高 作弊广告点击者的IP地址来自同一个地理区域 根据Cookies判断作弊Adsense广告点击 作弊广告点击者页面停留时间太短 直接访问者的广告点击率过高 流量小但广告点击率高 在网页上用文字提示请求鼓动点击广告]]></content>
  </entry>
  <entry>
    <title><![CDATA[35个短信免费接收平台分享，你值得拥有！免费接码平台！]]></title>
    <url>%2F2019%2F04%2F19%2F35%E4%B8%AA%E7%9F%AD%E4%BF%A1%E5%85%8D%E8%B4%B9%E6%8E%A5%E6%94%B6%E5%B9%B3%E5%8F%B0%E5%88%86%E4%BA%AB%EF%BC%8C%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89%EF%BC%81%E5%85%8D%E8%B4%B9%E6%8E%A5%E7%A0%81%E5%B9%B3%E5%8F%B0%EF%BC%81%2F</url>
    <content type="text"><![CDATA[35个短信免费接收平台 国内免费临时手机号1、https://sms.cm2、https://www.pdflibr.com3、https://www.becmd.com4、http://www.smszk.com5.http://www.51ym.me/User/MobileSMSCode.aspx（付费） 国外免费临时手机号1、https://zh.mytrashmobile.com（中文）2、https://ch.freephonenum.com（中文）3、SMSReceiveFree：https://smsreceivefree.com4、Receive SMS Online for FREE：https://www.receive-sms-online.info5、Receive a SMS Online：https://receive-a-sms.com6、Free SMS Numbers Online：https://smsnumbersonline.com7、Receive SMS online for Free：https://sms-online.co/receive-free-sms8、Receive-SMS：https://receive-sms.com9、Receive FREE SMS online：http://receivefreesms.com10、RECEIVE SMS ONLINE：https://www.receivesmsonline.net11、Free Online Phone：https://www.freeonlinephone.org12、Receive SMS Online：http://receive-sms-online.com13、TextNow：https://www.textnow.com14、Textfree：https://www.pinger.com/text-free/15、SELLAITE：http://sms.sellaite.com/16、Twilio：https://www.twilio.com/17、https://receive-sms.com/18、http://receive-sms-online.com/19、http://sms.sellaite.com/20、http://hs3x.com/21、http://receivefreesms.net22、http://receivesmsonline.in23、http://www.receive-sms-now.com24、https://sms-receive.net25、https://www.receivesms.net26、http://www.freesmsverifications.com27、http://receiveonlinesms.biz28、http://receivesmsverification.com29、https://www.receivesms.co30、http://receiveonlinesms.com 24，25亲测可以注册微博账号]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL数据库实验答案]]></title>
    <url>%2F2019%2F04%2F18%2FSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[2．使用UPDATE命令修改基本表中的数据 （1）将编号为‘F70006’的商品的单价改为12.00元 update commodity set avgprice=12.00 where cid=’ F70006’ （2）将名称为‘家乐福’的客户的等级改为VIP客户。 update customer set culevel=2 where cuname=’家乐福’ （3）将编号为‘A102’ 供应商供应商品的价格全部打八折 update supplying set price=price 0.8 where sid=’A102’ 3．使用DELETE命令删除基本表中的数据 （1）删除采购明细表中的所有记录 delect from dbo.stockDetail （2）从采购单表中删除2005年以前签订的采购单 delect from dbo.stock where year(cgdate)&lt;’2005’ 4．使用SELECT…INTO语句向表中成批插入记录 （1）将供应商‘A102’供应的商品和供应价格存到一个名字为‘A102_commodity’的表中 SELECT cgid,eid,cgmoney,cgdate INTO A102_commodity from stock where sid=’A102’ （2）将所有的VIP客户信息存储到一个名字为‘VIP_Customer’的表中 select cuid,cuname,cutelephone into VIP_Customer from customer where culevel=2 5．使用INSERT…SELECT语句向表中成批插入记录 （1）新建一个名称为‘achievement’的表，其属性包括销售单ID，销售单总金额，销售日期 CREATE TABLE achievement( SAid char(12) PRIMARY KEY, –**销售单**ID SAmoney float, –**销售金额** SAdate DateTIme, –**签订日期** ) （2）将编号为‘S0002’的销售员签订的销售单信息存储到achievement表中。 insert into achievement(SAid,SAmoney,SAdate) select SAid,SAmoney,SAdate from sale where eid=’S0002’ 三、自我测试 1．从采购明细表中删除所有从供应商‘A153’处采购的编号为‘F70006’商品的明细信息 DELETE from stockdetail where cgid in (select cgid from stock where sid=’A153’) and cid=’F70006’ 2．从销售明细表中删除2005年以前签订的销售单的销售明细记录 delete from saledetail where said in (select said from sale where year(sadate)&lt;’2005’) 实验三 单表查询 一、实验目的与要求 1．掌握基本的SELECT…FROM语句的用法 2．能应用SELECT语句及其子句解决常见的查询问题 3．掌握模糊查询的使用方法 4．能应用聚集函数和GROUP BY子句进行统计查询 二、实验内容 1． 查找所有商品的名称和库存信息 select cname,cstorage from commodity 2． 查找‘北京’地区的供应商 select * from supplier where sarea = ‘**北京’** 3． 查找所有销售人员的基本信息 Select * from employee where etype=3 4． 查找签订日期在‘2005-5-1’和‘2006-3-1’之间签订的采购单的基本信息 select * from stock where cgdate&gt;’2005-5-1’ and cgdate&lt;’2006-3-1’ 5． 查找2006年签订的所有销售单，要求显示销售单ID、客户ID和销售单总金额 select said,cuid,samoney from sale where year(sadate)= ‘2006’ 6． 查找每个采购员所签订的采购单的数目，显示结果按采购单数目降序排序 select eid,count(cgid) myc from stock group by eid order by myc desc 7． 查询每个销售员签订的销售单总金额 select eid,sum(samoney) from sale group by eid 8． 查找2005年与每个客户签订的销售单的总金额，只显示总金额大于500000的客户ID和总金额 select cuid,samoney from sale where samoney&gt;500000 and year(sadate)=2005 9． 查询2005年签订的金额最大的一笔销售单，要求显示销售员ID、客户ID和销售金额 select top 1 eid,cuid,samoney from sale where year(sadate)=2005 10． 查询2005年与编号为‘A002’的供应商签订的所有采购单的总金额 select sum(cgmoney) from stock where year(cgdate)=2005 and sid=’ A002’ 11． 查询名称中含有‘机’字的所有商品的ID、名称和库存量 select cid,cname,cstorage from commodity where cname like ‘%**机%’** 12． 查找第二个汉字是‘翔’的商品名称和单价。 select cname,avgprice from commodity where cname like ‘_**翔%’** 三、自我测试 1．查询2005年签订的销售合同总额排名前5名的销售员的ID和合同总额，要求结果按照合同总额降序排列 select top 5 eid,samoney from sale order by samoney desc 2．查询至少供应了3种商品的供应商的ID select sid from supplying group by sid having count(*)&gt;=3 3．查询在2006年至少已经与2名销售员签订了合同的客户ID select cuid,count(distinct eid) from sale where year(sadate)=2006 group by cuid having count(distinct eid)&gt;=2 实验四 表连接查询 一、实验目的与要求 1．掌握表连接查询的使用方法 2．掌握子查询的使用方法 3．能使用内连接、左外连接、右外连接以及交叉连接解决相关问题 4．熟悉系统函数的使用 二、实验内容 1．查找每一个供应商供应的商品的名称，要求显示供应商名称和商品名称。 select sname,cname from supplying sg,commodity c,supplier sr where sg.cid=c.cid and sr.sid=sg.sid 2．使用连接查询查找与姓名为‘李云’的采购员签订采购单的供应商的名称。 select distinct sname from stock s,supplier sr,employee e where s.sid=sr.sid and e.eid=s.eid and ename=’**李云’** 3．使用关键字IN完成查询，要求查找与姓名为‘李云’的采购员签订采购单的供应商的名称。 select sname from supplier where sid in( select sid from stock sk,employee e where sk.eid=e.eid and e.ename=’**李云’)** 4．使用左外连接完成如下查询：要求查找所有采购员签订的采购合同的详细信息。 select * from dbo.Employee e left join dbo.stock s on e.eid=s.eid 5．使用左外连接完成如下查询：查找所有客户购买的商品详细信息，要求显示客户名称， 商品名称，销售数量，商品单价，没有购买商品的客户也要显示。 select cuname,cname,sdnumber,sdprice from dbo.customer cu left join dbo.sale s on cu.cuid=s.cuid ​ left join dbo.saleDetail sd on sd.said=s.said ​ left join commodity c on sd.cid=c.cid 6．请使用内连接完成如下查询：查找每一个供应商供应的商品的种类，要求显示供应商名称，供应的商品的种类。 select sname,count(cname) from dbo.supplier s inner join dbo.supplying sp on s.sid=sp.sid inner join dbo.commodity c on sp.cid=c.cid ​ group by sname 7．查找购买了编号为‘A001’的供应商供应的商品的客户名称 select cuname from customer cu,sale s,saledetail sd,supplying sp,supplier sr Where cu.cuid=s.cuid and s.said=sd.said and sd.cid=sp.cid and sr.sid=sp.sid and sp.sid=’ A001’ 8．查找销售员‘王良’在2005年签订的销售合同的详细信息。 select sd.*,s.* from saledetail sd,sale s,employee e where sd.said=s.said and e.eid=s.eid 三、自我测试 1．使用右外连接完成如下查询：要求查找所有采购员签订的采购合同的详细信息，没有签订采购单的采购员也要显示 select st.*,std.*,e.* from stockdetail std right join stock st on std.cgid=st.cgid right join employee e on e.eid= st.eid 2．查找购买了名称为‘联想集团’的供应商供应的商品的客户名称 select distinct cuname from customer cu,sale s,saledetail sd,commodity c,supplying sp,supplier sr Where cu.cuid=s.cuid and s.said=sd.said and sd.cid=c.cid and sp.cid=c.cid and sp.sid=sr.sid and sr.sname=’**联想集团’** 实验五 表综合查询使用 一、实验目的与要求 1．能熟练应用SELECT语句及其相关字句 2．能将SELECT与系统函数、IF ELSE、WHILE等语句进行综合应用并解决相关问题 二、实验内容 1．查询所有供应‘鲜橙多’的供应商的最低报价。 select min(price) from supplying where cid in(select cid from commodity where cname=’**鲜橙多’)** 2．查找销售员‘王良’在2005年签订的所有销售合同中每一类商品的总金额。 select cid,sum(sdprice*sdnumber) from saledetail sd,sale sa where sd.said=sa.said and year(sadate)=2005 and eid in(select eid from employee where ename=’**王良**’) group by cid 3．汇总由姓名为‘刘明’的采购员在2005年采购的‘数码相机’的总金额。 select sum(sdnumber*sdprice) from stockdetail sd,stock s where sd.cgid=s.cgid and eid =(select eid from employee where ename=’**刘明’)** and cid=(select cid from commodity where cname=’**数码相机’)** 1． 汇总由姓名为‘刘明’的采购员在2005年采购的各类商品的数量。 select cid,sum(sdnumber) from dbo.stockDetail where cgid in(select cgid from stock where year(cgdate)=2005 and eid=(select eid from employee where ename=’**刘明’)** ) group by cid 2． 查找没有供应任何一类商品的供应商的名字。 select sname from supplier where sid not in(select sid from supplying) 3． 查找在2006年各个客户购买商品的总金额，要求结果按照购买商品的总金额降序排序 select cuid,sum(samoney) from sale where year(sadate)=2006 group by cuid 4． 查找编号为‘A002’的供应商没有供应的商品的名称 select cname from commodity where cid not in(select cid from supplying where sid=’A002’) 5． 查询由‘三高计算机公司’和‘联想集团’供应商的所有商品的商品名称。 select cname from commodity where cid in( select cid from supplying where sid in( ​ select sid from supplier where sname in(‘**三高计算机公司’,’联想集团’)))** 三、自我测试 \1. 请使用左连接完成以下查询：查找每一个销售人员销售的商品的详细信息，要求显示销售人员姓名、销售单ID、客户姓名、商品名称、销售数量、和销售单价。 select ename,s.said,cuname,sdnumber,sdprice from employee e left join sale s on s.eid = e.eid ​ left join saledetail sd on s.said=sd.said ​ left join customer cu on s.cuid=cu.cuid ​ left join commodity c on sd.cid=c.cid ​ where e.etype=3 \2. 查找每个采购员和每个供应商签订的合同的总金额，要求显示采购员姓名、供应商名称、和签订合同的总金额。（可以假设采购员姓名唯一，供应商名称唯一） select ename,sname,sum(cgmoney) from stock st,employee e,supplier sr Where e.eid=st.eid and sr.sid=st.sid Group by ename,sname 实验六 视图与索引 一、实验目的与要求 1．熟悉视图的概念，以及视图与表的联系和区别 2．掌握视图的定义方法 3．掌握对视图的查询操作 1． 掌握对视图的更新操作，并了解视图的更新条件 2． 掌握同时对视图和表进行操作的方法 3． 熟悉索引的概念与作用 4． 掌握索引的建立与删除操作 二、实验内容 1．定义一个名称为‘supplying_view’的视图，要求其对应的数据是由‘天天食品公司’供应的商品ID、商品单价。 create view supplying_view as select cid,price from supplying where sid = (select sid from supplier where sname=’**天天食品公司’)** 2．查询采购员‘李云’和供应商‘天天食品公司’签订的所有采购单的采购单ID、采购金额、签订日期，并将其建立为一个名称为‘stock_view_1’的视图。 create view stock_view_1 as select st.cgid,cgmoney,cgdate from stock st where eid =(select eid from employee where ename=’**李云’)** and sid =(select sid from supplier where sname=’**天天食品公司’)** 3．建立一个名称为‘commodity_100’的视图，其对应所有的库存量小于100的商品的信息。 create view commodity_100 as select * from commodity where cstorage&lt;100 4．使用视图supplying_view和相关基本表查找由供应商‘天天食品公司’供应的商品ID、商品名称和商品单价。 select sv.*,cname from supplying_view sv,commodity c where sv.cid=c.cid 5．使用视图‘stock_view_1’和相关基本表查询‘李云’和供应商‘天天食品公司’签订的所有采购单的采购明细信息，要求显示采购单ID、商品ID、商品名称、采购数量、和商品单价。 select sv1.cgid,c.cid,cname,sdnumber,avgprice from stock_view_1 sv1,commodity c,stockdetail std where sv1.cgid=std.cgid and c.cid=std.cid 6．为supermarket数据库中的任意一个表建立索引（按升序建唯一索引号）。 create index id on commodity(cid asc) 7．使用DROP INDEX语句删除新建的索引 drop index id 三、自我测试 1．建立一个视图，其对应的数据是在2006年签订的销售单总额超过100万的销售员的I D和姓名。 Create view myview as Select s.**eid,ename from sale s,employee e** where year(SAdate)=2006 and s.eid=e.eid 2．使用上述建立的视图和NOT IN关键字查询在2006年签订的销售单总额没有超过100万的销售员的I D和姓名。 Select s.eid,ename from sale s,employee e where s.eid=e.eid and year(SAdate)=2006 and s.eid not in(select eid from myview)]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原版编译原理实验指导书]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%8E%9F%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[编 译 原 理 实 验 指 导 书 前 言 编译原理是计算机科学与技术、软件工程等专业的主干课和必修课，由于这门课程相对抽象且内容较复杂，一直是比较难学的一门课程。在编译原理的学习过程中，实验非常重要，只有通过上机实验，才能使学生对比较抽象的课程内容产生一个具体的感性认识。 本书实验环境主要为C环境及一个词法分析器自动生成工具FLEX和一个语法分析器自动生成工具BISON。书中给出的参考源程序也是C源程序，但由于实验者熟悉精通的语言工具不尽相同，因而强求采用统一的编程语言编程是不现实的。实验者在掌握了编译程序各个阶段的功能和原理之后，不难借助使用其他自己熟悉的语言实现相关功能。 实验者在实验过程中应该侧重写出自己在算法分析、设计思路、实现功能或程序代码等方面的特色，写出设计和实现过程中遭遇到的难点和解决办法，可以不拘泥于实验指导给出的参考性设计思路，尽可能在深度和广度上加以拓展。只有这种各具特色的实验报告，才将更有利于体现实验者在创新思维和动手能力上的差异。 通过这些实验，能使学生对这些部份的工作机理有一个详细的了解，达到“知其然，且知其所以然”的目的。并可在C环境下对自动生成工具生成的词法、语法分析器进行编译调试。 由于手工生成词法和语法分析器的工作量太大，在实际中常用自动生成工具来完成之。这些工具中最著名的当属贝尔实验室的词法分析器生成工具LEX和语法分析器生成工具YACC。它们现已成为UNIX的标准应用程序同UNIX一起发行。与此同时GNU推出与LEX完全兼容的FLEX，与YACC完全兼容的BISON。这两个程序都在Internet上以源代码的形式免费发行，所以很容易在其它操作系统下重新编译安装。我们实验采用的就是for dos的FLEX和BISON。本书有关的编译工具及其源程序例子，可到BISON的网站上下载。关于FLEX和BISON的用法简介，参见附录，如需更详细的介绍，请参阅编译工具中帮助文件。 目 录 实验一 词法分析器设计实验… 1 实验二 用递归下降法实现语法分析实验… 5 实验三 熟悉**FLEX**使用方法… 9 附录一 词法分析器生成工具**FLEX**简介… 13 附录二 语法分析器生成工具**YACC**简介… 20 参考文献… 26 实验一 词法分析器**的设计** 【实验目的】 1． 掌握生成词法分析器的方法，加深对词法分析原理的理解。 2． 掌握设计、编制并调试词法分析程序的思想和方法。 3． 本实验是高级语言程序设计、数据结构和编译原理中词法分析原理等知识的综合。 【实验性质】 综合性实验（学时数：2H） 【实验内容及要求】 1． 设计并实现一个四则运算的计算器,通过命令行方式启动,可以通过键盘输入整个算式,然后直接显示结果。将换行作为分隔符，把输入分隔为一个个算式。 2． 使用C语言设计、编写、调试一个词法分析子程序。 3． 实验前请仔细阅读实验预习提示，已经附有完整的源代码,请在实验报告中画出该分析器所实现的状态转换图。 4． 提交的实验报告中要有实验名称、实验目的、实验内容、实验程序清单、调试过程和运行结果，程序的主要部分做出功能说明，并有实验收获体会或改进意见等内容。 5． 进阶实验:扩展原有计算器,使其可以支持括号和负数运算。 6． 本实验建议学时数为2学时 【实验预习提示】 1.词法分析器的功能和输出格式 词法分析器的功能是输入以字符串表示的源程序，输出单词符号或单词符号序列。词法分析器的单词符号常常表示成以下的二元组(单词的种别码，单词符号的属性值)。本实验是用于计算器的词法分析器，只需处理运算符和数值。 2.“超前搜索”方法 词法分析时，常常会用到超前搜索方法。如当前待分析字符串为“a&gt;+”,当前字符为’&gt;’，此时，分析器倒底是将其分析为大于关系运算符还是大于等于关系运算符呢？显然，只有知道下一个字符是什么才能下结论。于是分析器读入下一个字符’+’，这时可知应将’&gt;’解释为大于运算符。但此时，超前读了一个字符’+’，所以要回退一个字符，词法分析器才能正常运行。 3.词法分析程序主程序的算法思想 算法的基本思想是根据扫描到单词符号的第一个字符的种类，拼写出相应的单词符号，其实现的基本任务是从字符串表示的源程序中识别出相应的具有独立意义的单词符号。主程序示意图如图1.1所示。 ​ ​ 图1.1 词法分析主程序示意图 4.补充知识: (1)避免重复包含。在头文件token.h中，有这样的代码段： #ifndef TOKEN_H_INCLUDED #define TOKEN_H_INCLUDED ​ … #endif 这是为了防止多次用#include包含引起多重定义错误而采用的技巧。头文件用#include包含自己所依赖的其他所有头文件，可以让代码中只需书写一次include,且当依赖关系发生改变时较容易修改。但如果多个头文件这样书写，会报类型或宏的重复定义错误，一次可以采用这个技巧，根据开头的#ifndef语句，避免产生多重定义的错误。 (2)在执行语句sscanf(token-&gt;str,”%lf”,&amp;token-&gt;value);时，会出现null pointer assignment错误，这是因为没有给指针初始化。 5.参考源程序 ​ 实验二 用递归下降法实现语法分析 【实验目的】 1.掌握用递归下降分析法进行语法分析的方法。加深对自顶向下语法分析原理的理解。 2.掌握设计、编制并调试自顶向下语法分析程序的思想和方法。 3.本实验是高级语言程序设计、数据结构和编译原理中词法分析、自顶向下语法分析原理等知 识的综合。由于语法分析是在词法分析的基础上进行的，且词法分析器输出的结果即单词符号 或单词符号序列是语法分析的输入。 【实验性质】 综合性实验（学时数：2H） 【实验要求】 \1. 调用实验一的get_token函数进行词法分析，使用递归下降法作语法分析器，实现计算器的功能。 \2. 实验前请仔细阅读实验预习提示，参考所附完整的源代码,请在实验报告中写出该分析器所使用的语法规则。 \3. 本实验建议学时2学时。 【实验预习提示】 1、 语法分析程序的算法思想 （1） 主程序示意图如图4.1所示。 图4.1 递归下降法语法分析主程序示意图 （2） 递归下降分析程序示意图如图4.2所示。 ​ 图4.2 递归下降分析程序示意图 2.参考源程序parser.c： 实验三 熟悉FLEX使用方法 【实验目的】 1． 掌握FLEX基本使用方法 2． 掌握如何将通过FLEX生成的C语言模块加入到自已的程序中 【实验要求】 1．编制FLEX源程序,分别统计文本文件a.txt中出现的标识符和整数个数,并显示之。标识符定义为字母开头，后跟若干个字母，数字或下划线。整数可以带+或-号，也可不带，且不以0开头。非单词和非整数则忽略不记，将之滤掉不显示。 2．编制一FLEX源程序,分别求出文件hh.c中字母,数字,回车符的个数。 3． 思考：若main函数不在FLEX中实现，应该如何实现？ 4． 本次实验建议学时2学时。 【实验预习提示】 参见附录一。在看懂的基础上将之调试通过。 实验四 用FLEX和BISON自动**实现计算器** 【实验目的】 熟练掌握FLEX和BISON，并通过其生成词法和语法分析器，实现实验一和实验二的加算器功能 【实验要求】 1． 通过FLEX生成一词法分析器函数，其功能同实验一中词法分析器函数类似。 2． 通过BISON生成一语法分析器。参造附录，读懂所附源程序。 3． 生成一工程文件，调用1和2中生成的函数，实现计算器的功能 4． 本实验建议学时2学时。 【实验预习提示】 1． 由于FLEX生成的C程序模块lex.yy.c过于复杂，基本不可读，所以不要直接修改它，可将它看成一个“黑箱”，即不需要清楚知道其内部结构，只需要知道其接口即可。可通过修改FLEX源程序间接修改之。关于lex.yy.c中常用变量和函数，在附录中有详细说明。 2． 编制语法分析器mycalc.y，通过BISON生成y.tab.c和y.tab.h。命令为： bison –yacc –dv mycalc.y 使用BISON代替了YACC,默认生成的文件是mycalc.c和mycalc.h，所以在添加了—yacc参数，可以生成与YACC同名的文件 3． 编制词法分析器mycalc.l，通过FLEX生成lex.yy.c。命令为： flex mycalc.l 4． 生成一工程文件，不妨取名为test.prj，将文件lex.yy.c、y.tab.c和y.tab.h，加入之。源程序参考如下： (1) mycalc.l 附录一 词法分析器生成工具FLEX简介 1． FLEX简介 单词的描述称为模式(Lexical Pattern)，模式一般用正规表达式进行精确描述。FLEX通过读取一个有规定格式的文本文件，输出一个如下所示的C语言源程序。 FLEX的输入文件称为LEX源文件，它内含正规表达式和对相应模式处理的C语言代码。LEX源文件的扩展名习惯上用.l表示。FLEX通过对源文件的扫描自动生成相应的词法分析函数 int yylex()，并将之输出到名规定为lex.yy.c的文件中。实用时，可将其改名为lexyy.c。该文件即为LEX的输出文件或输出的词法分析器。也可将 int yylex()加入自已的工程文件中使用。 2． 模式简介 LEX的模式的格式(也称为规则)是机器可读的正规表达式，正规表达工是用连接、并、闭包运算递归生成的。为了方便处理，LEX在此基础上增加了一些运算。下列是按运算优先级由高往低排列的LEX的正规表达式的运算符。 “[]^-?.*+|()/${}%&lt;&gt; 关于LEX的模式定义，可参见下页附表1.1 3．LEX源文件格式 LEX对源文件的格式要求非常严格，比如若将要求顶行书写的语句变成非顶行书写就会产生致命错误。而LEX本身的查错能力很弱，所以书写时一定要注意。 LEX的源文件由三个部份组成，每个部分之间用顶行的“%%”分割，其格式如下： 定义部份 ％％ 规则部份 ％％ 用户附加C语言部份 ​ 3.1定义部份 定义部份由C语言代码、模式的宏定义、条件模式的开始条件说明三部份组成。 其中，C代码部份由顶行的%{和}%引入，LEX扫描源文件时将%{和}%之间的部分原封不动的拷贝到输出文件lex.yy.c中. 附表1.1 LEX 的模式定义 模 式 解 释 X 匹配单个字符x。(也可将模式写为”x”) . 匹配除换行符’\n’之外的任意字符 [xyz] 匹配x、y或z [abj-oZ] 匹配字符集:a、b、Z以及j到o之间的字母(包括j和o) [^A-Z] 匹配字符集A到Z之间字符集的补集。即除大写字母的其它字符 [^A-Z\n] 匹配除大写字母和换行符之外的其它字符 r* R是正规表达式，r*匹配0个或多个r r+ R是正规表达式，r+匹配1个或多个r r? R是正规表达式，r?匹配0个或1个r r{2,5} R是正规表达式，r{2,5}匹配2个到5个r r{2,} R是正规表达式，r{2,}匹配2个或以上r r{4} R是正规表达式，r{4}匹配4个r {name} name是在定义部份出现的模式宏名，在规则部份将之替换为模式 “[xyz]\”foo” 匹配字符串[xyz]”foo \x 如x是’a’、’b’、’f’、’n’、’r’或’t’，\x为转义字符，定义同ANSI C,否则，匹配字符x.此方法用于匹配正规表达式的运算符 \123 匹配八进制ASCII码为123的字符 \x2a 匹配十六进制ASCII码为2a的字符 (r) 匹配r,优先运算正规式r Rs 匹配正规式r和s的连接 r\ s 匹配正规式r或s r/s 匹配正规式r,但是，r之后一定要出现正规式s。称s为r的尾部条件 ^r 匹配正规式r,但是，r一定要出现在行首 r$ 匹配正规式r,但是，r一定要出现在行尾 r 匹配正规表达式r,但是一定要在开始条件s激活之后 &lt;&gt; 匹配文件结束标志 模式的宏定义部份如同C语言中的宏定义，通过宏名定义一个模式，这样，可以简化在源文件中多次出现的正规表达式的书写。格式为： 宏名1 宏定义1 宏名2 宏定义2 …… 例如： DIGIT [0-9] ID [A-Za-z][A-Za-z0-9_]* 宏名是以字母和下划线”_”开始，以字母、数字和下划线组成的字符串，且大小写敏感。宏名必须顶行写，宏名和宏定义必须写在同一行上。宏名和宏定义之间以不包括换行符的白字符(空格符、TAB符、换行符)隔开。 条件模式的开始条件说明格式如下： ％start s1 s2 s3 其中，s1、s2、s3为条件名。必须为大小写敏感的标识符。关于条件模式的使用，我们将在后面作说明。 3.2 规则部份 规则部份是LEX源文件的核心部份，它包括一组模式和在生成分析器识别相应模式后对相应模式进行处理的C语言动作(Action)。格式如下 C语言代码 模式1 动作1 模式2 | 模式3 动作3 …… 同定义部分一样，C语言代码必须出现在第一个模式之前，包括在%{和}%之中，且%{必须顶行书写。%{和}%之间的代码部份可用来定义yylex()用到的局部变量。 模式必须顶行书写。模式可为正规式或用{}括起且在定义部份定义过的宏名。动作为用{}括起的C代码。且开始括号{与模式之间用白字符隔开，且须和模式在同一行上。注意，在模式后加一|表示模式2和3采用同一动作3.|和模式2以白字符隔开。 3.3用户附加C语言部份 LEX对此部份不作任何处理，仅仅将之直接拷贝到输出文件lex.yy.c的尾部。在些部份，可定义对模式进行处理的C语言函数、主函数和yylex要调用的函数yywrap()等。如果用户在其它C模块中提供这些函数，用户代码部份可以省略。 3.4 源文件格式小结 综上所述，LEX源文件详细格式如下： %{ ​ /此模块为定义模块中Ｃ语言代码部份，在下面填入相应C代码/ }% 模式宏名1 模式1 模式宏名2 模式2 …… %start s1 s2 s3 %% %{ /此模块为规则模块中Ｃ语言代码部份，在下面填入相应C代码/ }% 模式1 动作1 模式2 动作2 …… %% /此模块为用户附加C语言部份，在下面填入相应C代码/ 注意：以上三部份及其中任何一子部份，均可省去。且如无第三部分，第二个%%也可省去，但第一个%%决不可省。 ４．LEX的工作原理 LEX通过对源文件的扫描，经过宏替换后，将规则部份的正规表达式转换成与之相应的DFA，并由之产生一个名为int yylex()的词法分析函数，将之拷贝到输出文件lex.yy.c中。由于考虑到C代码的可移植性和运行效率问题，lex.yy.c中大量使用了宏定义，且文件较大(30-50kb)。因此，几乎是不可读的。但是，其可移植性相当好。 lex.yy.c中定义了很多用户可定义的全局变量，以及在LEX源文件的动作中可调用的函数和宏。但是，由于lex.yy.c太过复杂，建议初学者不要随意修改它。用户在了解其的前提下，可在其它C模块中引用之。 ５．二义性问题的解决 yylex()函数被调用之后，它首先检查全局文件指针变量yyin是否有定义，如有，则将之设置为将要扫描的文件指针。如无，则设置为标准输入文件stdin.同理，如全局文件指针变量yyout无定义，则将之设置为标准输出文件stdout。 ​ 若有多个模式与被扫描文件中的字符串相匹配，则yylex()执行能匹配最长字符串的模式，称为“最长匹配原则”；若还有多个模式匹配长度相同的字符串，则yylex()选择在LEX源文件中排列最前面的模式进行匹配，称为“最先匹配原则”。yylex()常通过超前搜索一个字符来实现这样的原则，如果使用超前搜索匹配了某一模式，则yylex()在进行下一次分析前，将回退一个字符。见下例： %% ​ program {printf(“keyword:%s!\n”,yytext); /模式一/} ​ procedure {printf(“keyword:%s!\n”,yytext); /模式二/} ​ [a-z][a-z0-9] {printf(“identifier:%s!\n”,yytext); /模式三*/} ​ %% ​ 如输入串为”programming”，yylex()分析到子串”program”时，有模式一和三可以匹配，但根据最长搜索原则，发现在继续读入输入串时，还可匹配模式三。这样，将输出”identifier:programming!”。如输入串为”program”,则按最先匹配原则，模式一与之匹配，输出”keyword:program!”。注意，若将模式一和模式三在源文件中次序弄反，则模式一永远也得不到匹配。 若无模式可匹配输入串，则使用缺省规则，即将输入串原样拷贝至输出文件yyout中。 ６．常用全局变量和宏 ​ lex.yy.c中常用全局变量、函数和宏很多，在此仅指出一些最常用的，若需要更详细信息，请阅读源文件。 (1) FILE yyin,yyout:为指向字符输入和结果输出文件的指针。如用户未对其定义，则设为标准输入文件stdin和stdout。 (2) int yylex():为词法分析程序，它自动移动文件指针yyin和yyout。在定义模式动作时，用户可用return语句结束yylex(),return 必须返回一整数。由于yylex()的运行环境都是以全局变量的方式保存，因此，在下一次调用yylex()时，yylex()可从上次扫描的断点处继续扫描，在语法分析时，可利用这一特性。若用户未定义相应的return语句，则yylex()继续分析被扫描的文件，直到碰到文件结束标志EOF。在读到EOF时，yylex()调用int yywrap()函数(该函数用户必须提供)，若该函数返回非0值，则yylex()返回0而结束。否则，yylex()继续对yyin指向的文件扫描。 (3) char *yytext:存放当前被识别的词形。 (4) int yyleng:存放字符串yytext的长度。 (5) int yywrap():参见(2) (6) yymore()：将当前识别的词形保留在yytext中，分析器下次扫描时的词形将加追加在yytext中。例模式定义如下 …… hello {printf(“%s!”,yytext);yymore();} world {printf(“%s!”,yytext);} …… 当输入串为”helloworld”时，将输出”hello!helloworld!” (7) yyless(int n):回退当前识别的词形中n个字符到输入中 (8) unput(char c):回退字符c到输入，它将作为下一次扫描的开始字符 (9) input():让分析器从输入缓冲区中读取当前字符，并将yyin指向下一字符 (10) yyterminate():中断对当前文件的分析，将yyin指向EOF。 (11) yyrestart(FILE * file):重新设置分析器的扫描文件为file (12) ECHO:将当前识别的字符串拷贝到yyout (13) BEGIN:激活开始条件对应的模式 (14) REJECT:放弃当前匹配的字符串和当前的模式，让分析器重新扫描当前的字符串，并选择另一个最佳的模式再次进行匹配。 7.条件模式 LEX提供控制模式在一定状态下使用的功能，称为条件模式。LEX首先在定义部份通过%start来定义条件句。在规则部份可通过宏 BEGIN 条件名 来激活条件。BEGIN INITIAL或BEGIN 0将休眠所有的条件模式，使分析器回到开始状态。 例：将输入文件中的单词”magic” 作如下处理：识别”magic”时，如”magic”所在行行首为字符’a’,则输出”first”;若为’b’,则输出”second”;否则，输出”magic”。如不用条件模式，LEX源文件可这样写： %{int flag;}% %% ^a {flag=’a’;ECHO;} ^b {flag=’b’;ECHO;} \n {flag=0;ECHO;} magic { ​ switch(flag) ​ { ​ case ‘a’:printf(“first”);break; ​ case ‘b’:printf(“second”);break; ​ default :ECHO;break; ​ } ​ ​ } %% 如使用条件模式,则上述源文件可简化为 %start AA BB CC %% ^a {ECHO;BEGIN AA;} ^b {ECHO;BEGIN BB;} \n {ECHO;BEGIN 0;} magic {printf(“first”);} magic {printf(“second”);} %% 8．示例 例一：编制LEX源程序,分别统计文本文件a.txt中出现的标识符和整数个数,并显示之。标识符定义为字母开头，后跟若干个字母，数字或下划线。整数可以带+或-号，也可不带，且不以0开头。非单词和非整数则忽略不记，将之滤掉不显示。 设LEX源文件名为count.l.文件内容如下 ​ ​ %{ ​ #include “stdio.h” ​ #include “stdlib.h” ​ int num_num=0,num_id=0; %} INTEGER [-+]?[1-9][0-9]* ID [a-zA-Z][a-zA-Z_0-9]* SPACE [ \n\t] %% {INTEGER} { num_num++; ​ printf(“(num=%d)”,atoi(yytext));//打印数字值 ​ /数字数加一/ ​ } {ID} { ​ num_id++; ​ printf(“(id=%s)”,yytext); ​ } {SPACE} | . { ​ //什么也不做,滤掉白字符和其它字符 ​ } %% void main() { ​ yylex(); ​ printf(“num=%d,id=%d”,num_num,num_id); } int yywrap()//此函数必须由用户提供 {return 1;} 设count.l所在目录为c:\test，且已用path命令指定flex.exe所在目录。则调用命令 c:\test&gt; flex count.l后可在c:\test目录下得到一文件lex.yy.c，打开C环境，新建工程文件my.prj(TURBOC 或BORLAND C下后缀为.prj，VC下后缀为.dsw),将lex.yy.c加入工程文件中,编译运行可得可执行文件my.exe.若需分析从标准输入中输入的字符串,运行my.exe即可.若需分析放在其它文件中的串,如设在文件hello.txt中,则运行my.exe&lt;hello.txt即可. 例2:编制一LEX源程序,分别求出文件hh.c中字母,数字,回车符的个数.源程序如下: %{ #include “stdio.h” #include “stdlib.h” int num_digit=0,num_letter=0,num_enter=0; %} DIGIT [0-9] LETTER [A-Za-z] %% {DIGIT} {num_digit++;} {LETTER} {num_letter++;} \n {num_enter++;} . {/其它字符不作处理/} %% void main() { yyin=fopen(”hh.c”,r); yylex(); printf(“num=%d,letter=%d,enter=%d”, ​ num_digit,num_letter,num_enter); } int yywrap()//此函数必须由用户提供 { return 1; } 附录二 语法分析器生成工具YACC简介 1．YACC简介 YACC是语法分析器生成工具中最著名的，也是最早开发出来的一个。该工具和LEX都是源于贝尔实验室的UNIX计划，如今YACC也成为了UNIX系统的标准实用程序。它大大地简化了在语法分析器设计时的手工劳动，将程序设计语言编译器的设计重点放在语法制导翻译上来，从而方便了编译器的设计和对编译器代码的维护。Berkeley大学开发了和YACC完全兼容，但代码完全不一样的语法分析器生成工具BYACC，GNU也推出了和YACC兼容的语法分析器生成工具BISON，这也是我们实验时使用的工具，通过这个软件，我们可以学习YACC。 ​ 语法分析是对输入文件第二次重组，输入文件是有序的字符串，词法分析是第一次重组，即将有序的字符串转换成单词序列；而语法分析则是在第一次重组的基础上将单词序列转换为语句，它使用的是上下无关文法的形式规则。正如我们所知，一般的程序设计语言的形式方法大多是LALR（1）文法，它是上下无关文法的一个子类。多数程序设计语言的语法分析都采用LALR（1）分析表，YACC也正是以LALR（1）文法为基础。类似于LEX，它通过对输入的形式文法规则进行分析产生LALR（1）分析表，输出以该分析表驱动的语法分析器C语言源程序。YACC的输入文件称为YACC 源文件，它包含一组以巴克斯-鲁尔范式（BNF）书写的形式文法规则以及对每条规则进行语义处理的C语言语句。YACC源文件的文件后缀名一般用.y表示。YACC的输出文件一般有两个，在BISON下：一个是后缀为.c的包含有语法分析函数int yyparse()的C语言源程序xxx.tab.c(其中xxx是源文件的文件名)，称为输出的语法分析器；另一个是包含有源文件中所有终结符(词法分析中的单词)编码的宏定义文件xxx.tab.h(当BISON加参数-d时生成)，称为输出的单词宏定义头文件。 2．YACC的源文件格式 YACC的源文件部分由三个部分组成，即 定义部分 %% 语法规则部分 %% 用户附加C语言代码部分 不象LEX对源文件格式有严格的要求，任何YACC指令都可以非顶行书写。在介绍YACC源文件格式之前，先来回顾有关形式语法的基本概念。 (1) 单词和非终结符。 在YACC源文件中，有两种方式表示的单词（终结符）：一种是在定义部分通过YACC指令%token定义文法中出现的单词，称为有名单词，如%token NUMBER就定义了一有名单词NUMBER，可用它来表示整数的种别码；另一种是单个字符，称为字符单词，如单个字符’+’、’-’,’a’,’4’,’!’等，它们本身作为终结符出现在规则部分，不需要在定义部分说明，可直接加单引使用，如同C语言的字符常量。 非终结符一般为不加引号的标识符，习惯上用小写字母组成的字符串表示。如可用exp表示用来表示表达式的非终结符。 YACC在对源文件进行编译时，将对所有的单词和非终结符进行编码，并用该编码建立分析表和语法分析器。单词的编码原则是：字符单词使用其对应的ASCII码，有名单词则由分析器进行编码。用户在对有名单词进行命名时，一定要注意不要和使用该单词名的C源程序中已有的宏名相同，否则在编译该C模块时是会产生宏定义冲突的。 (2) 定义部分 YACC的定义部分比LEX复杂，在此并未给出其全部规则，只是给出了实验中要用到的部分。有兴趣的同学可以查阅有关资料或与我们联系。 定义部分结构如下： %{C语言代码部分%} 语义值数据类型定义 单词定义 非终结符定义 优先级定义 其中，C语言代码部分同LEX，语义值数据类型定义部分定义了进行语法分析时语义栈中元素的数据类型，可用宏YYSTYPE定义。本书例中数据类型为double型(算术表达式的语义值)，可直接将之放入到C语言代码部分中，如可在C语言代码部分中加入一句#define YYSTYPE double。非终结符一般不需要作声明，在此略过不谈。 结合次序和优先级别的定义，将让YACC在编译源文件时，面对由文法的二义性引起的移进-归约冲突时，能正确的选择移进或归约。如我们知道，二元’+’和’-‘的优先级低于’*’和’/’，它们优先级又都低于一元减(取负)’-‘,且它们都是左结合的，则我们可以这么定义： %left ‘+’ ‘-‘ %left ‘*’ ‘/’ %left UMINUS /虚拟单词，它和一元减有相同的优先级别和结合次序/ 上面的定义说明了它们的优先级，规则是越在后面定义的优先级越高。而%left说明了是左结合的。注意一元减用了个虚拟单词UMINUS。在规则部分，对一元减作如下处理： exp : | ‘-‘ exp %prec UMINUS …… 说明了一元减’-’就是前面定义的UMINUS。 这样就区别了同一算符在不同上下文环境中的优先级别和结合次序。 (3) 语法规则部分 YACC利用BNF范式定义形式语言的递归生成规则。YACC采用下述符号作为每个产生式的控制符号： 冒号‘：’分割产生式的左右两个部份；竖杠‘|’分割同一非终结符对应的多条规则；分号‘;’结束一个产生式。注意：在书写语法规则时一定要区别单词、非终结符和上述控制符号，否则将会导致出错。综上，每个产生式的规则如下： 非终结符： 规则一 ​ | 规则二 ​ ……… ​ |规则n 其中，每个规则是由单词和非终结符组成的语法符号串，每个语法符号用白字符分隔。如产生式exp-&gt;exp+exp|exp-expNUM可表示为 exp: exp ‘+’ exp | exp ‘-‘ exp | NUM ; 规则部分可以是空串，如产生式input-&gt;ε可表示为 input : /空串/ ; 加注释的目的是为了便于阅读。 YACC最欢迎的是左递归文法，而用右递归文法则可能会导致分析栈溢出，故要尽量避免用右递归文法。 3．语义定义 ​ YACC输出的分析器不仅要识别形式语言，更重要的是要完成语义的翻译。YACC提供一种语法规则制导语义定义的功能，它通过在源程序的语法规则中嵌入求解语义值或者完成相应语义动作的C语言代码，从而定义每个语法规则的语义。 ​ ​ (1)单词（终结符）语义值的计算 输出分析函数int yyparse()在需要向前查看单词或者移进一个单词时将调用函数int yylex(),此函数可通过由词法分析器自动生成，也可手动生成。本书中两例比较简单，采用的是手动生成int yylex（）的方法。用户必须在yylex（）中计算出当前单词的语义值，将该值保存在YACC输出的分析器提供的一个类型是YYSTYPE的全局变量yylval中。注意yyparse()在移进一个单词到分析栈的同时，将yylval的值拷贝到语义栈中。我们不用管yylval是如何进栈的，只需知道,一旦在yylex()中将一个值赋给yylval后，yyparse()每调用yylex()一次,就将yylval进栈一次。 ​ (2)非终结符语义值的计算 计算非终结符的语义值一般随归约动作同时进行，由于归约是利用语法规则进行归约的，所以YACC提供在每个语法规则的尾部附加C语言代码的功能，称为语义动作，当分析器用该规则进行归约时，将执行该段代码。利用这段代码和语义栈中已知语法符号的语义值，可完成对归约的非终结符的语义值的计算。语义动作由花括号引入，格式如下： 非终结符: 规则一 {动作一} ​ | 规则二 {动作二} ​ ……. ​ | 规则n {动作n} ​ ; YACC提供一种简单的方式让用户在语义动作中访问语义栈中栈顶元素的语义值。设当前规则中有n个语法符号，如： 非终结符: S1 S2 ……Sn 对以上产生式进行归约时，语义栈自底向顶分别排列为……S1,S2,……Sn，其相应的语义值可用……$1，$2……$n表示，非终结符对应的语义值用$$表示，在完成语义分析动作，即对$$的处理后，将$$的内容拷贝到语义栈中。如： exp : …… ​ | exp ‘+’ exp {$$=$1+$3;} ; 其中，$1和$3分别表示规则中第一个和第二个exp的语义值，$$表示非终结符exp的语义值。 4．其它 YACC的语法比较复杂，用法也很灵活，如它和LEX之间预留的接口是一样的，所以还可以和LEX直接结合使用。这些内容本书均未谈及，留待有兴趣的同学自己查阅有关资料。 5．示例 例一：用YACC生成逆波兰表示计算器 分析：逆波兰表达式文法可定义为 exp-&gt;exp exp + |exp exp – |exp exp * |exp exp / | exp exp ^ |exp n |NUM ​ 其中，’^’为乘幂符号,’n’为一元减,此文法为无二义性文法。 ​ 其YACC源程序(不妨取名为rpcalc1.y)如下 ​ %{ #define YYSTYPE double/ 定义表达式语义值为double型/ #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;ctype.h&gt; %} %token NUM /定义有名单词NUM，用来表示数的种别码/ %% input: /可为空串/ ​ |input line ​ ; line: ‘\n’ ​ |exp ‘\n’ {printf(“\t%10.g\n”,$1);} ​ ; exp: NUM {$$=$1;} ​ |exp exp ‘+’ {$$=$1+$2;} ​ |exp exp ‘-‘ {$$=$1-$2;} ​ |exp exp ‘‘ {$$=$1$2;} ​ |exp exp ‘/‘ {$$=$1/$2;} ​ |exp exp ‘^’ {$$=pow($1,$2);} ​ |exp ‘n’ {$$=-$1;} ​ ; %% main() { printf(“\nPlease input your expression,end with ENTER &amp;&amp; CTRL+Z:\n”); yyparse(); } yyerror(char *s) /此函数必须给出，为yyparse()出错时调用/ { printf(“error=%s”,s); } int yylex() /用户手编的词法分析器/ { int c; while((c=getchar())==’ ‘|| c==’\t’); if(c==’.’ || isdigit(c)) ​ { ​ ungetc(c,stdin); ​ scanf(“%lf”,&amp;yylval);/单词为数，将此数的值存入yylval/ ​ return NUM;/返回种别码/ ​ } if(c==EOF) ​ return 0; return c;/其它单个字符则返回其本身，因为其本身就是自己的编码/ } 在DOS提示符下运行 C:>bison rpcalc1.y –d 则在当前目录下生成新文件rpcalc1.tab.c，用TURBOC编译该文件，产生可执行文件rpcalc1.tab.exe。执行该文件 C:>rpcalc1.tab 则运行结果如下： Please input your expression,end with ENTER &amp;&amp; CTRL+Z: 12 35 + 47 例二：用YACC生成中缀表达式计算器 分析 中缀表达式产生式为 exp-&gt;exp + exp | exp - exp| exp * exp |exp / exp |exp ^ exp | - exp |(exp) |NUM 此文法是一个二义性文法，可通过设立结合性和优先次序来消除二义性。则YACC源程序(rpcalc2.y)如下: %{ #define YYSTYPE double #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;ctype.h&gt; %} %token NUM %left ‘-‘’+’ %left ‘*’’/‘ %left UMINUS /虚拟单词，它和一元减有相同的优先级别/ %right ‘^’ /上面代码定义了结合性和优先级/ %% input: /empty string/ ​ |input line ​ ; line: ‘\n’ ​ |exp ‘\n’ {printf(“\t%10.g\n”,$1);} ​ ; exp: NUM {$$=$1;} ​ |exp ‘+’ exp {$$=$1+$3;} ​ |exp ‘-‘ exp {$$=$1-$3;} ​ |exp ‘‘ exp {$$=$1$3;} ​ |exp ‘/‘ exp {$$=$1/$3;} ​ |exp ‘^’ exp {$$=pow($1,$3);} ​ |’-‘ exp %prec UMINUS {$$=-$2;} ​ |’(‘exp’)’{$$=$2} ​ ; %% /用户代码部分同例一相应部分，在此省略不写/ 参考文献 [1] 胡伦骏，徐兰芳，刘建农编.编译原理.电子工业出版社,2002,3 [2] 吕映芝，张素琴，蒋维杜.编译原理,1998,1]]></content>
      <categories>
        <category>编译原理实验</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理实验指导书]]></title>
    <url>%2F2019%2F04%2F18%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[实验一 词法分析器**的设计** 【实验目的】 1． 掌握生成词法分析器的方法，加深对词法分析原理的理解。 2． 掌握设计、编制并调试词法分析程序的思想和方法。 3． 本实验是高级语言程序设计、数据结构和编译原理中词法分析原理等知识的综合。 【实验性质】 综合性实验（学时数：2H） 【实验内容及要求】 1． 设计并实现一个四则运算的计算器,通过命令行方式启动,可以通过键盘输入整个算式,然后直接显示结果。将换行作为分隔符，把输入分隔为一个个算式。 2． 使用C语言设计、编写、调试一个词法分析子程序。 3． 实验前请仔细阅读实验预习提示，已经附有完整的源代码,请在实验报告中画出该分析器所实现的状态转换图。 4． 提交的实验报告中要有实验名称、实验目的、实验内容、实验程序清单、调试过程和运行结果，程序的主要部分做出功能说明，并有实验收获体会或改进意见等内容。 5． 进阶实验:扩展原有计算器,使其可以支持括号和负数运算。 6． 本实验建议学时数为2学时 【实验预习提示】 1.词法分析器的功能和输出格式 词法分析器的功能是输入以字符串表示的源程序，输出单词符号或单词符号序列。词法分析器的单词符号常常表示成以下的二元组(单词的种别码，单词符号的属性值)。本实验是用于计算器的词法分析器，只需处理运算符和数值。 2.“超前搜索”方法 词法分析时，常常会用到超前搜索方法。如当前待分析字符串为“a&gt;+”,当前字符为’&gt;’，此时，分析器倒底是将其分析为大于关系运算符还是大于等于关系运算符呢？显然，只有知道下一个字符是什么才能下结论。于是分析器读入下一个字符’+’，这时可知应将’&gt;’解释为大于运算符。但此时，超前读了一个字符’+’，所以要回退一个字符，词法分析器才能正常运行。 3.词法分析程序主程序的算法思想 算法的基本思想是根据扫描到单词符号的第一个字符的种类，拼写出相应的单词符号，其实现的基本任务是从字符串表示的源程序中识别出相应的具有独立意义的单词符号。主程序示意图如图1.1所示。 ​ ​ 图1.1 词法分析主程序示意图 4.补充知识: (1)避免重复包含。在头文件token.h中，有这样的代码段： #ifndef TOKEN_H_INCLUDED #define TOKEN_H_INCLUDED ​ … #endif 这是为了防止多次用#include包含引起多重定义错误而采用的技巧。头文件用#include包含自己所依赖的其他所有头文件，可以让代码中只需书写一次include,且当依赖关系发生改变时较容易修改。但如果多个头文件这样书写，会报类型或宏的重复定义错误，一次可以采用这个技巧，根据开头的#ifndef语句，避免产生多重定义的错误。 (2)在执行语句sscanf(token-&gt;str,”%lf”,&amp;token-&gt;value);时，会出现null pointer assignment错误，这是因为没有给指针初始化。 5.参考源程序 token.h 12345678910111213141516171819202122232425#ifndef TOKEN_H_INCLUDED#define TOKEN_H_INCLUDEDtypedef enum&#123; BAD_TOKEN, NUMBER_TOKEN, ADD_OPERATOR_TOKEN, SUB_OPERATOR_TOKEN, MUL_OPERATOR_TOKEN, DIV_OPERATOR_TOKEN, END_OF_LINE_TOKEN&#125;TokenKind;#define MAX_TOKEN_SIZE 100typedef struct &#123; TokenKind kind; double value; char str[MAX_TOKEN_SIZE];&#125;Token;void set_line(char *line);void get_token(Token *token);#endif lexicanalyzer.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include"token.h"static char *st_line;static int st_line_pos;typedef enum&#123; INITIAL_STATUS, IN_INT_PART_STATUS, DOT_STATUS, IN_FRAC_PART_STATUS&#125;LexerStatus;void get_token(Token *token)&#123; int out_pos=0; LexerStatus status=INITIAL_STATUS; char current_char; char ste[MAX_TOKEN_SIZE]; token-&gt;kind=BAD_TOKEN;while(st_line[st_line_pos]!='\0')&#123; current_char=st_line[st_line_pos]; if((status==IN_INT_PART_STATUS || status==IN_FRAC_PART_STATUS) &amp;&amp; !isdigit(current_char) &amp;&amp; current_char !='.')&#123; token-&gt;kind=NUMBER_TOKEN; sscanf(token-&gt;str,"%lf",&amp;token-&gt;value); return; &#125; if(isspace(current_char))&#123; if(current_char=='\n')&#123; token-&gt;kind=END_OF_LINE_TOKEN; return; &#125; st_line_pos++; continue; &#125; if(out_pos&gt;=MAX_TOKEN_SIZE-1)&#123; fprintf(stderr,"token too long.\n"); exit(1); &#125; token-&gt;str[out_pos]=st_line[st_line_pos]; st_line_pos++; out_pos++; token-&gt;str[out_pos]='\0'; if(current_char=='+')&#123; token-&gt;kind=ADD_OPERATOR_TOKEN; return; &#125;else if(current_char=='-')&#123; token-&gt;kind=SUB_OPERATOR_TOKEN; return; &#125; else if(current_char=='*')&#123; token-&gt;kind=MUL_OPERATOR_TOKEN; return; &#125; else if(current_char=='/')&#123; token-&gt;kind=DIV_OPERATOR_TOKEN; return; &#125;else if(isdigit(current_char))&#123; if(status==INITIAL_STATUS)&#123; status=IN_INT_PART_STATUS; &#125;else if(status==DOT_STATUS)&#123; status=IN_INT_PART_STATUS; &#125; &#125;else if(current_char==".")&#123; if(status=IN_INT_PART_STATUS)&#123; status=DOT_STATUS; &#125;else &#123; fprintf(stderr,"syntax error.\n"); exit(1); &#125; &#125;else &#123; fprintf(stderr,"bad character(%c)\n",current_char); &#125;&#125; &#125;void set_line(char *line)&#123; st_line=line; st_line_pos=0;&#125;void parse_line(char *buf)&#123; Token token; char str[MAX_TOKEN_SIZE]; set_line(buf); for(;;)&#123; get_token(&amp;token); if(token.kind==END_OF_LINE_TOKEN)&#123; break; &#125;else &#123; printf("kind..%d,str..%s\n",token.kind,token.str); if(token.kind=NUMBER_TOKEN) sscanf(token.str,"%lf",&amp;token.value); &#125; &#125;&#125;int main()&#123; char buf[1024]; while(fgets(buf,1024,stdin)!=NULL)&#123; parse_line(buf); &#125; return 0;&#125; 实验二 用递归下降法实现语法分析 【实验目的】 1.掌握用递归下降分析法进行语法分析的方法。加深对自顶向下语法分析原理的理解。 2.掌握设计、编制并调试自顶向下语法分析程序的思想和方法。 3.本实验是高级语言程序设计、数据结构和编译原理中词法分析、自顶向下语法分析原理等知 识的综合。由于语法分析是在词法分析的基础上进行的，且词法分析器输出的结果即单词符号 或单词符号序列是语法分析的输入。 【实验性质】 综合性实验（学时数：2H） 【实验要求】 \1. 调用实验一的get_token函数进行词法分析，使用递归下降法作语法分析器，实现计算器的功能。 \2. 实验前请仔细阅读实验预习提示，参考所附完整的源代码,请在实验报告中写出该分析器所使用的语法规则。 \3. 本实验建议学时2学时。 【实验预习提示】 1、 语法分析程序的算法思想 （1） 主程序示意图如图4.1所示。 图4.1 递归下降法语法分析主程序示意图 （2） 递归下降分析程序示意图如图4.2所示。 ​ 图4.2 递归下降分析程序示意图 2.参考源程序parser.c： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include"token.h"#include"lexicanalyzer.c"#define LINE_BUF_SIZE 1024static Token st_look_abead_token;static int st_look_abead_token_exists;static void my_get_token(Token *token)&#123; if (st_look_abead_token_exists)&#123; *token = st_look_abead_token; st_look_abead_token_exists = 0; &#125; else &#123; get_token(token); &#125;&#125;static void unget_token(Token *token)&#123; st_look_abead_token = *token; st_look_abead_token_exists = 1;&#125;//double parse_expression();static double parse_primary_expression()&#123; Token token; my_get_token(&amp;token); if (token.kind==NUMBER_TOKEN) &#123; return token.value; &#125; fprintf(stderr, "syntax error.\n"); exit(1); return 0.0;&#125;static double parse_term()&#123; double v1; double v2; Token token; v1 = parse_primary_expression(); while (1)&#123; my_get_token(&amp;token); if (token.kind != MUL_OPERATOR_TOKEN &amp;&amp; token.kind != DIV_OPERATOR_TOKEN)&#123; unget_token(&amp;token); break; &#125; v2 = parse_primary_expression(); if (token.kind == MUL_OPERATOR_TOKEN) v1 *= v2; else if (token.kind == DIV_OPERATOR_TOKEN) v1 /= v2; &#125; return v1;&#125;double parse_expression()&#123; double v1; double v2; Token token;v1 = parse_term();while (1)&#123; my_get_token(&amp;token); if (token.kind != ADD_OPERATOR_TOKEN &amp;&amp; token.kind != SUB_OPERATOR_TOKEN)&#123; unget_token(&amp;token); break; &#125; v2 = parse_term(); if (token.kind == ADD_OPERATOR_TOKEN) v1 += v2; else if (token.kind == SUB_OPERATOR_TOKEN) v1 -= v2; else unget_token(&amp;token);&#125;return v1; &#125;double parse_line()&#123; double value; st_look_abead_token_exists = 0; value = parse_expression(); return value;&#125;int main()&#123; char line[LINE_BUF_SIZE]; double value; while (fgets(line, LINE_BUF_SIZE, stdin) != NULL)&#123; set_line(line); value = parse_line(); printf("&gt;&gt;%f\n", value);&#125;return 0; &#125;]]></content>
      <categories>
        <category>编译原理实验</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate框架]]></title>
    <url>%2F2019%2F04%2F17%2FHibernate%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Hibernate（开放源代码的对象关系映射框架）Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的JaveEE架构中取代CMP，完成数据持久化的重任。 发展历程2001年，澳大利亚墨尔本一位名为Gavin King的27岁的程序员，上街买了一本SQL编程的书，他厌倦了实体bean，认为自己可以开发出一个符合对象关系映射理论，并且真正好用的Java持久化层框架，因此他需要先学习一下SQL。这一年的11月，Hibernate的第一个版本发布了。 2002年，已经有人开始关注和使用Hibernate了。 2003年9月，Hibernate开发团队进入JBoss公司，开始全职开发Hibernate，从这个时候开始Hibernate得到了突飞猛进的普及和发展。 2004年，整个Java社区开始从实体bean向Hibernate转移，特别是在Rod Johnson的著作《Expert One-on-One J2EE Development without EJB》出版后，由于这本书以扎实的理论、充分的论据和详实的论述否定了EJB，提出了轻量级敏捷开发理念之后，以Hibernate和Spring为代表的轻量级开源框架开始成为Java世界的主流和事实标准。在2004年Sun领导的J2EE5.0标准制定当中的持久化框架标准正式以Hibernate为蓝本。 2006年，J2EE5.0标准正式发布以后，持久化框架标准Java Persistent API（简称JPA）基本上是参考Hibernate实现的，而Hibernate在3.2版本开始，已经完全兼容JPA标准。 [1] 编程开发编程环境Hibernate是一个以LGPL（Lesser GNU Public License）许可证形式发布的开源项目。在Hibernate官网上有下载Hibernate包的说明。Hibernate包以源代码或者二进制的形式提供。 [1] 编程工具Eclipse ：一个开放源 代码的、基于Java的可扩展开发平台。 [2] NetBeans：开放源码的Java集成开发环境，适用于各种客户机和Web应用。 IntelliJ IDEA：在代码自动提示、代码分析等方面的具有很好的功能。 [3] MyEclipse：由Genuitec公司开发的一款商业化软件，是应用比较广泛的Java应用程序集成开发环境。 [4] EditPlus：如果正确配置Java的编译器“Javac”以及解释器“Java”后，可直接使用EditPlus编译执行Java程序。 [5] 语言特点 将对数据库的操作转换为对Java对象的操作，从而简化开发。通过修改一个“持久化”对象的属性从而修改数据库表中对应的记录数据。 提供线程和进程两个级别的缓存提升应用程序性能。 有丰富的映射方式将Java对象之间的关系转换为数据库表之间的关系。 屏蔽不同数据库实现之间的差异。在Hibernate中只需要通过“方言”的形式指定当前使用的数据库，就可以根据底层数据库的实际情况生成适合的SQL语句。 非侵入式：Hibernate不要求持久化类实现任何接口或继承任何类，POJO即可。 核心APIHibernate的API一共有6个，分别为:Session、SessionFactory、Transaction、Query、Criteria和Configuration。通过这些接口，可以对持久化对象进行存取、事务控制。 Session Session接口负责执行被持久化对象的CRUD操作(CRUD的任务是完成与数据库的交流，包含了很多常见的SQL语句)。但需要注意的是Session对象是非线程安全的。同时，Hibernate的session不同于JSP应用中的HttpSession。这里当使用session这个术语时，其实指的是Hibernate中的session，而以后会将HttpSession对象称为用户session。 SessionFactory SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。 Transaction Transaction 接口是一个可选的API，可以选择不使用这个接口，取而代之的是Hibernate 的设计者自己写的底层事务处理代码。 Transaction 接口是对实际事务实现的一个抽象，这些实现包括JDBC的事务、JTA 中的UserTransaction、甚至可以是CORBA 事务。之所以这样设计是能让开发者能够使用一个统一事务的操作界面，使得自己的项目可以在不同的环境和容器之间方便地移植。 Query Query接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL语言或本地数据库的SQL语句。Query经常被用来绑定查询参数、限制查询记录数量，并最终执行查询操作。 Criteria Criteria接口与Query接口非常类似，允许创建并执行面向对象的标准化查询。值得注意的是Criteria接口也是轻量级的，它不能在Session之外使用。 Configuration Configuration 类的作用是对Hibernate 进行配置，以及对它进行启动。在Hibernate 的启动过程中，Configuration 类的实例首先定位映射文档的位置，读取这些配置，然后创建一个SessionFactory对象。虽然Configuration 类在整个Hibernate 项目中只扮演着一个很小的角色，但它是启动hibernate 时所遇到的第一个对象。 版本Hibernate版本 Hibernate版本更新速度很快，目前为止有多个阶段性的版本：Hibernate3，Hibernate4和Hibernate5，这一点程序员从其Jar文件名便可以看出来。目前(2018-01-10)最新发布的版本是Hibernate ORM 5.2.12.Final Released。 Hibernate2系列的最高版本是Hibernate2.1.8，Hibernate3系列的最高版本是hibernate-distribution-3.6.10.Final-dist版，但使用较多且较稳定的版本是Hibernate 3.1.3或Hibernate 3.1.2。 另外，自Hibernate3发布以来，其产品线愈加成熟，相继出现了Hibernate注释、Hibernate实体管理器、Hibernate插件工具等一系列产品套件。在方便程序员使用Hibernate进行应用程序的开发的同时，也逐渐增强了Hibernate产品线的实力。 目前Hibernate已经出现了4.0以及5.0的版本 主键介绍Assigned Assigned方式由用户生成主键值，并且要在save()之前指定否则会抛出异常 特点：主键的生成值完全由用户决定，与底层数据库无关。用户需要维护主键值，在调用session.save()之前要指定主键值。 Hilo Hilo使用高低位算法生成主键，高低位算法使用一个高位值和一个低位值， Hibernate相关书籍 然后把算法得到的两个值拼接起来作为数据库中的唯一主键。Hilo方式需要额外的数据库表和字段提供高位值来源。默认情况下使用的表是 hibernate_unique_key，默认字段叫作next_hi。next_hi必须有一条记录否则会出现错误。 特点：需要额外的数据库表的支持，能保证同一个数据库中主键的唯一性，但不能保证多个数据库之间主键的唯一性。Hilo主键生成方式由Hibernate 维护，所以Hilo方式与底层数据库无关，但不应该手动修改hi/lo算法使用的表的值，否则会引起主键重复的异常。 Increment Increment方式对主键值采取自动增长的方式生成新的主键值，但要求底层数据库的主键类型为long,int等数值型。主键按数值顺序递增，增量为1。 /特点：由Hibernate本身维护，适用于所有的数据库，不适合多进程并发更新数据库，适合单一进程访问数据库。不能用于群集环境。/ Identity Identity方式根据底层数据库，来支持自动增长，不同的数据库用不 Hibernate相关书籍 同的主键增长方式。 特点：与底层数据库有关，要求数据库支持Identity，如MySQl中是auto_increment, SQL Server 中是Identity，支持的数据库有MySql、SQL Server、DB2、Sybase和HypersonicSQL。 Identity无需Hibernate和用户的干涉，使用较为方便，但不便于在不同的数据库之间移植程序。 Sequence Sequence需要底层数据库支持Sequence方式，例如Oracle数据库等 特点：需要底层数据库的支持序列，支持序列的数据库有DB2、PostgreSql、Oracle、SAPDb等在不同数据库之间移植程序，特别从支持序列的数据库移植到不支持序列的数据库需要修改配置文件。 Native Native主键生成方式会根据不同的底层数据库自动选择Identity、Sequence、Hilo主键生成方式 特点：根据不同的底层数据库采用不同的主键生成方式。由于Hibernate会根据底层数据库采用不同的映射方式，因此便于程序移植，项目中如果用到多个数据库时，可以使用这种方式。 UUID UUID使用128位UUID算法生成主键，能够保证网络环境下的主键唯一性，也就能够保证在不同数据库及不同服务器下主键的唯一性。 特点：能够保证数据库中的主键唯一性，生成的主键占用比较多的存贮空间 Foreign GUID Foreign用于一对一关系中。GUID主键生成方式使用了一种特殊算法，保证生成主键的唯一性，支持SQL Server和MySQL 包的作用net.sf.hibernate.* 该包的类基本上都是接口类和异常类 net.sf.hibernate.cache.* JCS的实现类 net.sf.hibernate.cfg.* 配置文件读取类 net.sf.hibernate.collection.* Hibernate集合接口实现类，例如List，Set，Bag等等，Hibernate之所以要自行编写集合接口实现类是为了支持lazy loading net.sf.hibernate.connection.* 几个数据库连接池的Provider net.sf.hibernate.dialect.* 支持多种数据库特性，每个Dialect实现类代表一种数据库，描述了该数据库支持的数据类型和其它特点，例如是否有AutoIncrement，是否有Sequence，是否有分页sql等等 net.sf.hibernate. eg.* Hibernate文档中用到的例子 net.sf.hibernate.engine.* 这个包的类作用比较散 net.sf.hibernate.expression.* HQL支持的表达式 net.sf.hibernate.hq.* HQL实现 net.sf.hibernate. id.* ID生成器 net.sf.hibernate.impl.* 最核心的包，一些重要接口的实现类，如Session，SessionFactory，Query等 net.sf.hibernate.jca.* JCA支持，把Session包装为支持JCA的接口实现类 net.sf.hibernate.jmx.* JMX是用来编写App Server的管理程序的，大概是JMX部分接口的实现，使得App Server可以通过JMX接口管理Hibernate net.sf.hibernate.loader.* 也是很核心的包，主要是生成sql语句的 net.sf.hibernate.lob.* Blob和Clob支持 net.sf.hibernate.mapping.* hbm文件的属性实现 net.sf.hibernate.metadata.* PO的Meta实现 net.sf.hibernate.odmg.* ODMG是一个ORM标准，这个包是ODMG标准的实现类 net.sf.hibernate.persister.* 核心包，实现持久对象和表之间的映射 net.sf.hibernate.proxy.* Proxy和Lazy Loading支持 net.sf.hibernate. ps.* 该包是PreparedStatment Cache net.sf.hibernate.sql.* 生成JDBC sql语句的包 net.sf.hibernate.test.* 测试类，你可以用junit来测试Hibernate net.sf.hibernate.tool.hbm2ddl.* 用hbm配置文件生成DDL net.sf.hibernate.transaction.* Hibernate Transaction实现类 net.sf.hibernate.type.* Hibernate中定义的持久对象的属性的数据类型 net.sf.hibernate.util.* 一些工具类，作用比较散 net.sf.hibernate.xml.* XML数据绑定 缓存管理Hibernate 中提供了两级Cache（高速缓冲存储器），第一级别的缓存是Session级别的缓存，它是属于事务范围的缓存。这一级别的缓存由hibernate管理的，一般情况下无需进行干预；第二级别的缓存是SessionFactory级别的缓存，它是属于进程范围或集群范围的缓存。这一级别的缓存可以进行配置和更改，并且可以动态加载和卸载。 Hibernate还为查询结果提供了一个查询缓存，它依赖于第二级缓存。 第一级缓存 第二级缓存 存放数据的形式 相互关联的持久化对象的散装数据 缓存的范围 事务范围，每个事务都有单独的第一级缓存进程范围或集群范围，缓存被同一个进程或集群范围内的所有事务共享 并发访问策略由于每个事务都拥有单独的第一级缓存，不会出现并发问题，无需提供并发访问策略由于多个事务会同时访问第二级缓存中相同数据，因此必须提供适当的并发访问策略，来保证特定的事务隔离级别数据过期策略没有提供数据过期策略。处于一级缓存中的对象永远不会过期，除非应用程序显式清空缓存或者清除特定的对象必须提供数据过期策略，如基于内存的缓存中的对象的最大数目，允许对象处于缓存中的最长时间，以及允许对象处于缓存中的最长空闲时间。 物理存储介质内存和硬盘 对象的散装数据首先存放在基于内存的缓存中，当内存中对象的数目达到数据过期策略中指定上限时，就会把其余的对象写入基于硬盘的缓存中。 缓存的软件实现 在Hibernate的Session的实现中包含了缓存的实现由第三方提供，Hibernate仅提供了缓存适配器(CacheProvider)。用于把特定的缓存插件集成到Hibernate中。启用缓存的方式只要应用程序通过Session接口来执行保存、更新、删除、加载和查询数据库数据的操作，Hibernate就会启用第一级缓存，把数据库中的数据以对象的形式拷贝到缓存中，对于批量更新和批量删除操作，如果不希望启用第一级缓存，可以绕过Hibernate API，直接通过JDBC API来执行指操作。用户可以在单个类或类的单个集合的粒度上配置第二级缓存。如果类的实例被经常读但很少被修改，就可以考虑使用第二级缓存。只有为某个类或集合配置了第二级缓存，Hibernate在运行时才会把它的实例加入到第二级缓存中。 用户管理缓存的方式第一级缓存的物理介质为内存，由于内存容量有限，必须通过恰当的检索策略和检索方式来限制加载对象的数目。Session的evict()方法可以显式清空缓存中特定对象，但这种方法不值得推荐。 第二级缓存的物理介质可以是内存和硬盘，因此第二级缓存可以存放大量的数据，数据过期策略的maxElementsInMemory属性值可以控制内存中的对象数目。管理第二级缓存主要包括两个方面：选择需要使用第二级缓存的持久类，设置合适的并发访问策略：选择缓存适配器，设置合适的数据过期策略。 一级缓存当应用程序调用Session的save()、update()、saveOrUpdate()、get()或load()，以及调用查询接口的 list()、iterate()或filter()方法时，如果在Session缓存中还不存在相应的对象，Hibernate就会把该对象加入到第一级缓存中。当清理缓存时，Hibernate会根据缓存中对象的状态变化来同步更新数据库。 Session为应用程序提供了两个管理缓存的方法： evict(Object obj)：从缓存中清除参数指定的持久化对象。 clear()：清空缓存中所有持久化对象。 二级缓存3.1. Hibernate的二级缓存策略的一般过程如下： 1) 条件查询的时候，总是发出一条select * from table_name where …. （选择所有字段）这样的SQL语句查询数据库，一次获得所有的数据对象。 2) 把获得的所有数据对象根据ID放入到第二级缓存中。 3) 当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；查不到，再查询数据库，把结果按照ID放入到缓存。 4) 删除、更新、增加数据的时候，同时更新缓存。 Hibernate的二级缓存策略，是针对于ID查询的缓存策略，对于条件查询则毫无作用。为此，Hibernate提供了针对条件查询的Query Cache。 3.2. 什么样的数据适合存放到第二级缓存中？ 1 很少被修改的数据 2 不是很重要的数据，允许出现偶尔并发的数据 3 不会被并发访问的数据 4 参考数据,指的是供应用参考的常量数据，它的实例数目有限，它的实例会被许多其他类的实例引用，实例极少或者从来不会被修改。 3.3. 不适合存放到第二级缓存的数据？ 1 经常被修改的数据 2 财务数据，绝对不允许出现并发 3 与其他应用共享的数据。 3.4. 常用的缓存插件 Hibernater 的二级缓存是一个插件，下面是几种常用的缓存插件： l EhCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，对Hibernate的查询缓存提供了支持。 l OSCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，提供了丰富的缓存数据过期策略，对Hibernate的查询缓存提供了支持。 l SwarmCache：可作为群集范围内的缓存，但不支持Hibernate的查询缓存。 l JBossCache：可作为群集范围内的缓存，支持事务型并发访问策略，对Hibernate的查询缓存提供了支持。 上述4种缓存插件的对比情况列于表9-3中。 表9-3 4种缓存插件的对比情况 缓 存 插 件 支 持 只 读 支持非严格读写 支 持 读 写 支 持 事 务 EhCache 是 是 是 OSCache 是 是 是 SwarmCache 是 是 JBossCache 是 是 它们的提供器列于表9-4中。 表9-4 缓存策略的提供器 缓 存 插 件 提供器（Cache Providers） Hashtable（只能测试时使用） org.hibernate.cache.HashtableCacheProvider EhCache org.hibernate.cache.EhCacheProvider OSCache org.hibernate.cache.OSCacheProvider 在默认情况下，Hibernate使用EhCache进行JVM级别的缓存。用户可以通过设置Hibernate配置文件中的hibernate.cache.provider_class的属性，指定其他的缓存策略，该缓存策略必须实现org.hibernate.cache.CacheProvider接口。 3.5. 配置二级缓存的主要步骤： 1) 选择需要使用二级缓存的持久化类，设置它的命名缓存的并发访问策略。这是最值得认真考虑的步骤。 2) 选择合适的缓存插件，然后编辑该插件的配置文件。 延迟加载延迟加载 Hibernate对象关系映射提供延迟的与非延迟的对象初始化。非延迟加载在读取一个对象的时候会将与这个对象所有相关的其他对象一起读取出来。这有时会导致成百的（如果不是成千的话）select语句在读取对象的时候执行。这个问题有时出现在使用双向关系的时候，经常会导致整个数据库都在初始化的阶段被读出来了。当然，你可以不厌其烦地检查每一个对象与其他对象的关系，并把那些最昂贵的删除，但是到最后，我们可能会因此失去了本想在ORM工具中获得的便利。 一个明显的解决方法是使用Hibernate提供的延迟加载机制。这种初始化策略只在一个对象调用它的一对多或多对多关系时才将关系对象读取出来。这个过程对开发者来说是透明的，而且只进行了很少的数据库操作请求，因此会得到比较明显的性能提升。这项技术的一个缺陷是延迟加载技术要求一个Hibernate会话要在对象使用的时候一直开着。这会成为通过使用DAO模式将持久层抽象出来时的一个主要问题。为了将持久化机制完全地抽象出来，所有的数据库逻辑，包括打开或关闭会话，都不能在应用层出现。最常见的是，一些实现了简单接口的DAO实现类将数据库逻辑完全封装起来了。一种快速但是笨拙的解决方法是放弃DAO模式，将数据库连接逻辑加到应用层中来。这可能对一些小的应用程序有效，但是在大的系统中，这是一个严重的设计缺陷，妨碍了系统的可扩展性。 Web层延迟加载 幸运的是，Spring框架为Hibernate 延迟加载 与DAO模式的整合提供了一 Hibernate有关书籍(10张) 种方便的解决方法。以一个Web应用为例，Spring提供了OpenSessionInViewFilter和OpenSessionInViewInterceptor。我们可以随意选择一个类来实现相同的功能。两种方法唯一的不同就在于interceptor在Spring容器中运行并被配置在web应用的上下文中，而Filter在Spring之前运行并被配置在 web.xml 中。不管用哪个，他们都在请求将当前会话与当前（数据库）线程绑定时打开Hibernate会话。一旦已绑定到线程，这个打开了的Hibernate会话可以在DAO实现类中透明地使用。这个会话会为 延迟加载 数据库中值对象的 视图 保持打开状态。一旦这个逻辑视图完成了，Hibernate会话会在Filter的doFilter方法或者Interceptor的postHandle方法中被关闭。 实现方法在web.xml中加入 hibernateFilterorg.springframework.orm.hibernate3.support.OpenSessionInViewFilter hibernateFilter *.do 性能优化初用HIBERNATE的人也许都遇到过性能问题，实现同一功能，用HIBERNATE与用JDBC性能相差十几倍很正常，如果不及早调整，很可能影响整个项目的进度。 大体上，对于HIBERNATE性能调优的主要考虑点如下： .数据库设计调整 .HQL优化 .API的正确使用(如根据不同的业务类型选用不同的集合及查询API) .主配置参数(日志，查询缓存，fetch_size, batch_size等) .映射文件优化(ID生成策略，二级缓存，延迟加载，关联优化) .一级缓存的管理 .针对二级缓存，还有许多特有的策略 .事务控制策略。 数据库设计a) 降低关联的复杂性 b) 尽量不使用联合主键 c) ID的生成机制，不同的数据库所提供的机制并不完全一样 d) 适当的冗余数据，不过分追求高范式 HQL优化HQL如果抛开它同HIBERNATE本身一些缓存机制的关联，HQL的优化技巧同普通的SQL优化技巧一样，可以很容易在网上找到一些经验之谈。 主配置a) 查询缓存，同下面讲的缓存不太一样，它是针对HQL语句的缓存，即完全一样的语句再次执行时可以利用缓存数据。但是，查询缓存在一个交易系统(数据变更频繁，查询条件相同的机率并不大)中可能会起反作用:它会白白耗费大量的系统资源但却难以派上用场。 b) fetch_size，同JDBC的相关参数作用类似，参数并不是越大越好，而应根据业务特征去设置 c) batch_size同上。 d) 生产系统中，切记要关掉SQL语句打印。 缓存a) 数据库级缓存:这级缓存是最高效和安全的，但不同的数据库可管理的层次并不一样，比如，在Oracle中，可以在建表时指定将整个表置于缓存当中。 b) SESSION缓存:在一个HibernateSESSION有效，这级缓存的可干预性不强，大多于HIBERNATE自动管理，但它提供清除缓存的方法，这在大批量增加/更新操作是有效的。比如，同时增加十万条记录，按常规方式进行，很可能会发现OutofMemeroy的异常，这时可能需要手动清除这一级缓存:Session.evict以及 Session.clear c) 应用缓存:在一个SESSIONFACTORY中有效，因此也是优化的重中之重，因此，各类策略也考虑的较多，在将数据放入这一级缓存之前，需要考虑一些前提条件： i. 数据不会被第三方修改(比如，是否有另一个应用也在修改这些数据?) ii. 数据不会太大 iii. 数据不会频繁更新(否则使用CACHE可能适得其反) iv. 数据会被频繁查询 v. 数据不是关键数据(如涉及钱，安全等方面的问题)。 缓存有几种形式，可以在映射文件中配置:read-only(只读，适用于很少变更的静态数据/历史数据)，nonstrict-read- write，read-write(比较普遍的形式，效率一般)，transactional(JTA中，且支持的缓存产品较少) d) 分布式缓存:同c)的配置一样，只是缓存产品的选用不同，oscache, jboss cache，的大多数项目，对它们的用于集群的使用(特别是关键交易系统)都持保守态度。在集群环境中，只利用数据库级的缓存是最安全的。 延迟加载a) 实体延迟加载:通过使用动态代理实现 b) 集合延迟加载:通过实现自有的SET/LIST，HIBERNATE提供了这方面的支持 c) 属性延迟加载: 方法选用a) 完成同样一件事，Hibernate提供了可供选择的一些方式，使用不同的编码方式对性能有不同的影响。比如：一次返回十万条记录，如果用 (List/Set/Bag/Map等)进行处理，很可能导致内存不够的问题，而如果用基于游标(ScrollableResults)或 Iterator的结果集，则不存在这样的问题。 b) Session的load/get方法，前者会使用二级缓存，而后者则不使用。 c) Query和list/iterator，如果去仔细研究一下它们，你可能会发现很多有意思的情况，二者主要区别(如果使用了Spring，在HibernateTemplate中对应find,iterator方法): i. list只能利用查询缓存(但在交易系统中查询缓存作用不大)，无法利用二级缓存中的单个实体，但list查出的对象会写入二级缓存，但它一般只生成较少的执行SQL语句，很多情况就是一条(无关联)。 ii. iterator则可以利用二级缓存，对于一条查询语句，它会先从数据库中找出所有符合条件的记录的ID，再通过ID去缓存找，对于缓存中没有的记录，再构造语句从数据库中查出，因此很容易知道，如果缓存中没有任何符合条件的记录，使用iterator会产生N+1条SQL语句(N为符合条件的记录数) iii. 通过iterator，配合缓存管理API，在海量数据查询中可以很好的解决内存问题，如: while(it.hasNext()){ YouObject object = (YouObject)it.next(); session.evict(youObject); sessionFactory.evice(YouObject.class, youObject.getId()); } 如果用list方法，很可能就出OutofMemory错误了。 集合的选用在Hibernate3.1文档的“19.5. Understanding Collection performance”中有详细的说明。 事务控制事务方面对性能有影响的主要包括:事务方式的选用，事务隔离级别以及锁的选用 a) 事务方式选用:如果不涉及多个事务管理器事务的话，不需要使用JTA，只有 JDBC的事务控制就可以。 b) 事务隔离级别:参见标准的SQL事务隔离级别 c) 锁的选用:悲观锁(一般由具体的事务管理器实现)，对于长事务效率低，但安全。乐观锁(一般在应用级别实现)，如在HIBERNATE中可以定义 VERSION字段，显然，如果有多个应用操作数据，且这些应用不是用同一种乐观锁机制，则乐观锁会失效。因此，针对不同的数据应有不同的策略，同前面许多情况一样，很多时候我们是在效率与安全/准确性上找一个平衡点，无论如何，优化都不是一个纯技术的问题，你应该对你的应用和业务特征有足够的了解。 批量操作即使是使用JDBC，在进行大批数据更新时，BATCH与不使用BATCH有效率上也有很大的差别。可以通过设置batch_size来让其支持批量操作。 举个例子，要批量删除某表中的对象，如“delete Account”，打出来的语句，HIBERNATE找出了所有ACCOUNT的ID，再进行删除，这主要是为了维护二级缓存，这样效率肯定高不了，在后续的版本中增加了bulk delete/update，但这也无法解决缓存的维护问题。也就是说，由于有了二级缓存的维护问题，HIBERNATE的批量操作效率并不尽如人意。 hibernate**工作原理：** 1、通过Configuration().configure();读取并解析hibernate.cfg.xml配置文件。 2、由hibernate.cfg.xml中的&lt;mappingresource=”com/xx/User.hbm.xml”/&gt;读取解析映射信息。 3、通过config.buildSessionFactory();//得到sessionFactory。 4、sessionFactory.openSession();//得到session。 5、session.beginTransaction();//开启事务。 6、persistent operate; 7、session.getTransaction().commit();//提交事务 8、关闭session; 9、关闭sessionFactory; hibernate**优点：** 1、封装了jdbc，简化了很多重复性代码。 2、简化了DAO层编码工作，使开发更对象化了。 3、移植性好，支持各种数据库，如果换个数据库只要在配置文件中变换配置就可以了，不用改变hibernate代码。 4、支持透明持久化，因为hibernate操作的是纯粹的（pojo）java类，没有实现任何接口，没有侵入性。所以说它是一个轻量级框架。 hibernate延迟加载： get不支持延迟加载，load支持延迟加载。 1、hibernate2对 实体对象和集合 实现了延迟加载 2、hibernate3对 提供了属性的延迟加载功能 hibernate延迟加载就是当使用session.load(User.class,1)或者session.createQuery()查询对象或者属性的时候 这个对象或者属性并没有在内存中，只有当程序操作数据的时候，才会存在内存中，这样就实现延迟加载，节省了内存的开销，从而提高了服务器的性能。 Hibernate的缓存机制 一级缓存：session级的缓存也叫事务级的缓存，只缓存实体，生命周期和session一致。不能对其进行管理。 不用显式的调用。 二级缓存：sessionFactory缓存，也叫进程级的缓存，使用第3方插件实现的，也只缓存实体，生命周期和sessionFactory一致，可以进行管理。 首先配置第3方插件，我们用的是EHCache，在hibernate.cfg.xml文件中加入 &lt;propertyname=”hibernate.cache.user_second_level_cache”&gt;true 在映射中也要显式的调用，&lt;cacheusage=”read-only”/&gt; 二级缓存之查询缓存：对普通属性进行缓存。如果关联的表发生了修改，那么查询缓存的生命周期也结束了。 在程序中必须手动启用查询缓存：query.setCacheable(true); 优化**Hibernate** 1、使用一对多的双向关联，尽量从多的一端维护。 2、不要使用一对一，尽量使用多对一。 3、配置对象缓存，不要使用集合缓存。 4、表字段要少，表关联不要怕多，有二级缓存撑腰。 hibernate 类与类之间关系 关联关系 聚集关系 继承关系 Hibernate继承关系映射策略分为三种：一张表对应一整棵类继承树、一个类对应一张表、每一个具体类对应一张表。]]></content>
      <categories>
        <category>Hibernate映射框架</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2.0框架分析]]></title>
    <url>%2F2019%2F04%2F17%2FYii2.0%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[加载composer 的自动加载器，支持了PSR-0 PSR-4 1require(__DIR__ . &apos;/../vendor/autoload.php&apos;); 进行常量的定义，并且声明了最基本的方法例如getVersion 1require __DIR__ . &apos;/BaseYii.php&apos;; 加载Yii自己的autoload加载器，从classmap中寻找，指定的类，如果没有找到，会解析名称到路径。 12spl_autoload_register([&apos;Yii&apos;, &apos;autoload&apos;], true, true);Yii::$classMap = require __DIR__ . &apos;/classes.php&apos;; todo 容器生成 1Yii::$container = new yii\di\Container(); 开始生成一个应用主体，并且加载了config配置，直接运行 1(new yii\web\Application($config))-&gt;run(); 主体生成 application is the base class for all web application classes. Yii::$app 是应用主体的实例，一个请求只会生成一个应用主体在Application类中，定义了初始的defaultRoute，以及coreComponent核心组件的列表，还有一些请求和相应相关的方法 继承链1web/application`=&gt;`base/application`=&gt;`base/Model`=&gt;`id/ServiceLocator`=&gt;`base/component`=&gt;`base/object`=&gt;`base/configurable 初始化主体的配置12345678910111213public function __construct($config = []) &#123; Yii::$app = $this; // 这样在任何地方都可以通过静态方法的方式，来调用应用主体 static::setInstance($this); // 将请求过来的的类实力，进行保存 $this-&gt;state = self::STATE_BEGIN; $this-&gt;preInit($config); // 进行config的初始化，给路径起别名，设置时区等，并且最后加载了核心组件 $this-&gt;registerErrorHandler($config); // 注册错误句柄，用来捕捉和处理错误的方法 Component::__construct($config); // &#125; 其中preInit会进行一个注册核心组件，这里web的入口进行了扩展，包含了request等 12345678910public function coreComponents() &#123; return array_merge(parent::coreComponents(), [ &apos;request&apos; =&gt; [&apos;class&apos; =&gt; &apos;yii\web\Request&apos;], &apos;response&apos; =&gt; [&apos;class&apos; =&gt; &apos;yii\web\Response&apos;], &apos;session&apos; =&gt; [&apos;class&apos; =&gt; &apos;yii\web\Session&apos;], &apos;user&apos; =&gt; [&apos;class&apos; =&gt; &apos;yii\web\User&apos;], &apos;errorHandler&apos; =&gt; [&apos;class&apos; =&gt; &apos;yii\web\ErrorHandler&apos;], ]); &#125; 讲configure格式为对象，存储到应用主体中 1234567public function __construct($config = []) &#123; if (!empty($config)) &#123; Yii::configure($this, $config); &#125; $this-&gt;init(); &#125; 组件注册这里我们来看下组件是如何注册到应用主体中的，这个-&gt; 实际上调用的是__Set魔术方法，那我们再看这个$this是什么，很明显是指yii\web\application 12345678public static function configure($object, $properties) &#123; foreach ($properties as $name =&gt; $value) &#123; $object-&gt;$name = $value; &#125; return $object; &#125; 我们从webapplication向parent一层一层的找，找到了__set 的定义，在basecomponent 123456789101112131415161718192021222324252627282930313233343536public function __set($name, $value) &#123; $setter = &apos;set&apos; . $name; if (method_exists($this, $setter)) &#123; // set property $this-&gt;$setter($value); return; &#125; elseif (strncmp($name, &apos;on &apos;, 3) === 0) &#123; // on event: attach event handler $this-&gt;on(trim(substr($name, 3)), $value); return; &#125; elseif (strncmp($name, &apos;as &apos;, 3) === 0) &#123; // as behavior: attach behavior $name = trim(substr($name, 3)); $this-&gt;attachBehavior($name, $value instanceof Behavior ? $value : Yii::createObject($value)); return; &#125; // behavior property $this-&gt;ensureBehaviors(); foreach ($this-&gt;_behaviors as $behavior) &#123; if ($behavior-&gt;canSetProperty($name)) &#123; $behavior-&gt;$name = $value; return; &#125; &#125; if (method_exists($this, &apos;get&apos; . $name)) &#123; throw new InvalidCallException(&apos;Setting read-only property: &apos; . get_class($this) . &apos;::&apos; . $name); &#125; throw new UnknownPropertyException(&apos;Setting unknown property: &apos; . get_class($this) . &apos;::&apos; . $name); &#125; 上面的set方法，会遍历config的属性，来交给不同的set方法处理，果然恰好存在了一个setComponents，用来处理组件 123456public function setComponents($components) &#123; foreach ($components as $id =&gt; $component) &#123; $this-&gt;set($id, $component); &#125; &#125; 最终组件配置就这样被注册到了$this-&gt;_definitions里面，后面我们可以通过$this-&gt;get($id) 来获取组件配置 123456789101112131415161718192021222324public function set($id, $definition) &#123; unset($this-&gt;_components[$id]); if ($definition === null) &#123; unset($this-&gt;_definitions[$id]); return; &#125; if (is_object($definition) || is_callable($definition, true)) &#123; // an object, a class name, or a PHP callable $this-&gt;_definitions[$id] = $definition; &#125; elseif (is_array($definition)) &#123; // a configuration array if (isset($definition[&apos;class&apos;])) &#123; $this-&gt;_definitions[$id] = $definition; &#125; else &#123; throw new InvalidConfigException(&quot;The configuration for the \&quot;$id\&quot; component must contain a \&quot;class\&quot; element.&quot;); &#125; &#125; else &#123; throw new InvalidConfigException(&quot;Unexpected configuration type for the \&quot;$id\&quot; component: &quot; . gettype($definition)); &#125; &#125; 注意这个init，并不是当前类下面的init方法，而是被webapplication 覆盖 12345public function init() &#123; $this-&gt;state = self::STATE_INIT; $this-&gt;bootstrap(); &#125; 同样bootstrap方法也被覆盖 12345678protected function bootstrap() &#123; $request = $this-&gt;getRequest(); Yii::setAlias(&apos;@webroot&apos;, dirname($request-&gt;getScriptFile())); Yii::setAlias(&apos;@web&apos;, $request-&gt;getBaseUrl()); parent::bootstrap(); &#125; 看下getRequest是怎么回事，跟踪代码，它通过get方法，来从_definitions中获取request对应的配置然后根据配置中的yiiwebrequest 来进行创建对象，其中$type 就是配置 12345678910111213141516public static function createObject($type, array $params = []) &#123; if (is_string($type)) &#123; return static::$container-&gt;get($type, $params); &#125; elseif (is_array($type) &amp;&amp; isset($type[&apos;class&apos;])) &#123; $class = $type[&apos;class&apos;]; unset($type[&apos;class&apos;]); return static::$container-&gt;get($class, $params, $type); // request 走的是这里 &#125; elseif (is_callable($type, true)) &#123; return static::$container-&gt;invoke($type, $params); &#125; elseif (is_array($type)) &#123; throw new InvalidConfigException(&apos;Object configuration must be an array containing a &quot;class&quot; element.&apos;); &#125; throw new InvalidConfigException(&apos;Unsupported configuration type: &apos; . gettype($type)); &#125; 进行完web层的引导之后，继续进行base层的引导，包括对配置中bootstrap的引导注册，会直接通过容器得到实例。（具体不详） 小结在上面的new的过程中，完成了组件的注册，配置的初始化，并且学到了get是createObject通过依赖注入的方法，获取组件对象 请求的处理前面所有的配置和准备都初始化完毕之后，要进行请求处理了。 这一句的run方法，就是处理请求的整个启动入口 1$application-&gt;run(); 使用handleRequest方法来处理请求，并且参数是request实例，其中handleRequest方法要看webapplication层的封装 1$response = $this-&gt;handleRequest($this-&gt;getRequest()); 调用resolve进行解析1list($route, $params) = $request-&gt;resolve(); 我们再看Urlmanager的时候，发现里面定义的routeParam是r也就是默认接受参数的值（重要）实际上下面这段代码完成的就是解析了$_GET的值，从里面寻找routeParam 定义的值（r）所代表的内容 1$result = Yii::$app-&gt;getUrlManager()-&gt;parseRequest($this); 这里要调用action方法了 12$this-&gt;requestedRoute = $route;$result = $this-&gt;runAction($route, $params); 创建控制器+调用action实际上runAction中的主要内容就是createController的实现： 12345678910// parts 分为两部分，0 是controller的实例，1 是实例里面的方法名称$parts = $this-&gt;createController($route);....../* @var $controller Controller */ // 这是一个跟踪优化，不然controller-&gt;runaction 就定位不了了list($controller, $actionID) = $parts;$oldController = Yii::$app-&gt;controller;Yii::$app-&gt;controller = $controller;$result = $controller-&gt;runAction($actionID, $params); 如果遇到了控制器，那么直接返回控制器对象和方法route的名称，这里route类似于action方法名称，代码略微繁琐，但是很清晰，具体实现就是 路由解析规则例如r=site 寻找controller，找到site控制器，直接实例化 例如r=site/index 构造控制器，并且id为site、route为index 例如r=site/index/test 发现没有找到控制器，那么从模块中获取，这里是重新构造id为site/index route为test，然后调用createControllerById 方法来获取控制器（具体不详，不过应该是通过namespace定位了） 而且createController直接返回了controller的实例 然后我们在createAction中找到解析action方法名称的代码例如r=site/index-test 那么下面对应的methodName就是actionIndexTest 1$methodName = &apos;action&apos; . str_replace(&apos; &apos;, &apos;&apos;, ucwords(implode(&apos; &apos;, explode(&apos;-&apos;, $id)))); 内容输出将调用action方法的值，进行返回，然后直接交给yii\web\Response作为data属性的一部分。最后调用send方法，进行输出。 12345678910111213public function send() &#123; if ($this-&gt;isSent) &#123; return; &#125; $this-&gt;trigger(self::EVENT_BEFORE_SEND); $this-&gt;prepare(); $this-&gt;trigger(self::EVENT_AFTER_PREPARE); $this-&gt;sendHeaders(); $this-&gt;sendContent(); $this-&gt;trigger(self::EVENT_AFTER_SEND); $this-&gt;isSent = true; &#125; 行为是如何注册到组件的呢？通过attacheBehavior注册行为之后，实际上是添加到了$this的_behaviors属性中 那么行为中的属性，就添加到了，_behaviors中 进行直接调用行为里面的方法的时候，实际上触发了yii\base\Component里面的__call魔术方法 END]]></content>
      <categories>
        <category>Yii框架</category>
      </categories>
      <tags>
        <tag>Yii2.0</tag>
      </tags>
  </entry>
</search>
